---
title: 얕은복사-깊은복사
author: 박재경
date: 2022-01-21
categories: [ETC, Python]
tag: [Python]
---

## mutable와  immutable

> mutable: 데이터의 값을 변화시킬 수 있다.
>
> immutable: 데이터의 값을 변화시킬 수 없다. 

<br>

| 자료형의 타입 | 변화 가능 여부 |
| ------------- | -------------- |
| list          | O (mutable)    |
| set           | O (mutable)    |
| dict          | O (mutable)    |
| int           | X (immutable)  |
| float         | X (immutable)  |
| str           | X (immutable)  |
| bool          | X (immutable)  |
| tuple         | X (immutable)  |

<br>

- 파이썬에서 변수에 값을 할당할 때 , 데이터를 직접적으로 변수에 저장하는 것이 아니다.

  변수는 데이터가 저장되어 있는 장소를 가리킴으로서 데이터를 참조한다. 

```python
# a는 '파이썬'이 저장되어 있는 메모리(객체)를 참조하고 있는 것이다. 
# 즉, a는 '파이썬'이라는 문자열을 저장한 것이 아닌 '파이썬'문자열이 위치한 저장장소를 가리키고 있다. 
a = '파이썬' 
b= '파이썬'
    
print(id(a), id(b))                   # 2302767247600 2302767247600
print(id('파이썬'))                    # 2302767247600


# 그러나 mutable한 데이터는 상황이 조금 다르다. 
# mutable한 데이터는 수정하고 변동시킬 수 있기 때문에 같은 값을 가진 새로운 리스트의 위치(주소)를 가르킨다. 
c = ['파이썬', '자바', 'C언어'] 
d = ['파이썬', '자바', 'C언어']          # 겉모습만 같은 새로운 객체 

print(id(c), id(d))                   # 2019960959552 2119960959552 
print(id(['파이썬', '자바', 'C언어']))   # 1921199609595
```

<br>

- 변수에 다른 변수를 할당하면( ex. `b = a` ) 다른 변수(`a`)가 참조하고 있었던 객체를 할당한다. 
  즉, 두 변수가 참조하고 있는 위치(주소)는 동일하다.  

```python
a = '파이썬'                         # a는 '파이썬'객체를 참조한다.
b = a                               # b는 '파이썬'객체를 참조한다. 

print(a, b)                         # 파이썬 파이썬
print(id(a), id(b))                 # 2302767247600 2302767247600 // 동일한 위치(주소)를 참조

b = '자바'                           # b는 '자바'객체를 참조한다.

print(a, b)                         # 파이썬 자바
print(id(a), id(b))                 # 2302767247600 2302767247600 // 둘이 다른 위치(주소)를 참조 
```

<br>

- 앞서 말했듯 mutable한 데이터의 경우 객체를 수정할 수 있다. 
  그렇다면 동일한 위치를 참조하고 있는 변수를 수정한다면 어떤 상황이 벌어질까?

```python
a = ['파이썬', '자바', 'C언어']
b = a

print(a, b)                         # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'C언어']
print(id(a), id(b))                 # 2162446316096 2162446316096 // 동일한 위치(주소)를 참조

b[2] = 'Go' # list 인자를 수정 

#변경된 사항이 참조된 위치(주소)에 있는 데이터에 적용되어 변수 a의 값도 변한다. 
print(a, b)                         # ['파이썬', '자바', 'Go'] ['파이썬', '자바', 'Go'] 
print(id(a), id(b))                 # 2162446316096 2162446316096


b = ['파이썬'] # 변수에 아예 다른 데이터를 할당. (재할당)

#b는 이제부터 ['파이썬']위치를 참조하기 때문에 a와 참조하는 위치(주소)가 다르다. 
print(a, b)                         # ['파이썬', '자바', 'Go'] ['파이썬']
print(id(a), id(b))                 # 2162446316096 2162454190464 // 다른 위치(주소)를 참조
```

**`b[2] = 'Go'`를 해도 변수a에 영향을 주지 않는 방법이 있을까. 🤔** 

<br>

## 얕은복사

> 얕은 복사는 앞에서 본 list 사례처럼 원본 객체의 위치(주소)를 복사하는 것을 말한다. 



그래서 이를 해결하기 위해서는 

> 함수나 연산을 통해 똑같은 형태의 새로운 값을 만들어서  다른 주소를 할당한다.
>
> (`b = a`처럼 변수 그대로 할당을 하지 않는다. ) 



### 슬라이싱 활용

```python
a = ['파이썬', '자바', 'C언어']
b = a[::]

print(a, b)                            # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'C언어']
print(id(a), id(b))                    # 2162446316096 1760665666496 // 할당하는 위치(주소)가 다름

b[2] = 'Go'                            # list 인자를 수정 

# 할당하는 위치(주소)가 다르기때문에 원본 변수에 변화를 일으키지 않는다. 
print(a, b)                            # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'Go'] 
print(id(a), id(b))                    # 2162446316096 1760665666496
```

<br>

### copy() 메서드 이용

```python
import copy
a = ['파이썬', '자바', 'C언어']
b = copy.copy(a)

print(a, b)                          # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'C언어']
print(id(a), id(b))                  # 2162446316096 1760665666496

b[2] = 'Go' 

print(a, b)                          # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'Go']
print(id(a), id(b))                  # 2162446316096 1760665666496
```

<br>

### list 형변환

```python
a = ['파이썬', '자바', 'C언어']
b = list(a)

print(a, b)                         # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'C언어']
print(id(a), id(b))                 # 2162446316096 1760665666496

b[2] = 'Go' 

print(a, b)                         # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'Go']
print(id(a), id(b))                 # 2162446316096 1760665666496
```

<br>

- 그런데 이런 얕은복사는 2차원 리스트와 같이 내부 객체들이 더 존재하는 경우, 내부 객체들의 주소까지 새로 할당하지 않는다. 

```python
a = ['파이썬', '자바', ['C언어', 'Go']]
b = a[::]

print(a[2][0], b[2][0])                  # C언어 C언어
print(id(a[2][0]), id(b[2][0]))          # 1940742547728 1940742547728 // 내부 객체들은 같은 위치(주소)를 할당
```

```python
# 이러한 얕은복사의 특징때문에 mutable한 데이터들은 scope가 달라도 변수의 내부 객체에 변화를 줄 수 있다. 
language = ['파이썬', '자바', 'Go']
def my_language(a):
    language[0] = 'Ruby'                 # 전역변수 선언을 하지 않아도 local에서 전역 변수를 읽고 변경 
    return language

print(my_language(language))             # ['Ruby', '자바', 'Go']
```

**만약 이런 상황을 바라지 않는 경우,  깊은복사를 사용해야 한다.** 

<br>

## 깊은복사

### deep.copy()메서드

내부 객체들까지 새로운 메모리로 ~:rocket:

```python
import copy
a = ['파이썬', '자바', ['C언어', 'Go']]
b = copy.deepcopy(a)

print(a[2][0], b[2][0])                    # C언어 C언어

#동일한 값이기 때문에 굳이 새로운 주소에 할당할 필요가 없음! 그래서 같은 주소에 위치한다. 
print(id(a[2][0]), id(b[2][0]))           # 2162446316096 2162446316096 

b[2][0] = 'Ruby'

print(a, b)                               # ['파이썬', '자바', ['C언어', 'Go']] ['파이썬', '자바', ['Ruby', 'Go']]
print(a[2], b[2])                         # ['C언어', 'Go'] ['Ruby', 'Go']

# 내부 객체들이 다른 위치(주소)를 할당하는 것을 확인할 수 있다. 
print(id(a[2]), id(b[2]))                 # 2162446316096 1905569176832
```

<br>

