---
title: 운영체제-기본-구조
author: 박재경
date: 2022-08-27
categories: [CS, 운영-체제]
tag: [cs, 운영-체제]
---

# 2장-운영체제-구조 

[강의 링크](https://core.ewha.ac.kr/publicview/C0101020140311132925816476?vmode=f)

<br>

## 1. 컴퓨터 시스템 구조

<br>

![image-20220827112738682](https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220827112738682.png)

<br>

- `CPU`
  - **메모리에 있는 instruction을 실행한다.**
  - CPU안에는 레지스터들과 modebit이 있다.
    - Modebit: CPU의 제어 권한이 현재 프로그램에 있는지 OS에 있는지 확인가능
  - 인터럽트 라인을 통해 I/O Device, disk와 통신한다. 
    - Device controller에게 일을 시킨다.
    - 일이 수행되었을 때, 인터럽트 라인을 통해 일이 끝난 것을 알게 된다. 
    - 인터럽트가 발생하면 OS에게 CPU를 넘긴다. 

- `Memory`

  - CPU의 작업 공간
  - CPU는 매 클럭 사이클 마다 memory에서 기계어를 읽어서 실행하게 된다. 

- `I/O Device, Disk`

  - Device를 전담하는 Device controller가 존재한다.  

  - 해당 device가 사용될 때, CPU가 Controller에게 일을 시킨다. 

  - Device controller들의 작업공간이 존재한다. 이를 Local Buffer라고 부른다. 

<br>

### 1) Mode bit

- 사용자가 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치가 필요하다.

- Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation을 지원한다.
  - **1: 사용자 모드로 사용자 프로그램을 수행한다.**
  - **0: 모니터 모드(커널 모드, 시스템 모드)로 OS 코드를 수행한다.**
- 보안을 해칠 수 있는 중요한 명령어는 **모니터 모드**에서만 수행가능한 `특권 명령`으로 규졍된다.
- 인터럽트 발생 시 하드웨어가 Mode bit을 0으로 바꾼다.
- 사용자 프로그램에게 CPU를 넘기기 전에 Mode bit을 1로 세팅한다.

<br>

| Mode bit | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| 1        | **사용자 모드** <br />제한된 instruction만 수행할 수 있다.   |
| 0        | **모니터 모드**<br />모든 instruction을 수행할 수 있다. <br />ex) I/O 장치,다른 프로그램의 메모리 공간에 접근이 가능하다. |

<br>

### 2) Timer

> CPU의 time sharing을 위해 필요하다. 
>
> 특정 프로그램이 CPU를 독점하는 것을 막는다. (인터럽트를 발생시킴으로)
{: .prompt-tip }

- 정해진 시간이 흐른 뒤, 운영체제에게 제어권이 넘기도록 인터럽트를 발생시킨다. 
- 타이머는 매 클럭 틱 때마다 1씩 감소한다.
- 타이머 값이 0이 되면 타이머 인터럽트가 발생한다. 
- 타이머는 현재 시간을 계산하기 위해서도 사용된다. 

즉, 타이머 인터럽트의 도움을 받아 여러 프로그램을 실행할 수 있게 된다. 

<br>

### 3) Device Controller

> I/O 장치를 전담하는 일종의 작은 cpu이다. (hardware)
{: .prompt-tip }

- 제어 정보를 위해 control register, status register를 가진다.
  - **CPU가 일을 시킬 때, 해당 레지스터를 통해 일을 명령(제어)**
  - ex) 출력해라
- Local Buffer를 가진다. (일종의 data regiseter)
  - **실제 데이터가 담겨있다.** 
  - ex) 출력할 데이터
- I/O는 실제 device와 local buffer 사이에서 일어난다.
- Device controller는 I/O가 끝났을 경우 인터럽트를 통해 CPU에 해당 사실을 알린다. 

<br>
**:speech_balloon: Device Driver (장치 구동기)**

OS 코드 중 각 장치 별 처리 루틴 (software)

<br>

### 4) DMA

> Direct memory Access: 직접 메모리에 접근할 수 있는 컨트롤러
>
> 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용된다. 
{: .prompt-tip }

- 원래는 메모리에 접근할 수 있는 것은 CPU만 가능했지만, DMA도 접근이 가능하다. 
- 만약 CPU와 DMA가 동시에 같은 메모리 주소에 접근한다면, Memory Controller가 중재한다. 
- I/O 장치가 인터럽트를 너무 자주 발생 시키기 때문에 CPU가 방해를 너무 많이 받는다.

- **그래서 CPU의 중재 없이 DMA가  Device의 Buffer Storage의 내용을 메모리에 block 단위로 직접 전송한다.**

- 바이트 단위가 아니라 Block 단위로 인터럽트를 발생시킨다. 

<br>

## 2. 입출력 수행

> 모든 입출력 명령은 특권 명령이다.
{: .prompt-tip }

- 시스템 콜: 사용자 프로그램이 운영체제에게 I/O를 요청한다.
- trap을 사용하여 인터럽트 벡터의 특정 위치로 이동한다.
- 제어권이 인터럽트 벡터가 가르키는 인터럽트 서비스 루틴으로 이동된다.
- 올바른 I/O 요청인지 확인 후, I/O를 수행한다.
- I/O 완료시, 제어권을 시스템 콜 다음 명령으로 옮긴다. 

<br>

### 1) 인터럽트

> 현재의 운영체제는 인터럽트에 의해 구동된다.
{: .prompt-tip }

| 분류      | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| Interrput | 하드웨어가 발생시킨 인터럽트                                 |
| Trap      | Exception: 프로그램이 오류를 범한 경우<br /><br />**System call: 프로그램이 커널 함수를 호출한 경우** <br />(사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것) |

- 인터럽트가 발생하면, 당한 시점의 레지스터와 program counter를 save한 후, CPU의 제어를 인터럽트 처리 루틴에 넘긴다. 
- 인터럽트 벡터: 해당 인터럽트의 처리 루틴 주소를 가지고 있다. 인터럽트 라인 별로 인터럽트 벡터가 존재한다. 
- 인터럽트 처리 루틴 (인터럽트 핸들러): 해당 인터럽트를 처리하는 커널 함수

<br>

### 2) 동기식 입출력과 비동기식 입출력

- **동기식 입출력 (Synchronous I/O)**
  - I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어간다.
  - 구현 방법 1
    - I/O가 끝날 때까지 CPU를 낭비시킬 수 있다.
    - 매 시점 하나의 I/O만 일어날 수 있다.
  - 구현 방법 2 (구현 방법 1의 단점을 커버)
    - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗는다.
    - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세운다.
    - 다른 프로그램에게 CPU를 준다. (I/O 요청을 보낸 프로그램은 어차피 현재 일을 못하기 때문에)
  - Read의 경우 I/O 작업의 결과가 필요해야 프로그램을 사용할 수 있기 때문에 일반적으로 기다리는 경우가 많다. 
- **비동기식 입출력 (Asynchronous I/O)**
  - I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어간다.
  - 즉, CPU는 커널에게 I/O 작업만 요청해놓고 다시 본인 일을 하러간다. 
  - Write의 경우, 비동기적으로 처리하는 경우가 많다. 

두 경우 모두 I/O의 완료는 인터럽트로 알려준다.

<br>

### 3) 입출력 명령어 저장 공간에 따른 분류

- I/O를 수행하는 special instruction에 의해
  - 메모리와 I/O가 별개의 어드레스 영역에 할당되는 것을 의미한다. 
  -  I/O를 사용하더라도 메모리의 용량은 감소하지 않는다.
  - Memory에 접근하는 명령어의 주소, I/O에 접근하는 명령어의 주소로 나뉜다.
- Memory Mapped I/O
  - 메모리와 I/O가 **하나의 연속된 address 영역에 할당**된다. 
  -  I/O가 차지하는 만큼 메모리 용량은 감소한다.

<br>

## 3. 메모리

### 1) 저장 장치 계층 구조

| 이름                | 특징                        | 비고                                                         |
| ------------------- | --------------------------- | ------------------------------------------------------------ |
| Registers           | 빠르다, 용량이 적다, 비싸다 | `휘발성` , CPU에서 직접 접근이 가능하다 (바이트 단위로 접근 가능) |
| Cache Memory (SRAM) | (캐싱 : 재사용 목적)        | `휘발성`,  CPU에서 직접 접근이 가능하다 (바이트 단위로 접근 가능) |
| Main Memory (DRAM)  |                             | `휘발성`,  CPU에서 직접 접근이 가능하다 (바이트 단위로 접근 가능) |
| MagneticDisk        |                             | `비휘발성`, CPU에서 직접 접근이 불가능하다 (섹터 단위로 접근 가능) |
| OpticalDisk         |                             | `비휘발성`, CPU에서 직접 접근이 불가능하다 (섹터 단위로 접근 가능) |
| Magnetic Tape       | 느리다, 용량이 많다, 싸다   | `비휘발성`, CPU에서 직접 접근이 불가능하다 (섹터 단위로 접근 가능) |

<br>

### 2) 프로그램의 실행 (메모리 load)

- 프로그램을 실행 파일 형태로 하드디스크에 저장되어 있다.

- 해당 프로그램을 실행시키게 되면, 해당 프로그램의 주소 공간 (address space)이 가상 메모리에 생성된다. 
  - 메모리 공간은 stack, code, data로 구성되어 있다. 
  - stack: 함수를 호출하거나 리턴할 때 데이터를 쌓아가거나 꺼내가는 공간.
  - code: cpu에서 실행할 기계어 코드 담고 있다.
  - data: 프로그램이 실행하는 변수와 같은 자료구조를 담고 있다. 

- 당장 실행에 필요한 부분만 메모리로 올라가서 프로세스가 된다. 
  - 사용이 안되면 메모리에서 쫓아낸다. 

<br>

### 3) 커널 주소 공간

| Code                                                         | Data (운영체제가 사용하는 자료 구조)                         | Stack                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- |
| 시스템 콜, 인터럽트 처리 코드<br />자원 관리를 위한 코드<br />편리한 서비스 제공을 위한 코드 | **`프로세스 관리`**<br />ProcessA의 PCB<br />ProcessB의 PCB<br /><br />**`하드웨어 관리`**<br /> CPU, Memory, Disck와 같은 하드웨어가 사용하는 자료 구조 | Process A의 커널 스택<br />Process B의 커널 스택<br />... |

<br>

### 4) 함수의 메모리 주소 

> 모든 프로그램은 함수구조로 구성되어 있다.
{: .prompt-tip }

- 사용자 정의 함수  `Process A의 Address space`  `usermode` 
  - 자신의 프로그램에서 정의한 함수
- 라이브러리 함수  `Process A의 Address space`  `usermode`
  - 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
  - 자신의 프로그램의 실행 파일에 포함되어 있다.
- 커널 함수  `Kernel Address space`  `kernelmode`
  - 운영체제 프로그램의 함수
  - **커널 함수의 호출 = 시스템 콜 (다른 공간에 있기 때문에 CPU 제어권을 넘겨야 한다)**

<br>
