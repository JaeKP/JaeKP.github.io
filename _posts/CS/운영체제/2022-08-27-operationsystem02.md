---
title: 운영체제-기본-구조
author: 박재경
date: 2022-08-27
categories: [CS, 운영-체제]
tag: [cs, 운영-체제]
---

# 2장-운영체제-구조 

[강의 링크](https://core.ewha.ac.kr/publicview/C0101020140311132925816476?vmode=f)

<br>

## 1. 컴퓨터 시스템 구조

<br>

![image-20220827112738682](https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220827112738682.png)

<br>

- `CPU`
  - **메모리에 있는 instruction을 실행한다.**
  - CPU안에는 레지스터들과 modebit이 있다.
    - Modebit: CPU의 제어 권한이 현재 프로그램에 있는지 OS에 있는지 확인가능
  - 인터럽트 라인을 통해 I/O Device, disk와 통신한다. 
    - Device controller에게 일을 시킨다.
    - 일이 수행되었을 때, 인터럽트 라인을 통해 일이 끝난 것을 알게 된다. 
    - 인터럽트가 발생하면 OS에게 CPU를 넘긴다. 

- `Memory`

  - CPU의 작업 공간
  - CPU는 매 클럭 사이클 마다 memory에서 기계어를 읽어서 실행하게 된다. 

- `I/O Device, Disk`

  - Device를 전담하는 Device controller가 존재한다.  

  - 해당 device가 사용될 때, CPU가 Controller에게 일을 시킨다. 

  - Device controller들의 작업공간이 존재한다. 이를 Local Buffer라고 부른다. 

<br>

### 1) Mode bit

- 사용자가 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치가 필요하다.

- Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation을 지원한다.
  - **1: 사용자 모드로 사용자 프로그램을 수행한다.**
  - **0: 모니터 모드(커널 모드, 시스템 모드)로 OS 코드를 수행한다.**
- 보안을 해칠 수 있는 중요한 명령어는 **모니터 모드**에서만 수행가능한 `특권 명령`으로 규졍된다.
- 인터럽트 발생 시 하드웨어가 Mode bit을 0으로 바꾼다.
- 사용자 프로그램에게 CPU를 넘기기 전에 Mode bit을 1로 세팅한다.

<br>

| Mode bit | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| 1        | **사용자 모드** <br />제한된 instruction만 수행할 수 있다.   |
| 0        | **모니터 모드**<br />모든 instruction을 수행할 수 있다. <br />ex) I/O 장치,다른 프로그램의 메모리 공간에 접근이 가능하다. |

<br>

### 2) Timer

> CPU의 time sharing을 위해 필요하다. 
>
> 특정 프로그램이 CPU를 독점하는 것을 막는다. (인터럽트를 발생시킴으로)
{: .prompt-tip }

<br>

- 정해진 시간이 흐른 뒤, 운영체제에게 제어권이 넘기도록 인터럽트를 발생시킨다. 
- 타이머는 매 클럭 틱 때마다 1씩 감소한다.
- 타이머 값이 0이 되면 타이머 인터럽트가 발생한다. 
- 타이머는 현재 시간을 계산하기 위해서도 사용된다. 

<br>

### 3) Device Controller

> I/O 장치를 전담하는 일종의 작은 cpu이다. (hardware)
{: .prompt-tip }

- 제어 정보를 위해 control register, status register를 가진다.
  - **CPU가 일을 시킬 때, 해당 레지스터를 통해 일을 명령(제어)**
  - ex) 출력해라
- Local Buffer를 가진다. (일종의 data regiseter)
  - **실제 데이터가 담겨있다.** 
  - ex) 출력할 데이터
- I/O는 실제 device와 local buffer 사이에서 일어난다.
- Device controller는 I/O가 끝났을 경우 인터럽트를 통해 CPU에 해당 사실을 알린다. 

<br>
**:speech_balloon: Device Driver (장치 구동기)**

OS 코드 중 각 장치 별 처리 루틴 (software)

<br>

### 4) DMA

> Direct memory Access: 직접 메모리에 접근할 수 있는 컨트롤러

- 원래는 메모리에 접근할 수 있는 것은 CPU만 가능했지만, DMA도 접근이 가능하다. 
- 만약 CPU와 DMA가 동시에 같은 메모리 주소에 접근한다면, Memory Controller가 중재한다. 
- I/O 장치가 인터럽트를 너무 자주 발생 시키기 때문에 CPU가 방해를 너무 많이 받는다.
- 그래서 이를 방지 하기 위해 DMA가 I/O 관련 업무를 

<br>

## 2. 입출력 수행

> 모든 입출력 명령은 특권 명령이다.

- 시스템 콜: 사용자 프로그램이 운영체제에게 I/O를 요청한다.
- trap을 사용하여 인터럽트 벡터의 특정 위치로 이동한다.
- 제어권이 인터럽트 벡터가 가르키는 인터럽트 서비스 루틴으로 이동된다.
- 올바른 I/O 요청인지 확인 후, I/O를 수행한다.
- I/O 완료시, 제어권을 시스템 콜 다음 명령으로 옮긴다. 

<br>

### 1) 인터럽트

> 현재의 운영체제는 인터럽트에 의해 구동된다.

| 분류      | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| Interrput | 하드웨어가 발생시킨 인터럽트                                 |
| Trap      | Exception: 프로그램이 오류를 범한 경우<br /><br />**System call: 프로그램이 커널 함수를 호출한 경우** <br />(사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것) |

- 인터럽트가 발생하면, 당한 시점의 레지스터와 program counter를 save한 후, CPU의 제어를 인터럽트 처리 루틴에 넘긴다. 
- 인터럽트 벡터: 해당 인터럽트의 처리 루틴 주소를 가지고 있다.
- 인터럽트 처리 루틴: 해당 인터럽트를 처리하는 커널 함수

<br>

### 2) 동기식 입출력과 비동기식 입출력

- 동기식 입출력
  - I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어간다.
  - 구현 방법1
    - I/O가 끝날 때까지 CPU를 낭비시킬 수 있다.
    - 매 시점 하나의 I/O만 일어날 수 있다.
  - 구현 방법 2
    - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗는다.
    - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세운다.
    - 다른 프로그램에게 CPU를 준다.
- 비동기식 입출력
  - I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어간다.

두 경우 모두 I/O의 완료는 인터럽트로 알려준다.

<br>

