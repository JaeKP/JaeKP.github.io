---
title: 컴퓨터구조-중앙-처리-장치
author: 박재경
date: 2022-08-02
categories: [CS, 컴퓨터-구조]
tag: [cs, 컴퓨터-구조]
---



## 중앙처리 장치 파트1

[강의링크](https://www.youtube.com/watch?v=-Y2-gdesND8&list=PLc8fQ-m7b1hCHTT7VH2oo0Ng7Et096dYc&index=18)

### 1) CPU 주요 요소

#### (1) 기억장치

- 레지스터의 집합
- 데이터 임시 저장 장소 이다. 
- 데이터와 프로그램을 메인메모리에 저장되지만, 이것들이 수행되기 위해서는 레지스터로 이동해야 한다. 
  - 명령어는 IR레지스터로 이동!
  - 데이터는 데이터 레지스터로 이동!

<br>

#### (2) 제어장치

-  CPU 명령어를 처리하는 회로의 집합이다.
- 논리 게이트와 요소들로 구성되어 있다.
  - 게이트 
  - 요소: 디코더, 멀티 플렉서, 인코더, 버퍼
  - 와이어
- 명령어에 따라서 연산 제어를 수행한다. 
  - 필요한 타이밍에 연산 제어를 한다. 

<br>

#### (3) 연산장치

- ALU
- 산술 연산, 논리 연산 및 시프트 연산을 수행한다.

<br>

### 범용 레지스터 구조 ( General Register Organization)

#### (1) 공용 ALU를 가진 레지스터 집합

> 소스 데이터를 어느 레지스터로 부터 가져와서 연산된 결과 값을 어떤 레지스터로 보낼 것인가. 
{: .prompt-tip }

<br>

![image-20220726091652897](https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220726091652897.png)

<br>

- 7개의 범용 레지스터
  - 연산에 사용할  데이터를 가져온다. 
  - 연산 결과를 저장한다. 
- 공통 bus
  - 버스를 활용하여 데이터를 이동시킨다. 
- 8x1 MUX 2개
  - `SELA`: 어떤 데이터를 가져오는가. 
  - `SELB`: 이항연산일 경우 또다른 오퍼레드를 가져오는가. 
- ALU
  - OPR: 연산 종류 결정
  - 연산결과를 어떤 레지스터로 보내는가 
- 3x8 디코더 1개
  - load입력이 1일때 레지스터의 값이 들어가기 때문에 (`SELD`)
  - 디코더를 활용해 어떤 레지스터에 데이터 결과를 load할 지 저장한다. 

**따라서 `SELA`, `SELB`, `오퍼레이션`, `SELD` 비트가 이미 결정되어 있어야 한다.** 

<br>

#### (2) 제어 워드 집합

![image-20220726092343221](https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220726092343221.png)

- SELA, SELB:  ALU 입력을 결정한다.
- SELD: ALU 출력 저장소를 결정한다. 
- OPR: 연산의 정류를 지정한다. 

<br>

### 2) 스택 구조 (Stack Organization)

![image-20220726093913890](https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220726093913890.png)

#### (1) 레지스터 스택

- SP(Stack Pointer)
  - 레지스터
  - 지금 스택의 가장 꼭대기. 즉 가장 위의 번지 수를 저장하고 있다. 
- FULL, EMPTY
  - 플립플롭
  - FULL: 스택이 꽉 차면 1이된다.
  - EMPTY:  스택이 비면 1이 된다. 

- PUSH 동작
  - SP <- SP +1 : 스택 포인터 증가
  - M[SP] <- DR: 스택포인터가 가리키는 주소의 메모리에 데이터 레지스터에 있는 값을 넣는다. 
  - IF (SP = 0) then (FULL <- 1): 만약 스택포인터가 0이면 (이전에 마지막 스택포인터를 가르키다가 0으로 돌아간 것) FULL 플립플롭을 1로 놓는다. 
  - EMPTY <- 0
- POP 동작
  - DR <- M[SP] : 스택포인터가 가리키는 메모리에 있는 값을 데이터 레지스터로 이동시킨다. 
  - SP <- SP - 1
  - IF (SP = 0 ) thend (EMPTY <- 1)
  - FULL <- 0

<br>

#### (2) 메모리 스택

<img src="https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220726094843599.png" alt="image-20220726094843599" style="zoom:67%;" />

- PUSH 동작
  - SP <- SP -1: down-ward grow 스택구조 이기 때문에 아래로 내려갈 수록 주소가 커진다. 
  - M[SP] <- DR 
- POP 동작
  - DR <- M[SP]
  - SP <- SP + 1

<br>

#### (2) 메모리 세그먼트

> 프로그램을 CPU가 동작시키기 위해 임의로 나눠놓은 메모리의 구획이다.
{: .prompt-tip }

<br>

- 모든 프로그램은 Code / Data / Stack(Heap)로 구획을 나눌 수 있다. 

- 하나의 세그먼트의 크기
  - MS-DOS / WIndows: 64KB
  - UNIX / Linux: N x 1KB 블록

<br>

#### (3) 스택 오버 플로우

> 스택의 크기를 벗어나는 SP 값
{: .prompt-tip }

<br>

- stack point가 더 이상 증가할 수 없는데, push를 한다면 발생한다. (error)
  - 메모리의 세그먼트 할당 크기가 제한이 있기 떄문이다. 
- 특히, Protected mode에서 발생된다. 
  - protected mode: 하나의 프로세스가 다른 프로세스의 메모리를 침범할 수 없다.

- 다른 메모리의 영역에 침범하지 않도록 한다.

<br>

#### (4) 스택 연산

<img src="https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220726124956510.png" alt="image-20220726124956510" style="zoom: 67%;" />

<br>

## 중앙처리 장치 파트2

[강의링크](https://www.youtube.com/watch?v=uQrRlccgSs4&list=PLc8fQ-m7b1hCHTT7VH2oo0Ng7Et096dYc&index=19)

### 1) 명령어 형식 (Instruction Format)

- 오퍼랜드 주소를 몇개로 표시하는가에 따라 나뉜다.
  - 3주소 명령어: source와 destination을 다 표시한다. 
    - 프로그램의 길이를 짤게 하지만, 명령어의 길이가 길어진다.
  - 2주소 명령어: 연산코드 + 오퍼랜드 1 + 오퍼랜드 2 
    - 가장 일반적이다. 
  - 1주소 명령어: 연산 코드 + 오퍼랜드 (누산기에 의해 데이터를 처리한다)
  - 무주소 명령어: 주소가 필요없다. 연산코드만 존재한다. (ex. stack)


<br>

### 2) 어드레싱 모드 (Addressing Mode)

> 연산에 사용될 데이터가 기억장치의 어디에 위치하는 지를 지정하는 방법
{: .prompt-tip }

<br>

#### (1) 다양한 어드레싱 모드를 사용하는 이유

> 제한된 명령어 비트로 오퍼랜드를 지정하기 때문이다.
{: .prompt-tip }

- Pointer, couter Indexing기능
- 프로그램 재배치 (relocation) 편의를 제공한다.
  - 프로그램 융통성을 위해 사용된다. 

- 명령어 주소 필드 최소화

<br>

#### (1) 직접 주소 모드

- 명령어의 주소 부분이 유효주소 (EA)를 표시한다.
- 분기 명령에서는 실제 분기 주소를 표시한다. 

<br>

#### (2) 간접 주소 모드

- 명령어의 주소 부분에 유효주소를 지정하는 주소 표시방법이다.
  - 다양한 간접 주소 모드를 사용할 수 있다. 
  
  - 상대 주소 모드
  - 인덱스 어드레싱 모드
  - 베이스 레지스터 어드레싱 모드

<br>

✅`유효주소 계산 예시`

![image-20220726191307906](https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220726191307906.png)

<br>

### 3) 데이터 전송과 처리 (Data Transfer and Manipulation)

#### (1) ALU가 처리하는 명령어

- 산술 명령어
- 논리 연상 및 비트 처리 명령어
- 시프트 명령어

<br>

### 4) 프로그램 제어 (Program Control)

#### (1) 상태 비트 조건

<img src="https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220726192046061.png" alt="image-20220726192046061" style="zoom:67%;" />

<br>

- 상태비트를 확인하고 조건에 따라 프로그램을 제어한다. 

- `C`: ALU 출력 캐리 값
- `S`: AC의 부호 비트
- `Z`: AC 값의 zero 여부
- `V`: 연산 결과 오버플로우 여부

<br>

#### (2) 조건부 분기 명령어

- 조건 값이 어떤 값이냐에 따라 분기를 하느냐 마느냐를 나누는 경우의 수
- 상태 비트에 따라서 분기한다. 

<br>

![image-20220726192649518](https://raw.githubusercontent.com/JaeKP/image_repo/main/img/image-20220726192649518.png)

<br>

#### (3) 서브루틴 

- Call

  -  `SQ <- SP-1 `

  - `M[SP] <- PC`:  복귀주소를 스택에 push 한다.

  - `PC <- effective address`: 내가 가야할 주소를 pc에 넣는다.

- Return

  - `PC <- M[SP]`: 복귀 주소로!
  - `SP <- SP +1`

- 순환 서브 루틴 (recursive Subroutine)
  - 서브루틴이 자기 자신을 호출한다.
  - 순환 call이 return 주소를 지워버리는 것을 방지하기 위하여 스택에 return 주소를 저장한다. 
    - 재귀함수를 돌리면 하나하나씩 스택에 복귀주소를 push되고 pop된다. 

<br>

#### (4) 프로그램 인터럽트

- 인터럽트를 처리하고 돌아오는 복귀주소를 스택에 저장하게 된다. 
- 서브루틴과의 차이점
  - 시스템 내, 외부적 신호에 의하여 프로그램 진행이 변경된다.
  - 인터럽트 처리 루틴의 주소는 하드웨어 적으로 결정되어 있다.
  - PC 값만 아니라 CPU의 다른 상태를 나타내는 정보도 대피한다. (메모리(스택)에 저장한다.)
- PSW (Program Status Word)
  - 인터럽트가 발생할 때 저장되는 CPU 정보
  - PSW로 저장되는 데이터
    1. 프로그램 카운터(PC)의 값
    2. 모든 레지스터의 값
    3. 상태 조건 비트 (C, S, V, Z)



:white_check_mark: `인터럽트 형태`

- 외부 인터럽트
  - 입출력 장치, 타이밍 장치, 전원 등 외부 요소에 의하여 발생한다.
- 내부 인터럽트
  - 불법적인 명령이나 데이터를사용할 때 발생한다.
  - ex) 오버 플로우, divided bt 0, segment fault 등
- 소프트웨어 인터럽트
  - 명령어의 수행에 의하여 발생한다.
  - Supervisior call 명령, System call

<br>

### 5) 간소화된 명령어 집합 컴퓨터 (RISC)

> 명령어가 줄어든 CPU
{: .prompt-tip }

<br>

#### (1) 정의

- CISC(complex Instruction Set Computer) 에 비하여 새로운 설계 개념을 제시한다.
- 새로운 마이크로 아키텍쳐와 명령어 구조를 제시했다.
- 명령어가 많으면, 명령어 하나에 따를 제어장치를 만들어야 한다. 즉, 명령어가 많으면 제어장치가 커지고 복잡해질 수 있다.
  - 제어장치가 줄어든 빈자리를 레지스터로 채워 넣는다.
- CISC보다 간단한 구조, 빠른 처리속도, 높은 효율을 자랑한다. 

| CISC                                                         | RISC                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 많은 수의 명령어 <br />특별한 명령을 수행하는 일부 명령어는 자주 사용되지 않음 | 상대적으로 적은 수의 명렁어                                  |
| 다양한 어드레싱 모드<br />                                   | 상대적으로 적은 수의 어드레싱 모드<br />메모리 참조는 load/store 명령으로만 제한한다. |
| 가변 길이 명령어 형식                                        | 고정된 길이의 명령어 형식 사용                               |
| 메모리에서 피연산자 처리                                     | 모든 동작은 CPU 내 레지스터에서 수행한다.                    |
|                                                              | 단일 사이클의 명령어 실행                                    |
|                                                              | 하드 와이어 제어 방식 사용                                   |

<br>

#### (2) 특징

- 적은 수의 명령어로 인한 장점
  - 제어 장치의 간소화로 여유 공간 확보
  - 많은 수의 레지스터 (128개 이상)
  - 제어장치를 하드 와이어 방식으로 구현
- 효과적인 명령어 파이프라인 사용
- 프로시저의 빠른 호출 / 복귀를 위한 중첩된 레지스터 윈도우 사용
- 빠르고 효과적인 구조의 컴파일러 
- 고정 길이 명령어 사용으로 인한 간단한 디코딩
- 단일 사이클의 명령어 실행

<br>

:white_check_mark: `중첩된 레지스터 윈도우`

- 프로시저에 사용할 파라미터를 전달한다.
- 중첩된 윈도우를 통하여 보호모드에서 빠른 데이터를 전달한다.
  - CPU에서 여러개의 프로시저(함수 혹은 하나의 프로세서)를 실행할 때, 프로시저간 데이터를 전달하려면 OS의 도움을 받아 전달해야 한다. 
  - 그런데 공통영역을 사용할 수 있도록 만들고 해당 공간에 데이터를 던지면 간편하게 데이터를 전달할 수 있다. 
- 많은 수의 레지스터로 인한 구조적 장점이 있다. 

<br>