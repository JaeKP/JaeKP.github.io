---
title: Tree
author: 박재경
date: 2022-03-16
categories: [Algorithm, basics]
tag: [Algorithm]
---

## 1. 트리

> 비선형 구조

- **트리는 무향 그래프이다.** 
  - **그런데 트리를 저장할때는 유향 그래프 형식으로 저장한다. (부모-> 자식의 형태로만 탐색할 수 있도록!)**
  - **루트가 정해져 있을 수도 있다.**
- **트리는 연결 컴포넌트 (Connected compoent)이다.**
  - **트리에 속한 임의의 두 정점 u,v, 사이에 경로가 반드시 하나만 존재해야 한다. (그래프와 가장 큰 차이점)**
- **트리는 싸이클이 없다.** 
  - **그래서 트리를 순회할 때 그래프와 달리(bfs, dfs) 방문표시를 안한다.**
  - **어차피 한 번 간 곳을 다시 갈 일이 없으니까!** 
  - **트리에 속한 정점의 수가|V|개라면, 간선의 갯수는 |V-1|개이다.**

- 원소들 간에 1:n 관계를 가지는 자료구조이다.
- 원소들간에 계층관계를 가지는 계층형 자료구조이다.
- 상위 원소에서  하위 원소로 내려가면서 확장되는 트리모양의 구조이다. 

<br>

| 트리 용어               | 설명                                                      |
| ----------------------- | --------------------------------------------------------- |
| 노드(node)              | 트리의 원소. ( = 정점:vertex )                            |
| 간선(edge)              | 노드를 연결하는 선. 부모 노드와 자식 노드를 연결한다.     |
| 루트(root node)         | 트리의 시작 노드.                                         |
| 형제 노드(sibling node) | 같은 부모 노드의 자식 노드들.                             |
| 조상 노드               | 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들. |
| 서브 트리(sub tree)     | 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리.        |
| 자손 노드               | 서브 트리에 있는 하위 레벨의 노드들.                      |
| 노드의 차수             | 노드의 연결된 **자식 노드**의 수이다.                     |
| 트리의 차수             | 트리에 있는 노드의 차수 중에서 가장 큰 값이다.            |
| 단말 노드(리프 노드)    | 차수가 0인 노드. 자식 노드가 없는 노드이다.               |
| 노드의 높이             | 루트에서 노드에 이르는 **간선의 수**이다. (노드의 레벨)   |
| 트리의 높이             | 트리에 있는 노드의 높이 중에서 가장 큰 값. (최대 레벨)    |

<br>

**`언제 사용하는가`**

1. 부모- 자식 관계를 저장한다. 
2. 계층적 구조 (포함 관계)를 표현한다. 
3. 각 정점마다 자식 정보를 저장, 필요하면 부모 정보도 저장한다.

<br>

## 2. 이진 트리

-  모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리.
- 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리이다.
  - 왼쪽 자식 노드
  - 오른쪽 자식 노드
- **레벨 i에서의 노드의 최대 개수는 `2**i` 개이다.**
- **높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 `h+1`개가 되며, 최대 개수는 `2**(h+1) - 1`개가 된다.**

<br>

### 1) 이진트리의 종류

#### (1) 포화 이진 트리

> 모든 레벨에 노드가 포화상태로 차 있는 이진 트리이다.

- 리프노드를 제외한 모든 노드들이 2개의 노드를 가지고 있다. 
- 루트를 1번으로 하여  `2**(h+1) - 1`까지 정해진 위치에 대한 노드 번호를 가진다.

<br>

#### (2) 완전 이진 트리

> 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진트리.

- 높이가 h이고 노드 수가 n개 일때, (단, h+1 <= n < 2**(h+1) - 1 ) 포화 이진트리의 노드 번호 1번 부터 n번까지 빈 자리가 없는 이진 트리
- 즉 싱글 노드의 높이에서만 빈자리가 있다. 

<br>

#### (3) 편향 이진 트리

> 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리 

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
  - 왼쪽 편향 이진 트리
  - 오른쪽 편향 이진 트리

<br>

### 2) 이진트리 순회

> 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말한다. 
> 트리는 비선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없다. 
>
> 따라서 특별한 방법이 필요하다. 

순회: 트리의 노드들을 체계적으로 방문하는 것.

#### (1) 전위순회 (VLR)

> 부모 노드를 방문 후, 자식 노드를 좌, 우 순서로 방문한다.

1. 현재 노드 n을 방문하여 처리한다. (V)
2. 현재 노드 n의 왼쪽 서브트리로 이동한다. (L)
3. 현재 노드 n의 오른쪽 서브트리로 이동한다. (R)

<br>

#### (2) 중위순회 (LVR)

> 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문한다. 
>
> 이진탐색트리에서 중위 순회를 하면 오름차순으로 정렬된 값을 구할 수 있다. 

1. 현재 노드 n의 왼쪽 서브트리로 이동한다. (L)
2. 현재 노드 n을 방문하여 처리한다. (V)
3. 현재 노드 n의 오른쪽 서비트리로 이동한다. (R)

<br>

#### (3) 후위순회 (LRV)

> 자식 노드를 좌우 순서로 방문한 후, 부모노드로 방문한다.

1. 현재 노드 n의 왼쪽 서브트리로 이동한다. (L)
2. 현재 노드 n의 오른쪽 서브트리로 이동한다. (R)
3. 현재 노드 n을 방문하여 처리한다. (V)

<br>

### 3) 이진트리의 표현

#### (1) 배열

> 노드 번호를 배열의 인덱스로 사용한다. 

1. 이진 트리에 각 노드 번호를 부여한다.
2. 루트의 번호를 1로한다. (그래서 한 개 더 많은 배열을 만든다. -배열의 인덱스는 0부터 시작하기 때문에)
3. 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 `2**n`부터 `2**(n+1) - 1`까지 번호를 부여한다.  

<br>

#### (2) 부모 번호를 인덱스로 자식번호를 저장한다. 

```python
'''
4
1 2 1 3 3 4 3 5
'''
E = int(input())   # edge 수
arr = list(map(int,input().split()))
V = E + 1          # 정점 수 == 1번부터 V번까지 정점이 있을때 마지막 정점

# 부모번호를 인덱스로 자식번호를 저장한다.
ch1 = [0]*(V+1)    # 정점 번호에 0이 없기때문에 0으로 채워놓는다. 
ch2 = [0]*(V+1)

for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    if ch1[p] == 0: # 아직 자식이 없는 경우
        ch1[p] = c
    else: 
        ch2[p] = c
```

<br>

- **[부록] 전위 순회를 해보자.**

```python
def pre_order(v):
    if v:        # 0번 정점이 없으므로-> 0번은 자식이 없는 경우를 표시한다.
        print(v) # visit(v)
        pre_order(ch1[v])
        pre_order(ch2[v])
    
pre_order(1)    # 1 2 3 4 5 (트리 전부 순회)
pre_order(3)    # 3 4 5(서브트리만 순회)
```

<br>

- **[부록2] 중위 순회를 해보자**

```python
def in_order(v):
    if v:
        in_order(ch1[v])
        print(v)
        in_order(ch2[v])

in_order(1)    # 2 1 4 3 5 
```

<br>

- **[부록3] 후위 순회를 해보자**

```python
def post_order(v):
    if v:
        post_order(ch1[v])
        post_order(ch2[v])
        print(v)
        
post_order(1)   # 2 4 5 3 1
```

<br>

#### (3) 자식 번호를 인덱스로 부모번호를 저장한다.

```python
'''
4
1 2 1 3 3 4 3 5
'''
E = int(input())   #
arr = list(map(int,input().split()))
V = E + 1         

# 자식 번호를 인덱스로 부모 번호를 저장한다. 
par = [0] * (V + 1)

for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    par[c] = p
    
print(*par)    # 0 0 1 1 3 3 
```

<br>

- **[부록] root 찾기**

```python
root = 0
for i in range(1, V+1):
    if par[i] == 0:
        root = i
        break

print(root)
```

<br>

- **[부록2] 조상찾기**

```python
c = 5          # 정점 c의 조상찾기
anc = []
while par[c] != 0:
    anc.append(par[c])
    c = par[c]
    
print(*anc)    # 3 1
```

<br>

#### (4) 연습문제

```python
'''
13 12
1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
'''
V, E = map(int, input().splite)
arr = list(map(int, input().split()))

L = [0] * (V + 1) # 왼쪽 자식
R = [0] * (V + 1) # 오른쪽 자식
P = [0] * (V + 1) # 부모

for i in range(0, E*2, 2):
    p, c = arr[i], arr[i+1]
    # p(부모)를 인덱스로 사용
    if L[p] == 0:
        L[p] = c
    else:
        R[p] = c
    P[c] = p
```

<br>

- bfs로 구현해본다면?

```python
def bfs(s):
    Q = [s]
    while Q:
        v = Q.pop(0)
        if v == 0:
            continue
        else:
            print(v, end=' ')
            Q.append(L[v])
            Q.append(R[v])
bfs(1)
```

<br>

#### (5) 완전 이진트리

완전 이진 트리의 경우 노드 번호는 다음과 같은 성질을 갖는다. 

<img src="https://user-images.githubusercontent.com/72687619/158569592-5265e9e4-49c7-470b-9dec-d9287ba0ff9e.png" style="zoom:80%;" >

<br>

| 노드번호의 성질                                 | 결과      | 예시 (`i = 5`, `n = 2`)                          |
| ----------------------------------------------- | --------- | ------------------------------------------------ |
| 노드 번호가 i인 노드의 부모 노드 번호는?        | `i//2`    | 2                                                |
| 노드 번호가 i인 노드의 왼쪽 자식 노드 번호는?   | `2*i`     | 10                                               |
| 노드 번호가 i인 노드의 오른쪽 자식 노드 번호는? | `2*i + 1` | X <br />(마지막 노드의 값보다 작거나 커야 한다.) |
| 레벨 n의 노드 번호 시작 번호는?                 | `2**n`    | 4                                                |

<br>

- 노드번호 성질을 이용하여 순회를 한다면, 마지막 노드의 번호만 알면 구할 수 있다. 

```python
def pre_order(v):
    global last
    if c <= last:   # 마지막 정점 번호 이내
        print(v)   
        pre_order(v*2)   # 왼쪽 자식정점 방문
        pre_order(v*2+1) # 오른쪽 자식정점 방문
```

<br>

#### (6) 수식트리

> 수식을 표현하는 이진 트리
>
> 수식 이진트리라고 부르기도 한다. 

- 연산자는 루트 노드이거나 가지 노드이다.
- 피연산자는 모두 잎 노드이다. 

<br>
<img src="https://user-images.githubusercontent.com/72687619/158571744-7434879b-9e51-4205-a495-171d69d245a7.png">

- 중위 순회: `A/B*C*D+E`
- 후위 순회: `AB/C*D*E+`
- 전위 순회:`+**/ABCDE`

<br>

## 3. 이진 탐색 트리

> 탐색작업을 효율적으로 하기 위한 자료구조이다.

- 모든 원소는 서로 다른 유일한 키를 갖는다.
- key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
- 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리이다.
- **중위 순회하면 오른차순으로 정렬된 값을 얻을 수 있다.** 
- 이진 탐색과 search(탐색)하는 비용은 같지만 정렬하는 비용에 있어서 훨씬 효율적이다. 
  - **중간에 데이터를 삽입, 제거하고 다시 정렬할 때 훨씬 효율적이다.**


<br>

#### (1) 탐색연산

- 루트에서 시작한다.
- 탐색할 키 값 x를 루트 노드의 키 값과 비교한다.
  - (키 값x = 루트 노드의 키 값)인 경우: 원하는 원소를 찾았으므로 탐색연산 성공
  - (키 값x < 루트 노드의 키 값)인 경우: 루트노드의 왼쪽 서브트리에 대해서 탐색연산 수행
  - (키 값x > 루트 노드의 키 값)인 경우: 루트 노드의 오른쪽 서브트리에 대해서 탐색연산 수행
- 서브트리에 대해서 순환적으로 탐색 연산을 반복한다.

<br>

#### (2) 삽입연산

- 먼저 탐색 연산을 수행한다.
  - 삽입할 원소와 같은 원소가 트리에 있으면 삽입할 수 없으므로, 같은 원소가 트리에 있는지 탐색하여 확인한다.
  - 탐색에서 탐색 실패가 결정되는 위치가 삽입 위치가 된다.
- 탐색 실패한 위치에 원소를 삽입한다.

<br>

## 4. 힙 (heap)

> 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료 구조
> 우선수의 큐 등에서 활용할 수 있는 자료구조이다. 
>
> **=> 완전 이진트리의 특성을 잘 이해해야 한다.**
> **=> 완전 이진트리를 1차 배열로 만든다. 비어있지 않는 배열이기 때문에 인덱스를 통해 부모 자식관계에 접근할 수 있다.** 

- 최대 힙(max heap)
  - 키값이 가장 큰 노드를 찾기위한 완전 이진 트리
  - **{부모 노드의 키값 > 자식 노드의 키 값}**
  - 루트 노드: 키값이 가장 큰 노드 

- 최소 힙(min heap)
  - 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  - **{부모 노드의 키값 < 자식 노드의 키값}**
  - 루트 노드: 키값이 가장 작은 노드

새로운 요소가 삭제되거나 추가되어도 대소 관계는 유지되어야 한다!

<br>

#### (1) 삽입

> 스택! 을 생각하면 된다. 

- 값을 삽입하고 싶다면, 마지막 정점 번호 +1을 인덱스로 갖고 배열에 값을 append
- 최대 힙의 경우엔 추가된 노드의 값이 부모 노드보다 작은 값여야 하기 때문에 정점 번호를 이용하여 값을 비교한다.
- 최소 힙의 경우엔 추가된 노드의 값이 부모 노드보다 큰 값여야 하기 때문에 정점 번호를 이용하여 값을 비교한다. 

```python
'''
최대 100개의 정수 
최대 힙 
'''
def enq(n):
    global last
    # full 체크 => last < N(트리의 크기) // 공간을 정해놓고 진행하기 때문이다.
    last += 1
    tree[last] = n  # 완전이진트리 유지
    
    c = last        # 새로 추가된 정점을 자식으로
    p = c//2        # 완전이진트리에서의 부모 정점 번호
    while p >= 1 and tree[p] < tree[c]: # 부모가 있고, 자식의 키값이 더 크면 교환 
        tree[p], tree[c] = tree[c], tree[p]
        c = p
        p = c//2

# 포화이진트리의 정점 번호 1 ~ 100
tree = [0] * (101)
last = 0     # 마지막 정점 번호 

enq(3)
enq(2)
enq(4)
enq(7)
enq(5)
enq(1)
print(tree[1])   # 7
```

<br>

#### (2) 삭제

힙에서는 루트 노드의 원소만을 삭제할 수 있다.

루트 노드의 원소를 삭제하여 반환한다.  (힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다. )

```python
def deq():
    global last
    # empty체크 한다. => last > 0 
    tmp = tree[1]         # 루트의 key값
    tree[1] = tree[last]  # 마지막 정점의 키를 루트에 복사
    last -= 1             # 마지막 정점 삭제 (하나를 제거하는 것이기 때문에 쨋든 마지막 정점 번호는 -1을 해야 한다. )
    # 부모 > 자식 규칙 유지
    p = 1
    c = p * 2 # 왼쪽자식 노드 번호
    while c <= last:    # 왼쪽 자식이 있으면
        # 오른쪽 자식노드도 있고 더 크면 오른쪽 자식을 선택한다. 
        if c+1 <= last and tree[c]<tree[c+1]:  
            c += 1
        # 자식의 값이 더크면 교환한다.
        if h[p] >= H[c]:
            break
        tree[p], tree[c] = tree[c]. tree[p]
        p = c
        c = p * 2
            
    return tmp
```

<br>

#### (3) 힙 활용

힙을 활용하는 대표적인 2가지 예는 **특별한 큐의 구현 ( 우선 순위 큐) **와 **정렬**이다.

- 우선순위 큐를 구현하는 가장 효율적인 방법이 힙을 사용하는 것이다. 
- 완전 정렬보다 관리 비용이 적다.  (다른 정렬 방법은 자료를 삽입, 삭제할때 마다 많은 비용이 발생한다. )

<br>
