<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://jaekp.github.io/</id><title>Hello, World!</title><subtitle>기록 보관소</subtitle> <updated>2023-02-11T23:25:42+09:00</updated> <author> <name>박재경</name> <uri>https://jaekp.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://jaekp.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://jaekp.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 박재경 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>MongoDB-index를-활용하여-빠른-탐색하기</title><link href="https://jaekp.github.io/posts/mogodb04/" rel="alternate" type="text/html" title="MongoDB-index를-활용하여-빠른-탐색하기" /><published>2023-02-10T00:00:00+09:00</published> <updated>2023-02-10T00:00:00+09:00</updated> <id>https://jaekp.github.io/posts/mogodb04/</id> <content src="https://jaekp.github.io/posts/mogodb04/" /> <author> <name>박재경</name> </author> <category term="WEB" /> <category term="MongoDB" /> <summary> 1. Index 인덱스는 문서의 필드 값을 색인하여 콜렉션에서 데이터를 빠르게 탐색할 수 있도록 도와 빠른 쿼리 작업을 지원하고 데이터 정렬 및 집계 작업이 효율적으로 실행될 수 있도록 한다. 1) 정의 우리가 사전에서 단어를 빨리 찾을 수 있는 이유는 색인에 따른 정렬이 되어있기 때문이다. 데이터도 탐색을 효율적으로 하기위해 Index를 사용하여 효과적으로 데이터를 탐색할 수 있다. MongoDB에서 Index는 B-tree와 같은 데이터 구조를 유지하여 필드의 값을 문서의 위치로 매핑한다. (키랑 주소만 저장하여 데이터를 매핑) 그래서 쿼리가 실행될 때, MongoDB는 전체 콜렉션을 검색할 필요 없이 인덱스를 사용하여 관련 문서를 찾을 수 있게 된다. 예를 들어, 사용자를 나타내... </summary> </entry> <entry><title>MongoDB-Read-성능-향상시키기</title><link href="https://jaekp.github.io/posts/mogodb03/" rel="alternate" type="text/html" title="MongoDB-Read-성능-향상시키기" /><published>2023-02-06T00:00:00+09:00</published> <updated>2023-02-06T00:00:00+09:00</updated> <id>https://jaekp.github.io/posts/mogodb03/</id> <content src="https://jaekp.github.io/posts/mogodb03/" /> <author> <name>박재경</name> </author> <category term="WEB" /> <category term="MongoDB" /> <summary> 강의 링크 Read는 퍼포먼스에 많은 영향을 미친다. 서로 연결되어 있는 데이터를 가공, 조합해야 하기 때문에 DB 설계를 어떻게 하느냐 따라 성능이 달라진다. 만약 다음과 같은 콜렉션을 가진 데이터베이스가 있다고 가정해보자. 콜렉션 관계 User 1 Blog N 콜렉션 관계 User N Blog N Comment 1 { id: "Blogid", t... </summary> </entry> <entry><title>MongoDB-관계된-데이터-관리</title><link href="https://jaekp.github.io/posts/mogodb02/" rel="alternate" type="text/html" title="MongoDB-관계된-데이터-관리" /><published>2023-02-03T00:00:00+09:00</published> <updated>2023-02-03T00:00:00+09:00</updated> <id>https://jaekp.github.io/posts/mogodb02/</id> <content src="https://jaekp.github.io/posts/mogodb02/" /> <author> <name>박재경</name> </author> <category term="WEB" /> <category term="MongoDB" /> <summary> 강의 링크 1. 1:N 관계 1:N 관계는 한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미한다. 실제 DB를 설계할 때 자주 쓰이는 방식이다. 1) Schema 작성 일반적인 게시판을 생각하면, 하나의 유저가 여러 개의 게시글을 작성한다. 콜렉션 관계 유저 1 게시글 N 이러한 유저와 게시글의 관계를 1:N 관계라고 하는데, RDBMS의 경우에는 FK (Foregin Key)를 통해 한 테이블의 필드 중 다른 테이블을 연결하는 방식으로 표현한다. MongoDB에서도 마찬가지로 ID로 관계를 표현한다. ... </summary> </entry> <entry><title>MongoDB-환경설정과-간단한-CRUD구현하기</title><link href="https://jaekp.github.io/posts/mogodb01/" rel="alternate" type="text/html" title="MongoDB-환경설정과-간단한-CRUD구현하기" /><published>2023-02-03T00:00:00+09:00</published> <updated>2023-02-05T22:35:12+09:00</updated> <id>https://jaekp.github.io/posts/mogodb01/</id> <content src="https://jaekp.github.io/posts/mogodb01/" /> <author> <name>박재경</name> </author> <category term="WEB" /> <category term="MongoDB" /> <summary> 강의 링크 MongoDB는 NoSQL 데이터 베이스 중 하나이다. NoSQL은 Not Only SQL의 줄임말로 기존의 RDBMS의 한계를 극복하기 위해 만들어진 새로운 형태의 데이터 저장소이다. 관계형 DB는 표를 저장한다면 MongoDB는 객체를 저장한다고 생각하면 된다. 즉, 관계형 DB가 아니므로, RDMS처럼 고정된 스키마 및 JOIN이 존재하지 않는다. 데이터의 구조가 달라도 같은 테이블에 저장할 수 있다. (Schemaless) 관계형 베이스: database &amp;gt; table &amp;gt; row MogoDB: database &amp;gt; collection &amp;gt; document 1. Node.js와 MongoDB node.js는 비동기 프로그래밍이기... </summary> </entry> <entry><title>GraphQL-Apollo-Client</title><link href="https://jaekp.github.io/posts/graphql02/" rel="alternate" type="text/html" title="GraphQL-Apollo-Client" /><published>2023-02-02T00:00:00+09:00</published> <updated>2023-02-02T00:00:00+09:00</updated> <id>https://jaekp.github.io/posts/graphql02/</id> <content src="https://jaekp.github.io/posts/graphql02/" /> <author> <name>박재경</name> </author> <category term="WEB" /> <category term="GraphQL" /> <summary> 공식 문서 Apollo Client는 GraphQL API를 클라이언트 단에서 호출하기 위해서 사용한다. ( ReduxRTKQuery와 사용법이 유사하다!) 1. 환경 설정 # 패키지 설치 npm install @apollo/client graphql // App.js // apolloClient 모듈을 import한다. import { ApolloProvider } from '@apollo/client'; import { ApolloClient, InMemoryCache } from '@apollo/client' // GraphQL 서버로와 정보를 주고 받을 ApolloClient 객체를 만든다. const client = new ApolloClient({ uri: 'h... </summary> </entry> </feed>
