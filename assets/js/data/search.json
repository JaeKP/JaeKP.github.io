[ { "title": "MongoDB-index를-활용하여-빠른-탐색하기", "url": "/posts/mogodb04/", "categories": "WEB, MongoDB", "tags": "MongoDB", "date": "2023-02-10 00:00:00 +0900", "snippet": "1. Index 인덱스는 문서의 필드 값을 색인하여 콜렉션에서 데이터를 빠르게 탐색할 수 있도록 도와 빠른 쿼리 작업을 지원하고 데이터 정렬 및 집계 작업이 효율적으로 실행될 수 있도록 한다.1) 정의우리가 사전에서 단어를 빨리 찾을 수 있는 이유는 색인에 따른 정렬이 되어있기 때문이다. 데이터도 탐색을 효율적으로 하기위해 Index를 사용하여 효과적으로 데이터를 탐색할 수 있다.MongoDB에서 Index는 B-tree와 같은 데이터 구조를 유지하여 필드의 값을 문서의 위치로 매핑한다. (키랑 주소만 저장하여 데이터를 매핑)그래서 쿼리가 실행될 때, MongoDB는 전체 콜렉션을 검색할 필요 없이 인덱스를 사용하여 관련 문서를 찾을 수 있게 된다.예를 들어, 사용자를 나타내는 문서의 콜렉션이 있고 각 문서에 age라는 필드가 있는 데이터 베이스가 있다. age 필드에 인덱스를 생성하게 되면 MongoDB는 모든 문서를 검사할 필요 없이 특정 나이를 가진 모든 문서를 효율적으로 찾을 수 있게 된다.인덱스가 없다면, age가 30인 유저를 백만개의 데이터 중에서 찾을때 모든 콜렉션을 탐색한다.그래서 총 125ms가 소요되는 것을 아래의 이미지에서 확인할 수 있다.Index를 사용하면 총 10ms로 압도적으로 시간이 줄어드는 것을 확인할 수 있다. 인덱스를 사용하면, 모든 콜렉션을 탐색하는 것이 아니라 인덱스 정보를 Fetch하고 IXSCAN(인덱스 스캔)을 통해 데이터를 찾는 것을 확인할 수 있다.그러나 인덱스는 추가 디스크 공간을 사용하고, 각 문서에 기록할 때마다 관련 인덱스를 업데이트 해야하므로 쓰기 작업이 느려질 수 있다. 데이터를 생성할 때, Index도 생성하고 저장해야 하기 때문에 쓰기 작업이 느려진다. MongoDB는 모든 콜렉션에 대해 _id 필드에 대한 인덱스를 자동으로 생성하여 각 문서에 고유 식별자가 있어 효율적으로 위치를 지정할 수 있다. unique한 값에도 자동으로 index가 생성된다. 왜냐하면 중복인지 아닌지 확인하기 위해서는 탐색을 해야하기 때문에 index가 필요한 것이다.2) Index Selectivity MongoDB의 Index Selectivity는 특정 인덱스가 얼마나 정확하게 데이터를 검색하는지를 나타내는 지표다. Selectivity는 0에서 1 사이의 값으로 표시되며, 1에 가까울수록 인덱스의 검색 정확도가 높다.인덱스의 Selectivity는 인덱스를 사용하여 검색할 때 검색하는 값의 유일성에 따라 결정된다.예를 들어, 유일한 값이 있는 특정 필드에 대해서는 Selectivity가 1이 되어 검색 정확도가 높지만, 많은 값이 중복되는 필드에 대해서는 Selectivity가 낮아져 검색 정확도가 떨어질 수 있다.MongoDB는 검색 성능을 향상시키기 위해 Selectivity가 높은 인덱스를 우선적으로 사용하도록 최적화되어 있어, Selectivity가 높은 인덱스를 사용하여 검색 쿼리를 작성하면 검색 성능이 향상될 수 있다.예를 들어, name.last에 대한 인덱스와 age에 대한 인덱스가 있는 데이터 베이스가 있다. 이 데이터 베이스에서{\"name.last\": \"Hoeger\", age: 24} 와 조건이 일치한 결과를 탐색한다면 어떤 인덱스를 활용할까?이는 앞서 말했 듯, Selectivity가 높은 name.last 인덱스를 사용한다. (다양성이 더 많음)3) 구현MongoDB Compass에서 간단하게 Index를 생성 할 수도 있고, 코드로 생성할 수도 있다. Schema를 정의할 때, index 속성 사용 Schema의 Index 메서드 사용import { Schema, model, Types } from \"mongoose\";import { CommentSchema } from \"./Comment.js\";const BlogSchema = new Schema( { title: { type: String, required: true }, content: { type: String, required: true }, isLive: { type: Boolean, required: true, default: true }, user: { // 1. index 속성으로 인덱스 생성 _id: { type: Types.ObjectId, required: true, ref: \"user\", index: true }, username: { type: String, required: true }, name: { first: { type: String, required: true }, last: { type: String, required: true }, }, }, comments: [CommentSchema], }, { timestamps: true });// 2. index 메서드로 인덱스 생성 // unique: true 속성을 줄 수도 있다. BlogSchema.index({ updateAt: 1 });BlogSchema.index({ updateAt: 1 }, { unique: true });const Blog = model(\"blog\", BlogSchema);export default Blog;2. CompoundKey CompoundKey(복합키)란 다수의 필드를 포함하는 고유한 키로 한 개의 도큐먼트에서 각 필드 값의 조합이 고유하게 식별되어야 하는 경우 사용된다.1) 정의MongoDB에서는 도큐먼트의 각 필드 값을 결합하여 고유한 식별자를 생성할 수 있다.예를 들어, 고객 정보를 저장할 때 고객의 이름과 주소를 결합한 값을 고유 식별자로 사용할 수있고 이를 CompoundKey라고 한다.해당 키를 사용하여 고객의 이름과 주소를 기준으로 검색, 정렬한 데이터를 더 빠르게 얻을 수 있다. CompundKey의 원리는 각 필드 값을 결합하여 고유한 키를 생성한다. MongoDB는 BSON(Binary JSON) 형식으로 저장되는 도큐먼트를 사용하기 때문에 각 필드 값을 결합하여 고유한 식별자를 생성할 수 있다. BSON은 MongoDB에서 사용하는 데이터 형식으로 JSON 형식의 데이터를 이진 형식으로 저장한다. BSON은 더 빠르고 효율적으로 데이터를 저장, 전송할 수 있다. CompoundKey를 다음과 같이 활용할 수 있다. 중복 데이터 방지: CompoundKey를 사용하면, 각 도큐먼트가 고유하게 식별되어 중복 데이터를 방지할 수 있다. 검색 성능 향상: CompoundKey 기반으로 검색할 수 있어 빠른 속도로 데이터를 조회할 수 있다. 데이터 구조 정의: CompoundKey를 통해 필드 값을 결합하여 원하는 키 구조를 생성할 수 있어 데이터 구조를 정의할 수 있다.CompoundKey는 고유성, 성능, 유연성을 향상시킬 수 있는 기능으로 적절히 활용하면 더 효율적인 데이터 관리와 분석이 가능하다.2) 구현import { Schema, model, Types } from \"mongoose\";import { CommentSchema } from \"./Comment.js\";const BlogSchema = new Schema( { title: { type: String, required: true }, content: { type: String, required: true }, isLive: { type: Boolean, required: true, default: true }, user: { _id: { type: Types.ObjectId, required: true, ref: \"user\" }, username: { type: String, required: true }, name: { first: { type: String, required: true }, last: { type: String, required: true }, }, }, comments: [CommentSchema], }, { timestamps: true });// CompoundKey index 생성 BlogSchema.index({ \"user._id\": 1, updateAt: 1 });const Blog = model(\"blog\", BlogSchema);export default Blog;3. textIndex MongoDB에서 텍스트 검색을 위한 인덱스이다.1) 정의일반적인 B-Tree 인덱스는 숫자나 날짜와 같은 정수, 부동소수점 타입의 값을 인덱스하지만 textIndex는 텍스트 필드의 값을 인덱스하여 텍스트 검색 쿼리를 할 수 있다. 검색할 텍스트 필드의 모든 단어를 색인하고 단어의 빈도수와 위치 등의 정보를 포함하여 검색 결과의 정확도를 향상시킨다.예를 들어, title에 특정 단어가 들어간 블로그 게시글을 찾으려고 한다면 textIndex를 title필드에 생성하여 아래의 이미지와 같이 데이터를 탐색할 수 있다.2) 구현import { Schema, model, Types } from \"mongoose\";import { CommentSchema } from \"./Comment.js\";const BlogSchema = new Schema( { title: { type: String, required: true }, isLive: { type: Boolean, required: true, default: true }, _id: { type: Types.ObjectId, required: true, ref: \"user\" }, username: { type: String, required: true }, name: { first: { type: String, required: true }, last: { type: String, required: true }, }, }, comments: [CommentSchema], }, { timestamps: true });BlogSchema.index({ \"user._id\": 1, updateAt: 1 });// text Index는 콜렉션에서 한개만 만들 수 있다.BlogSchema.index({ title: \"text\" });const Blog = model(\"blog\", BlogSchema);export default Blog; textIndex는 콜렉션에서 한 개만 만들 수 있기 때문에, 만약 content에 대한 textIndex도 추가하고 싶으면 복합 키를 만들면 된다. BlogSchema.index({title: \"text\", content: \"text\"}) " }, { "title": "MongoDB-Read-성능-향상시키기", "url": "/posts/mogodb03/", "categories": "WEB, MongoDB", "tags": "MongoDB", "date": "2023-02-06 00:00:00 +0900", "snippet": "강의 링크Read는 퍼포먼스에 많은 영향을 미친다. 서로 연결되어 있는 데이터를 가공, 조합해야 하기 때문에 DB 설계를 어떻게 하느냐 따라 성능이 달라진다.만약 다음과 같은 콜렉션을 가진 데이터베이스가 있다고 가정해보자. 콜렉션 관계 User 1 Blog N 콜렉션 관계 User N Blog N Comment 1 { id: \"Blogid\", title: \"BlogTitle\", content: \"BlogContent\", user: { id: \"userId\", username: \"username\" }, comments: [ { content: \"content\", user: { id: \"userId\", username: \"username\" } } ]}일반적으로 프론트는 위와 같은 데이터를 원한다. 게시글에 대한 정보를 보낼 때, 해당 게시글과 관련된 댓글과 유저에 대한 정보도 전달해야 하는 것이다.그렇다면, 이러한 데이터 구조를 만드는 방법에 대해서 알아보자.1. 데이터를 직접 요청 매번 필요한 정보를 요청하여 데이터를 client에서 가공한다. 이는, 클라이언트가 백엔드에 요청하는 호출은 최소화 해야 하기 때문에 비효율적인 방법이다.// client.jsimport axios from \"axios\";const URI = \"http://localhost:3000\";const BLOG_URI = `${URI}/blog`;const USER_URI = `${URI}/user`;const test = async () =&gt; {console.time(\"loading time: \");let { data: { blogs },} = await axios.get(`${BLOG_URI}`);blogs = await Promise.all( blogs.map(async (blog) =&gt; { const [res1, res2] = await Promise.all([ // 게시글 작성 유저 정보 요청 axios.get(`${USER_URI}/${blog.user}`), // 게시글 정보 요청 axios.get(`${BLOG_URI}/${blog._id}/comment`), ]); blog.user = res1.data.user; // 게시글 댓글, 댓글 작성 유저 정보 요청 blog.comments = await Promise.all( res2.data.comments.map(async (comment) =&gt; { const { data: { user }, } = await axios.get(`${USER_URI}/${comment.user}`); comment.user = user; return comment; }) ); return blog; }));console.dir(blogs[0], { depth: 10 });console.timeEnd(\"loading time: \"); }; 데이터가 많아지면 많아 질 수록 호출 수가 증가하기 때문에 데이터를 가공하고 합치는데 시간이 너무 걸린다. 클라이언트가 백엔드에서 게시글 목록을 요청할 때 각 게시글에 대한 작성자 정보, 댓글, 댓글의 작성자 정보를 따로 요청하게 되는데 게시글의 개수가 N개일 경우, N+3 번의 요청이 발생하는 것이다.이러한 현상을 N+1 Problem라고 한다. 클라이언트가 하나의 리소스에 대한 정보를 요청할 때, 관련된 다른 리소스를 하나씩 요청하는 경우에 발생한다.이를 방지하기 위해서는 백엔드에서 한 번에 필요한 모든 데이터를 포함하여 클라이언트에 응답하는 것이 좋다. 또한, 클라이언트에서 한 번에 필요한 모든 데이터를 요청하는 것도 좋은 방법이다.2. Populate() populate() 메서드는 한 문서에서 다른 문서로의 참조 관계를 처리할 때 사용하며 참조 관계를 가지는 두 문서의 _id값을 기준으로 연결한다.populage()메서드를 사용하면 참조 관계를 가진 데이터들을 한 번에 클라이언트에게 보내는 데 용이하다.1) Schema 수정먼저 BlogSchema를 통해 comments에 접근하기 위해 가상 keys를 BlogSchema에 추가해야 한다.// src/models/Blog.jsimport { Schema, model, Types } from \"mongoose\";import { CommentSchema } from \"./Comment.js\";const BlogSchema = new Schema( { title: { type: String, required: true }, content: { type: String, required: true }, isLive: { type: Boolean, required: true, default: true }, user: { type: Types.ObjectId, required: true, ref: \"user\" }, }, { timestamps: true });// 가상의 key를 만들어 comments에 접근한다. // commentSchema의 blog 필드를 통해 연결되어 있어 가능하다. (역참조를 위한 설정)BlogSchema.virtual(\"comments\", { ref: \"comment\", // 어떤 모델인가 localField: \"_id\", // 참고해야 하는 필드는 무엇인가 foreignField: \"blog\", // 어떻게 연결되어있는가});BlogSchema.set(\"toObject\", { virtuals: true });BlogSchema.set(\"toJSON\", { virtuals: true });const Blog = model(\"blog\", BlogSchema);export default Blog; vitrual()은 데이터베이스에 저장되지 않은, 스키마에 정의된 프로퍼티의 가상 필드를 생성하는 메서드이다. 예를 들어, 사용자 도큐먼트에서 이름과 패스워드 필드를 갖는데, 사용자의 전체 이름을 구성하는 가상 필드를 생성할 수 있다. 가상 필드는 데이터베이스에 저장되지 않지만, 사용자 문서에서 사용 가능한 프로퍼티이다. virtual()메서드를 사용하면 역참조 관계를 모델에서 정의할 수 있다. 가상 속성을 추가하고 이 가상 속성에서 지정된 경로의 문서를 참조 할 수 있다. 2) API 수정// src/routes/Blogroute.jsblogRouter.get(\"/\", async (req, res) =&gt; { try { // 연결시킬 데이터를 populate를 사용하여 참조해준다. // {path: \"user}: 게시글 작성 유저 // {path: \"comments\", populate: {path: \"user\"}}: 댓글, 댓글 작성 유저 const blogs = await Blog.find({}) .populate([{ path: \"user\" }, { path: \"comments\", populate: { path: \"user\" } }]); return res.send({ blogs }); } catch (error) { console.log(error); res.status(500).send({ error: error.message }); }});이렇게 populate()를 활용해 참조한 데이터를 탐색하여 한번에 클라이언트에게 전달할 수 있다.확실히, 클라이언트와 백엔드간의 통신의 횟수는 1번으로 줄였지만 참조한 데이터를 탐색하는 데 시간이 걸리기 때문에 다른 방법이 좀 더 효율이 좋을 수 있다.3. Nesting (문서 내장) Nesting은 하나의 문서 안에 다른 문서를 포함하는 과정을 말한다. 포함된 문서는 부모 문서의 필드로 저장된다.Nesting을 통해 관련 데이터를 함께 저장하여, 관련 데이터가 별도의 컬렉션에 저장되어 있는 경우에 비해 검색하고 조작하는 것이 더 효율적인 방법이다.특히 몽고 DB는 수평적인 확장이 굉장히 용이 하기 때문에 데이터 용량 자체가 크더라도 괜찮다. (그래도 16mb 이상이 되어서는 안된다.) 관련 데이터가 하나의 문서에 함께 저장되어 데이터의 일관성이 향상된다. 별도의 컬렉션에 대한 여러 읽기와 쓰기 작업이 줄어들어 성능이 향상도니다. 관련 데이터가 하나의 문서에 저장되어 하나의 단위로 조작하기 쉽다.1) Schema 수정// src/models/commentRoute.jsimport { Schema, model, Types } from \"mongoose\";import { CommentSchema } from \"./Comment.js\";// 관계형 DB 만들기const BlogSchema = new Schema( { title: { type: String, required: true }, content: { type: String, required: true }, isLive: { type: Boolean, required: true, default: true }, // 1 필요한 model을 내장시킨다. user: { _id: { type: Types.ObjectId, required: true, ref: \"user\" }, // 여기에는 unique: true 속성을 주면 안된다. (여러 유저가 작성할 수 있음) username: { type: String, required: true }, name: { first: { type: String, required: true }, last: { type: String, required: true }, }, }, // 2. Schema 자체를 내장시킬 수도 있다. comments: [CommentSchema], }, { timestamps: true });const Blog = model(\"blog\", BlogSchema);export default Blog;이렇게 Schema를 수정하면 다음과 같은 도큐먼트를 확인할 수 있다.(Nesting은 이렇게 관련된 데이터를 한번에 저장하는 것이다. 자식 문서를 부모 문서에 아예 저장시킴으로 Read작업이 정말 간소해진다. )2) API 수정유저나 댓글이 수정, 삭제되면 게시글에 저장된 정보도 같이 수정, 삭제를 해야 한다.// src/routes/commentRoute.jscommentRouter.patch(\"/:commentId\", async (req, res) =&gt; { const { commentId } = req.params; const { content } = req.body; if (typeof content !== \"string\") { return res.status(400).send({ error: \"content is required\" }); } // comments 배열안에 _id의 값이 comment._id와 동일한 것을 찾아서 수정한다. const [comment] = await Promise.all([ Comment.findOneAndUpdate({ _id: commentId }, { content }, { new: true }), // $를 사용하면 filter를 통해 선택된 도큐먼트를 가리킨다. // 원래는 comments[index].content = value로 저장해야 하지만 index를 모르기 때문에 $를 사용하는 것이다. // 즉, comments.$는 comments._id가 comment_id인 comment를 의미한다. await Blog.updateOne({ \"comments._id\": commentId }, { \"comments.$.content\": content }), ]); return res.send({ comment });});commentRouter.delete(\"/:commentId\", async (req, res) =&gt; { const { commentId } = req.params; const comment = await Comment.findOneAndDelete({ _id: commentId }); // $pull 연산자는 일치하는 모든 값을 모두 제거한다. 만약 일치하는 값이 없다면 도큐먼트는 변경되지 않는다. await Blog.updateOne({ \"comments._id\": commentId }, { $pull: { comments: { _id: commentId } } }); return res.send({ comment });});// src/routes/userRoutes.jsuserRouter.put(\"/:userId\", async (req, res) =&gt; { try { const { userId } = req.params; if (!mongoose.isValidObjectId(userId)) { return res.status(400).send({ error: \"Invalid userId\" }); } const { age, name } = req.body; if (!age &amp;&amp; !name) return res.status(400).send({ error: \"age or name is required\" }); if (age &amp;&amp; typeof age !== \"number\") return res.status(400).send({ error: \"age must be a number\" }); if (name &amp;&amp; typeof name.first !== \"string\" &amp;&amp; typeof name.last != \"string\") return res.status(400).send({ error: \"must be string\" }); let user = await User.findById(userId); if (age) user.ane = age; // user의 이름이 변경되면 블로그, 댓글에 대한 데이터도 변경해야 한다. if (name) { user.name = name; await Promise.all([ // updateMany: 다수의 도큐먼트를 수정한다. Blog.updateMany({ \"user._id\": userId }, { \"user.name\": name }), // array filter를 사용하여 해당 유저가 작성한 모든 코멘트를 수정한다. // update 연산자에서 배열의 엘리먼트에 대한 조건적 업데이트를 지원하는 옵션이다. await Blog.updateMany( {}, { \"comments.$[elem].user.name\": name }, { arrayFilters: [{ \"elem.user._id\": userId }] } ), ]); } await user.save(); return res.send({ user }); } catch (error) { console.log(error); return res.status(500).send({ error: error.message }); }});userRouter.delete(\"/:userId\", async (req, res) =&gt; { try { const { userId } = req.params; if (!mongoose.isValidObjectId(userId)) { return res.status(400).send({ error: \"Invalid userId\" }); } // 삭제 const [user] = await Promise.all([ User.findOneAndDelete({ _id: userId }), Blog.deleteMany({ \"user._id\": userId }), // $pull: {제거할 데이터: {조건}} Blog.updateMany({ \"comments.user._id\": userId }, { $pull: { comments: { \"user._id\": userId } } }), Comment.deleteMany({ user: userId }), ]); return res.send({ user }); } catch (error) { console.log(error); return res.status(500).send({ error: error.message }); }});하지만, Nesting에도 제한이 있기 때문에 데이터 구조와 데이터 관계의 성격을 잘 파악하여 다음 중 하나를 선택하여 DB를 구축하면 된다. 참조 관계 활용 개별적으로 읽을 때도 있거나 내장하려는 문서가 자주 바뀔 경우 1:N 관계의 경우 N의 크기가 클 수록 Nesting 같이 불러올 때가 많고 읽기 비중이 높을 경우 1:N 관계의 경우 N의 크기가 작을 수록 " }, { "title": "MongoDB-관계된-데이터-관리", "url": "/posts/mogodb02/", "categories": "WEB, MongoDB", "tags": "MongoDB", "date": "2023-02-03 00:00:00 +0900", "snippet": "강의 링크1. 1:N 관계 1:N 관계는 한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미한다. 실제 DB를 설계할 때 자주 쓰이는 방식이다.1) Schema 작성일반적인 게시판을 생각하면, 하나의 유저가 여러 개의 게시글을 작성한다. 콜렉션 관계 유저 1 게시글 N 이러한 유저와 게시글의 관계를 1:N 관계라고 하는데, RDBMS의 경우에는 FK (Foregin Key)를 통해 한 테이블의 필드 중 다른 테이블을 연결하는 방식으로 표현한다. MongoDB에서도 마찬가지로 ID로 관계를 표현한다. 위의 도큐먼트는 유저가 작성한 게시글 데이터이다. 이렇게 user의 id를 user에 저장함으로 둘이 연결되어 있는 데이터임을 보여주는 것이다.// src/models/Blog.jsimport { Schema, model, Types } from \"mongoose\";const BlogSchema = new Schema( { title: { type: String, required: true }, content: { type: String, required: true }, // 기본값 설정 isLive: { type: Boolean, required: true, default: false }, // 블로그는 유저 모델과 1:N 관계이다. // 그래서 어떤 model과 관계가 있는지 ref를 통해 몽구스에게 알려준다. user: { type: Types.ObjectId, required: true, ref: \"user\" }, }, { timestamps: true });const Blog = model(\"blog\", BlogSchema);export default Blog; Blog를 작성한 user를 표현하기 위해 user의 id를 도큐먼트에 기록해야한다. ref 속성을 사용하여 어떤 콜렉션과 연결되어있는지를 몽구스에게 알려주어야한다. ref속성에 model의 이름을 기입해야 한다. 2) post 요청 구현// src/routes/blogRoute.jsimport { Router } from \"express\";import { Blog, User } from \"../models/index.js\";import { isValidObjectId } from \"mongoose\";const blogRouter = Router();blogRouter.post(\"/\", async (req, res) =&gt; { try { const { title, content, isLive, userId } = req.body; // 유효성 검사 if (typeof title !== \"string\") res.status(400).send({ error: \"title is required\" }); if (typeof content !== \"string\") res.status(400).send({ error: \"content is required\" }); if (isLive &amp;&amp; typeof isLive !== \"boolean\") res.status(400).send({ error: \"isLive must be a boolean\" }); if (!isValidObjectId(userId)) res.status(400).send({ error: \"userId is invalid\" }); // 유저가 존재하는지 검사 let user = await User.findById(userId); if (!user) res.status(400).send({ error: \"user does not exist\" }); // blog 인스턴스에는 user 객체가 담겨져 있지만, db에 저장될 때는 알아서 id만 저장한다. let blog = new Blog({ ...req.body, user }); await blog.save(); return res.send({ blog }); } catch (error) { console.log(error); res.status(500).send({ error: error.message }); }}); 1:N 관계에서 데이터를 저장할 때 유의해야 하는 것은 관계가 연결된 도큐먼트가 실제로 존재하는지 확인하는 과정을 거쳐야 한다. fingById를 통해 해당 user가 존재하는 지 확인할 수 있다. 앞서 말했 듯, user의 id를 Blog 도큐먼트에 저장을 해야 하는데 이때 그냥 user 객체 자체를 넣어서 저장해도 db에서는 알아서 user의 id만 저장한다.2. 예시1) SchemaComment 콜렉션은 Blog와 1:N, 유저와 1:N 관계를 가진 콜렉션이다.블로그 게시 글에도 여러 개의 댓글이 달릴 수도 있고, 유저도 여러 개의 댓글을 작성할 수 있기 때문이다. 위의 도큐먼트는 특정 유저가 특정 게시글에 작성한 댓글 데이터이다. user의 id와 블로그의 id가 comment 도큐먼트에 저장되어 있음을 알 수 있다.// src/models/Comment.jsimport { Schema, model, Types } from \"mongoose\";const CommentSchema = new Schema( { content: { type: String, required: true }, user: { type: Types.ObjectId, required: true, ref: \"user\" }, blog: { type: Types.ObjectId, required: true, ref: \"blog\" }, }, { timestamps: true });const Comment = model(\"comment\", CommentSchema);export default Comment;2) API일반적으로 댓글은 특정 블로그의 댓글을 불러오기 때문에 블로그의 자식 개념이다. 그래서 계층 구조를 uri에 명확히 기입해야 한다./blog/:blogId/comment/:commentId로 표현을 해야 한다. 그래서 router를 만들 때 다음과 같이 만들어야 한다.// server.jsapp.use(\"/user\", userRouter);app.use(\"/blog\", blogRouter);// comment는 특정 블로그의 후기를 불러오는 개념이기 때문에 자식 개념이기 떄문에 uri를 다음과 같이 한다.app.use(\"/blog/:blogId/comment\", commentRouter);// src/routes/commentRoute.jsimport { Router } from \"express\";import { User, Blog, Comment } from \"../models/index.js\";import { isValidObjectId } from \"mongoose\";// blogId를 params에서 불러오기 위해 mergeParams를 true로 설정해야 한다.const commentRouter = Router({ mergeParams: true });commentRouter.post(\"/\", async (req, res) =&gt; { try { const { blogId } = req.params; const { content, userId } = req.body; // 유효성 검사 if (!isValidObjectId(blogId)) return res.status(400).send({ error: \"blogId is invalid\" }); if (!isValidObjectId(userId)) return res.status(400).send({ error: \"userId is invalid\" }); if (typeof content !== \"string\") return res.status(400).send({ error: \"content is required\" }); // 순차적으로 데이터를 불러올 필요는 없다. // 동시에 데이터를 불러오는 것이 더 빠르다. const [blog, user] = await Promise.all([Blog.findById(blogId), User.findById(userId)]); // 유효성 검사 if (!blog || !user) return res.status(400).send({ error: \"blog or user does not exist\" }); if (!blog.isLive) return res.status(400).send({ error: \"blog is not available\" }); // 저장 const comment = new Comment({ content, user, blog }); await comment.save(); return res.send({ comment }); } catch (error) { console.log(error); res.status(500).send({ error: error.message }); }});commentRouter.get(\"/\", async (req, res) =&gt; { const { blogId } = req.params; if (!isValidObjectId(blogId)) return res.status(400).send({ error: \"blogId is invalid\" }); const comments = await Comment.find({ blog: blogId }); return res.send({ comments });});export default commentRouter;" }, { "title": "MongoDB-환경설정과-간단한-CRUD구현하기", "url": "/posts/mogodb01/", "categories": "WEB, MongoDB", "tags": "MongoDB", "date": "2023-02-03 00:00:00 +0900", "snippet": "강의 링크 MongoDB는 NoSQL 데이터 베이스 중 하나이다. NoSQL은 Not Only SQL의 줄임말로 기존의 RDBMS의 한계를 극복하기 위해 만들어진 새로운 형태의 데이터 저장소이다.관계형 DB는 표를 저장한다면 MongoDB는 객체를 저장한다고 생각하면 된다.즉, 관계형 DB가 아니므로, RDMS처럼 고정된 스키마 및 JOIN이 존재하지 않는다. 데이터의 구조가 달라도 같은 테이블에 저장할 수 있다. (Schemaless) 관계형 베이스: database &gt; table &gt; row MogoDB: database &gt; collection &gt; document1. Node.js와 MongoDBnode.js는 비동기 프로그래밍이기 때문에 Node.js로 MangoDB를 다룰 때 이를 유의해야한다.특히, 동기적으로 처리해야 하는 경우와 비동기적으로 처리해도 괜찮은 경우를 알고 코딩을 해야 한다.또한, Blocking이 많은 CPU Intensive한 작업들은 node.js에 맞지 않는다.async function createBlog(){ await User.findOne({...}) // 비동기적으로 처리해도 될 때는 Promise.all로 묶으면 된다. // 효율적으로 cpu를 사용하기 위해.. await Promise.all([{ Blog.insertOne({...}), User.updateOne({...}) }]) await LogApi({...}) return \"success\"}1) 환경 설정공식 문서mongoose는 Node.js와 MongoDB를 연결해주는 ODM으로 mongoose를 사용하면 좀 더 편리하게 MongoDB를 사용할 수 있다.npm install mongoose다음과 같이 DB를 연결해주면 된다.// src/server.jsimport dotenv from \"dotenv\";import express from \"express\";import mongoose from \"mongoose\";import userRouter from \"./routes/userRoute.js\";dotenv.config();const PASSWORD = process.env.PASSWORD;const app = express();// mongodb compass connect uriconst MONGO_URI = `mongodb+srv://admin:${PASSWORD}@mongodbtutorial.5pazsio.mongodb.net/?retryWrites=true&amp;w=majority`;const server = async () =&gt; { try { mongoose.set(\"strictQuery\", false); // DB 연결 let mongodbConnection = await mongoose.connect(MONGO_URI); mongoose.set(\"debug\", true); console.log(\"MongoDB connected\"); // json을 객체로 파싱하는 미들웨어 app.use(express.json()); // Router (userAPI와 연결) app.use(\"/user\", userRouter); // 클라이언트가 3000포트로 접속할 수 있다. (node Server) app.listen(3000, function () { console.log(\"server start: http://localhost:3000/\"); }); } catch (error) { console.log(error); }};server();2) Schema, Model 생성앞서 말했듯이, Mongoose는 Table이 없기 때문에, 오타로 인한 다른 데이터나 타입이 데이터베이스에 저장되는 경우가 발생할 수 있다.이러한 문제를 막기 위해 몽구스는 Schema를 도입했다. Mongoose는 사용자가 작성한 스키마를 기준으로 데이터에 DB를 넣기 전에 먼저 검사를 한다. Schema는 어느정도 테이블의 역할을 한다고 보면 된다.// src/models/User.jsimport { Schema, model } from \"mongoose\";// new mongoose.Schema(스케마 정의, 추가 옵션)const UserSchema = new Schema( { username: { type: String, required: true, unique: true }, name: { first: { type: String, required: true }, last: { type: String, required: true }, }, age: Number, emain: String, }, { timestamps: true });// 만든 스케마를 몽구스에게 알려주어 모델을 생성한다.// model(콜렉션이름, 스키마)const User = model(\"user\", UserSchema);export default User;이렇게 만든 콜렉션에 도큐먼트를 추가하는 API를 만드려면 다음과 같이 코드를 작성하면 된다.앞서 말했듯이, Node.js는 비동기 프로그래밍이기 때문에 데이터관련 작업 결과가 끝날 때까지 기다려야함을 유의해야 한다.// src/routes/userRoute.jsapp.post(\"/user\", async (req, res) =&gt; { try { // 유효성 검사 let { username, name } = req.body; if (!username) return res.status(400).send({ error: \"username is required\" }); if (!name || !name.first || !name.last) return res.status(400).send({ error: \"Both first and last names are required\" }); const user = new User(req.body); // 데이터 저장 await user.save(); return res.send({ user }); // 에러 처리 } catch (error) { console.log(error); return res.status(500).send({ error: error.message }); }}; 먼저, post 요청을 받으면 요청에 대한 유효성 검사를 실행한다. 예시의 경우에는 필수 값인 username과 name 필드 값이 있는지 확인한다. 에러가 없고 요청에 제대로 왔으면, 데이터를 db에 저장한다. 저장이 완료된 후 응답을 보낸다.3) 간단한 CRUD 작업하기공식 문서mongoose의 메서드를 사용하면, SQL 문법을 잘 몰라도 쉽게 DB에 접근하고 데이터를 CRUD할 수 있다.mongoose에서 제공하는 메서드는 위의 공식 문서에 잘 정리되어있다.:white_check_mark: find, findOne, findById// src/routes/userRoute.js// user 데이터를 전부 반환하는 get 요청app.get(\"/user\", async (req, res) =&gt; { try { // find({필터 조건}): 탐색한 결과의 배열을 리턴한다. // findOne({필터 조건}): 탐색한 결과 하나를 리턴한다. const users = await User.find({}); return res.send({ users }); } catch (error) { console.log(error); return res.status(500).send({ error: error.message }); }});// 특정 id의 user 데이터를 반환하는 get 요청app.get(\"/user/:userId\", async (req, res) =&gt; { try { const { userId } = req.params; // userId가 ObjectId에 맞는 형식인지 유효성 검사 if (!mongoose.isValidObjectId(userId)) { return res.status(400).send({ error: \"Invalid userId\" }) } const user = await User.findOne({ _id: userId }); return res.send({ user }); } catch (error) { console.log(error) return res.status(500).send({ error: error.message }); }}); Model.find({필터 조건}): 탐색한 결과의 배열을 반환한다. Model.findOne({필터 조건}): 탐색한 결과 처음 찾은 도큐먼트를 반환한다. Model.findById(id): 해당 ID를 가진 도큐먼트를 반환한다. moongoose.isValidObjectId(데이터): 해당 데이터가 objectId에 맞는 형식인지 검사 후 boolean값을 반환한다.:white_check_mark: delete, findOneAndDelete, findByIdAndDelete// src/routes/userRoute.jsapp.delete(\"/user/:userId\", async (req, res) =&gt; { try { const { userId } = req.params; // userId가 ObjectId에 맞는 형식인지 유효성 검사 if (!mongoose.isValidObjectId(userId)) { return res.status(400).send({ error: \"Invalid userId\" }); } // 삭제 const user = await User.findOneAndDelete({ _id: userId }); return res.send({ user }); } catch (error) { console.log(error); return res.status(500).send({ error: error.message }); }}); Model.delete({필터 조건}): 해당 조건에 맞는 도큐먼트 삭제 Model.findOneAndDelete({필터 조건}): 해당 조건에 맞는 도큐먼트가 있는지 확인 후 삭제 Model.findByIdAndDelete(id): 해당 id를 가진 도큐먼트를 삭제:white_check_mark: update, findOneAndUpdate, findByIdAndUpdate// src/routes/userRoute.jsapp.put(\"/user/:userId\", async (req, res) =&gt; { try { const { userId } = req.params; // userId가 ObjectId에 맞는 형식인지 유효성 검사 if (!mongoose.isValidObjectId(userId)) return res.status(400).send({ error: \"Invalid userId\" }); } // 입력한 데이터 유효성 검사 const { age } = req.body; if (!age) return res.status(400).send({ error: \"age is required\" }); if (typeof age !== \"number\") return res.status(400).send({ error: \"age must be a number\" }); // 해당 id를 가진 데이터의 age를 수정한다. // new: true 옵션을 사용하여 업데이트 된 데이터를 반환한다. const user = await User.findByIdAndUpdate(userId, { age }, {new: true}); return res.send({ user }); } catch (error) { console.log(error); return res.status(500).send({ error: error.message }); }}); Model.update({필터 조건}, {수정하는 값}): 해당 조건에 맞는 도큐먼트 수정 Model.findOneAndUpdate({필터 조건}, {수정하는 값}): 해당 조건에 맞는 도큐먼트가 있는지 확인 후 수정 Model.findByIdAndUpdate(id, {수정하는 값}): 해당 id를 가진 도큐먼트 수정그러나 위와 같이 DB를 직접 update하는 것은 schema를 체크하지 않기 때문에 위험할 수 있다.대신 유저 객체를 찾고 수정한 뒤 저장하면, 데이터 베이스를 두 번 거쳐야 하지만 안정적이게 데이터를 수정할 수 있다.// 해당 id를 가진 데이터의 age, name을 수정한다.// 1. 업데이트 방식let updateBody = {};if (age) updateBody.age = ageif (name) updateBody.name = name const user = await User.findByIdAndUpdate(userId, updateBody, { new: true });// 2. save 방식 =&gt; user.save할 때 스케마를 체크하기 때문에 좀 더 안정적이다. // 수정해야 하는 데이터의 형태가 복잡할 때 추천하는 방식이다. let user = await User.findById(userId);if (age) user.ane = age;if (name) user.name = name;await user.save();" }, { "title": "GraphQL-Apollo-Client", "url": "/posts/graphql02/", "categories": "WEB, GraphQL", "tags": "GraphQL", "date": "2023-02-02 00:00:00 +0900", "snippet": "공식 문서Apollo Client는 GraphQL API를 클라이언트 단에서 호출하기 위해서 사용한다.( ReduxRTKQuery와 사용법이 유사하다!)1. 환경 설정# 패키지 설치npm install @apollo/client graphql// App.js// apolloClient 모듈을 import한다. import { ApolloProvider } from '@apollo/client';import { ApolloClient, InMemoryCache } from '@apollo/client'// GraphQL 서버로와 정보를 주고 받을 ApolloClient 객체를 만든다. const client = new ApolloClient({ uri: 'http://localhost:4000', // 서버 주소 cache: new InMemoryCache() // InMemoryCache를 통한 캐시 관리});// ...// 내부 요소들을 ApolloProvider로 감싸준다. return ( &lt;div className=\"App\"&gt; &lt;ApolloProvider client={client}&gt; &lt;header className=\"App-header\"&gt; &lt;h1&gt;Company Management&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; {NavMenus()} &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main&gt; {mainComp[menu]} &lt;/main&gt; &lt;/ApolloProvider&gt; &lt;/div&gt; );2. GraphQL API 호출1) useQuery (Read)공식 문서useQuery는 기본적으로 loading, error, data를 반환한다. loading: 로딩 중이면 true, 아니면 false를 반환한다. data: 요청에 의해 반환되는 데이터 error: error 여부import { gql, useQuery } from '@apollo/client';// 선언 const GET_DOGS = gql` query GetDogs($id :Int) { dogs { id breed } }`// 호출function GetDog() { const { loading, error, data } = useQuery(GET_DOGS, { variables: { breed }, }); // ... }아폴로 클라이언트는 쿼리의 결과를 자동으로 캐싱한다. 그래서 똑같은 쿼리를 보낸 경우 빠르게 반응할 수 있다.polling 과 refetch를 통해 캐시된 데이터를 최신 상태로 유지할 수 있다.// 1. polling: 정한 시간마다 자동으로 데이터를 갱신const { loading, error, data } = useQuery(GET_DOGS, { variables: { breed }, pollInterval: 500, });// 2. refetch: 유저의 특정 행동 후에 다시 query를 요청하는 함수를 실행 (데이터 갱신)const { loading, error, data, refetch } = useQuery(GET_DOGS, { variables: { breed }, }); // ... return (\t&lt;button onClick={() =&gt; refetch({breed: \"new_dog_breed\"})}&gt; click &lt;/button&gt; );};2) useLazyQueryuseLazyQuery는 사용자의 이벤트에 대한 응답으로 쿼리를 요청하는데 적합하다.useQuery의 경우 호출하면 연결된 쿼리를 즉시 실행하지만,useLazyQuery는 즉시 실행하지 않고 쿼리 함수를 반환하여 특정 이벤트 후에 쿼리를 요청하도록 할 수 있다.import { useLazyQuery } from '@apollo/client';function GetDog() { // 호출했지만, GET_DOGS가 바로 실행되지 않는다. // 쿼리는 getDog()통해 실행된다. const [getDog, { loading, error, data }] = useLazyQuery(GET_DOGS); // ... return (\t&lt;button onClick={() =&gt; getDog({variables: { breed: \"new_dog_breed\"}})}&gt; click &lt;/button&gt; );};3) useMutation (Create, Update, Delete)공식 문서useMutation은 useLazyQuery와 유사하게 쿼리 함수를 반환한다.일반적으로 추가, 수정, 삭제는 사용자의 이벤트에 대한 응답으로 실행되는 경우가 많기 때문에 useQuery와 같이 호출시 즉시 실행하지 않는다.import { gql, useMutation } from '@apollo/client';// 선언const ADD_TODO = gql` mutation AddTodo($type: String!) { addTodo(type: $type) { id type } }`;// 호출, 실행function AddTodo() { const [addTodo, { data, loading, error }] = useMutation(ADD_TODO); // form을 제출하면, mutate 함수가 실행된다. return ( \t&lt;form onSubmit={event =&gt; { event.prevendDefault(); addTodo({variables: {type: input.value}}); }}; &gt; //... &lt;/form&gt; )}만약, mutation 요청을 보낸 후에 데이터를 최신 상태로 유지하고 싶다면 refetchQueries옵션을 사용하면 된다.const [addTodo, { data, loading, error }] = useMutation(ADD_TODO, { refetchQueries: [ {query: GET_POST}, // DocumentNode object parsed with gql 'GetComments' // Query name ],});" }, { "title": "GraphQL-기초", "url": "/posts/graphql01/", "categories": "WEB, GraphQL", "tags": "GraphQL", "date": "2023-02-02 00:00:00 +0900", "snippet": "공식 문서1. GraphQL이란GraphQL은 SQL과 마찬가지로 쿼리 언어 중 하나이다. SQL: 데이터 베이스 시스템에 저장된 데이터를 효율적으로 가져오는 것이 목적 GraphQL:웹 클라이언트가 데이터를 서버로부터 효율적으로 가져오는 것이 목적즉, 클라이언트와 서버간 통신을 위해 주로 사용된다.1) 장점 필요한 정보만 선택하여 받아올 수 있다. RESTAPI의 Overfetching 문제 해결 데이터 전송량 감소 여러 계층의 정보들을 한 번에 받아올 수 있다. RESTAPI의 Underfetching 문제 해결 요청 횟수 감소 하나의 Endpoint에서 모든 요청을 처리한다. 하나의 URI에서 POST로 모든 요청이 가능하다. 2) ApolloGraphQL은 RESPAPI와 마찬가지로 소프트웨어 통신을 원할 하게 위한 명세일 뿐이다.그래서 GraphQL을 구현할 솔루션이 필요하다. 그 중 하나의 솔루션이 Apollo이다. 백엔드에서 정보를 제공 및 처리 프론트엔드에서 요청을 전송 2. Apollo 서버 구축하기공식 문서const database = require('./database')const { ApolloServer, gql } = require('apollo-server')// typeDef: GraphQL 명세에서 사용될 데이터의 타입 (schema), 요청의 타입을 지정한다.// gql(template literal tag)로 생성된다. const typeDefs = gql` type Query { teams: [Team] } type Team { id: Int manager: String office: String extension_number: String mascot: String cleaning_duty: String project: String }`// resolver: 서비스의 액션들을 함수로 지정한다. // 요청에 따라 데이터를 반환, 입력, 수정, 삭제한다. const resolvers = { // teams를 요청하면, database의 team을 반환하는 함수를 실행한다. Query: { teams: () =&gt; database.teams }}// ApolloServer 클래스는 typeDefs와 resiolvers를 인자로 받아서 서버를 생성한다.const server = new ApolloServer({ typeDefs, resolvers })server.listen().then(({ url }) =&gt; { console.log(`🚀 Server ready at ${url}`)})typeDef에 대해 좀 더 자세히 살펴보면 Query의 루트 타입이 지정되어 있음을 확인할 수 있다.// Query로 teams을 요청하면 Team의 배열을 확인할 수 있다 (요청에 대한 타입)type Query { teams: [Team] }// Team의 타입은 다음과 같다. (데이터에 대한 타입)type Team { id: Int manager: String office: String extension_number: String mascot: String cleaning_duty: String project: String}1) Schemas and Types공식 문서GraphQL에서 데이터의 타입을 지정할 때, 사용되는 타입들은 정해져있다.우선, GraphQL 스키마의 가장 기본적인 구성 요소는 객체 유형이다. 그 외에도 기본적인 타입들이 다음과 같이 존재한다. 타입 설명 ID 기본적으로는 String이나, 고유 식별자 역할임을 나타냄 String UTF-8 문자열 Int 부호가 있는 32비트 정수 Float 부호가 있는 부동소수점 값 Boolean 참/거짓 ! null을 반환할 수 없다. [Type] 배열 이외에도 enum, union, interface, input 타입이 존재한다. (자세한 내용은 공식문서 참고)2) Query (Read)일반적으로 조건에 맞는 데이터를 찾으려는 경우가 많다.그런 경우 인자를 사용하여 조건을 제한할 수 있다.// typeDefs: id를 인자로 받아 해당 값을 가지고 있는 team을 반환한다. const typeDefs = gql` type Query { team(id: Int): Team }`// resolver const resolvers = { Query: { team: (parent, args, context, info) =&gt; database.teams .filter((team) =&gt; { return team.id === args.id })[0] }}여러 계층의 정보를 요청할 때는 아래와 같이 해결 할 수 있다. (UnderFetching 문제 해결 )예를 들면, Team과 Supply가 1:N 관계일 때 Team의 타입에 supplies라는 필드를 만들어 Supply의 배열 타입을 추가한다.그 후, Team의 데이터를 요청 할때 해당 Team에 맞는 Supply를 supplies 필드에 추가하는 로직을 넣어 Supply 데이터를 함께 반환한다.// 해당 team이 소유하고 있는 supplies를 같이 요청한다. const typeDefs = gql` type Query { teams: [Team] } type Team { id: Int manager: String office: String extension_number: String mascot: String cleaning_duty: String project: String supplies: [Supply] } type Supply { id: string team: Int }`const resolvers = { Query: { teams: () =&gt; database.teams .map((team)=&gt; { team.supplies = database.supplies .filter((supply) =&gt; { return supply.team === team.id }) return team }) }}3) Mutation (Create, Update, Delete)// 해당 팀을 삭제하고 삭제한 팀을 반환한다. const typeDefs = gql` type Mutation { deleteTeam(id:Int): Team }`const resolvers = { Mutatation: { deleteTeam: (parent, args, context, info) =&gt; { const deleted = database.teams .filter((team) =&gt; { return team.id === args.id })[0] database.team = database.teams .filter((team) =&gt; { return team.id !== args.id }) return deleted } }}5. Request공식 문서클라이언트에서는 데이터를 요청하는 방식을 알아보면, 이는 기본적으로 특정한 필드를 요청하는 방식으로 되어 있다.// teams라는 Action을 통해 Team 데이터를 요청한다. // Team 데이터의 id, manager, office 필드만 요청하고 있다. query requestTeam { teams { id manager office }}// 반환 되는 배열을 별칭 myTeam으로 지정할 수도 있다. query requestTeam { myTeam: team { id manager office }}// 조건을 지정할 때는 다음과 같이 소괄호를 이용하여 인자를 전달한다. query requestTeam { team(id:1) { id manager office }}// 변수를 사용하여 인자에 전달할 수도 있다. (동적 쿼리)// 선언된 변수는 scalars, enums, or input object 타입 중 하나여야 한다. query requestTeam($id: Id) { team(id: $id) { id manager office }}// 변수에 기본 값을 지정해 줄 수도 있다. // 변수를 사용하여 인자에 전달할 수도 있다. query requestTeam($id: Id = ABC) { team(id: $id) { id manager office }}// ...을 이용하여 타입에 제한을 줄 수도 있다. // 반환되는 데이터의 manager가 Developer 타입인지 Marketing 타입인지에 따라 반환되는 데이터가 다르다. query requestTeam { teams { manager\t\t... on Developer { office } ... on Marketing { id } }}타입이 복잡한 경우 Fragment를 사용하여 재사용 할 수 있다.const TeamInfo = gql` fragment teamInfo on Team { manager year }`const WorkInfo = gql` fragment workInfo on Team { office role }`const Get_TEAM = gql` query GetTeam { team { id ...workInfo ...teamInfo } ${WorkInfo} ${TeamInfo} }`또한, 지시어를 사용하여 좀 더 편리하게 데이터를 받을 수 있다.const Get_TEAM = gql` query GetTeam($id: Int!, $checkManager:Boolean = true) { team(id: $id) { id manager @include(if: $checkManager) office } }` @include(if: Boolean): 인자가 true 인 경우에만 이 필드를 결과에 포함한다. @skip(if: Boolean) 인자가 true 이면 이 필드를 건너뛴다." }, { "title": "실전-웹-성능-최적화-(feat. React)-Part2", "url": "/posts/performance03/", "categories": "WEB, Performance", "tags": "perfomance", "date": "2022-11-12 00:00:00 +0900", "snippet": "강의 링크웹 성능은 크게 두 가지로 분류할 수 있다.바로, 로딩 성능과 렌더링 성능이다. 로딩 성능: 각 리소스를 불러오는 성능을 의미한다. 렌더링 성능: 불러온 리소스를 화면에 보여주는 성능을 의미한다.1. 일반 홈페이지 최적화사용하는 툴 크롬 Network 탭 크롬 Performance 탭 크롬 Lighthouse 탭 Coverage 탭1) 이미지 레이지(lazy) 로딩로딩 성능 최적화가끔 히어로 컨텐츠보다 이미지가 먼저 로딩 되어 중요한 컨텐츠의 로딩이 늦어지는 경우가 있다. 히어로 컨텐츠보다 먼저 로딩되는 이미지들을 처리하는 방법은 두가지가 있다. 최대한 빠르게 이미지를 다운로드한다. (궁극적인 해결방법이 아니다. ) 이미지는 당장 눈에 보이는 요소가 아니기 때문에 나중에 로딩 시킨다.(1) 이미지 레이지 로딩 이미지를 나중에 필요할때 로딩하겠다라는 의미이다.그렇다면 해당 이미지들은 언제 불려야할까?바로 이미지가 보여지는 순간 혹은 직전에 이미지가 로드되면 좋을 것이다.이미지가 스크롤에 닿는 순간에 이미지를 로드한다.즉, 이미지가 보여지는 요소까지 스크롤이 된다면 이미지를 로딩하는 것이다.스크롤 이벤트를 통해, 스크롤이 이미지가 있는 곳까지 판단을 해서 이미지를 로드한다.(2) intersection observer 스크롤 이벤트마다 많은 함수가 실행된다는 단점이 있다. 이는 intersection observer를 통해 해결할 수 있다.intersection observer를 통해 특정 엘레멘트를 observer를 하면, 해당 요소가 화면에 보여지는 지를 확인할 수 있다.즉, 화면에 이미지가 보여지면 로딩을 하는 것이다.성능에 이득을 챙길 수 있다.function createObserver() { let observer; let options = { root: null, rootMargin: \"0px\", threshold: buildThresholdList() }; // args: 콜백 함수, options 객체 observer = new IntersectionObserver(handleIntersect, options); // observe라는 메서드를 통해 DOMElement를 이제 observe 상태가 된다. observer.observe(boxElement);} 콜백함수는 처음엔 oberve할 때, 페이지에서 보일 때, 페이지에서 안 보일때 호출한다.(3) 리액트에 적용하기function Card(props) { const imgRef = useRef(null); // 마운트할 때 한번만 하면 된다. useEffect(() =&gt; { const options = {}; const callback = (entries, observer) =&gt; { entries.forEach(entry =&gt; { // 2. 이미지가 보이는 순간에만 콜백함수가 실행하도록 한다. if(entry.isIntersecting) { // 3. data-src속성에 저장한 이미지 소스를 넣는다. entry.target.src = entry.target.dataset.src; // 4. 이미지를 넣었으면 이제 unobserve한다. observer.unobserve(entry.target); } }); }; const observer = new IntersectionObserver(callback, options); // 1. useRef를 통해 접근한다. observer.observe(imgRef.current); }, [])\treturn (\t\t&lt;div className=\"Card text-center\"&gt;\t\t\t&lt;img data-src={props.image} ref={imgRef}/&gt;\t\t\t&lt;div className=\"p-5 font-semibold text-gray-700 text-xl md:text-lg lg:text-xl keep-all\"&gt;\t\t\t\t{props.children}\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t)}export default Card2) 이미지 사이즈 최적화로딩 성능 최적화이미지 자체가 너무 커서 로딩하는 것 조차 네트워크 리소스를 많이 잡아 먹을 때가 있다.큰 사이즈를 이미지를 우리가 필요한 사이즈의 이미지로 줄이고 압축을 통해 더 낮은 용량의 이미지를 만들 수 있다.(1) 이미지 사이즈 포맷 PNG: 무손실 압축으로 용량이 크다 JPG: 압축이 되어있다. PNG 보다 JPG 사용을 권장한다. WEBP: JPG보다 더 좋은 이미지 포맷 지원하지 않는 브라우저가 존재한다 화질, 사이즈, 용량에 있어서 JPG보다 성능이 좋다. squoosh.app사이트를 통해 이미지를 변환한다.(2) 분기 추가하기 WEBP를 지원하지 않는 브라우저가 존재한다. &lt;picture&gt;태그를 활용하여 브라우저 별로 이미지 확장자를 다르게 제공할 수 있다.&lt;!-- 사이즈 --&gt;&lt;picture&gt; &lt;source srcset=\"mdn-logo-wide.png\" media=\"(min-width: 600px)\" /&gt; &lt;img src=\"mdn-logo-narrow.png\" alt=\"MDN\" /&gt;&lt;/picture&gt;&lt;!-- 확장자 --&gt;&lt;picture&gt; &lt;source srcset=\"photo.avif\" type=\"image/avif\" /&gt; &lt;source srcset=\"photo.webp\" type=\"image/webp\" /&gt; &lt;img src=\"photo.jpg\" alt=\"photo\" /&gt;&lt;/picture&gt;&lt;picture&gt;\t&lt;source data-srcset={main_items_webp} type=\"image/webp\" /&gt;\t&lt;img data-src={main_items} ref={imgEl1} alt=\"\" /&gt;&lt;/picture&gt; webp 파일 확장자를 제공하면 main_items_webp 이미지를 제공한다. 그러지 않을 경우 main_items 이미지를 제공한다.(3) webp에도 레이지 로딩 적용하기const callback = (entries, observer) =&gt; { entries.forEach(entry =&gt; { if(entry.isIntersecting) { console.log(entry.target.dataset.src);\t\t\t //이전 태그 (soure태그를 잡는다) const sourceEl = entry.target.previousSibling; sourceEl.srcset = sourceEl.dataset.srcset; entry.target.src = entry.target.dataset.src; observer.unobserve(entry.target); } });}3) 동영상 최적화로딩 성능 최적화(1) 동영상 압축동영상도 가로와 세로의 사이즈가 있고 화질에 따라 용량이 달라진다.단순하게, 동영상을 작은 용량을 압축해 주는 작업을 통해 최적화를 한다.그런데, 동영상 화질이 저하되기 때문에 동영상이 메인 컨텐츠면 해당 방법을 추천하지 않는다. media.io 에서 압축한다. WEBM 확장자로 압축 (2) 분기 처리 WEBM을 지원하지 않는 브라우저가 존재하기 때문에 분기처리를 해야 한다.&lt;video autoPlay loop muted&gt; &lt;source src={video_webm} type=\"video/webm\" /&gt; &lt;source src={video} type=\"video/mp4\" /&gt;&lt;/video&gt;(3) 화질 팁 화질이 너무 저하되면 오히려 유저의 경험이 나빠질 수 있다. 영상 길이를 줄이고 영상을 반복한다. 영상 위에 작은 도트를 반복해서 올린다. (동영상이 메인 컨텐츠가 아닐 때 ) 영상 자체에 블러처리를 한다. (동영상이 메인 컨텐츠가 아닐 때 )4) 폰트 최적화로딩 성능 최적화폰트를 로딩하느라, 텍스트가 나중에 화면에 보일 수 있다. (텍스트가 깜빡거린다)폰트는 하나의 리소스로서 네트워크에 다운받는다. FOUT (Flash of Unstyled Text): 폰트를 다운로드 하기 전에는 기본 폰트로 텍스트를 보여준다. IE, Edge 브라우저 FOIT (Flash of Invisible Text): 폰트를 다운로드 하기 전에는 아예 텍스트를 보여주지 않는다. Chrome , 사파리 브라우저 궁극적으로 웹폰트를 최적화 하여 위의 현상을 최소화 해야 한다.(1) 웹 폰트 적용 시점 컨트롤 font-display 속성을 활용하여 FOUT와 FOIT를 컨트롤 할 수 있다. 속성 설명 auto 브라우저 기본 동작 block FOIT (timeout = 3s)텍스트를 보여주지 않다가 3초 이내에 다운로드가 안되면, 3초 후에 기본 폰트를 적용한다. swap FOUT fallback FOIT (timeout = 0.1s)텍스트를 보여주지 않다가 0.1초 이내에 다운로드가 안되면, 0.1초 후에 기본 폰트를 적용한다. 3초 후에도 불러오지 못했을 시, 기본 폰트로 유지한다. 다운로드된 폰트는 캐시해둔다. optional FOIT (timeout = 0.1s)이후 네트워크 상태에 따라 기본 폰트로 유지 할지 웹폰트를 적용할지 결정한다. 폰트를 캐시해둔다.구글에서는 optional을 권장한다. (2) 페이드 효과 유저 체감 성능을 위해 fade효과를 적용할 수 있다. 폰트가 로드가 된 시점을 캐치해서 이벤트를 넣어준다. 폰트가 다운로드 되기 전에는 opacity 0을 준다 폰트가 다운로드 되면 opacity 1을 준다.폰트가 다운되었는지 파악하기 위해서는 fontfaceobserver를 사용하면 된다.$ npm install fontfaceobserverimport FontFaceObserver from 'fontfaceobserver'function BannerVideo() { const [isFontLoaded, setIsFontLoaded] = useState(false); const font = new FontFaceObserver('BMYEONSUNG'); // 폰트가 로드 되었는지 확인한다. useEffect(() =&gt; { font.load().then(function () { setIsFontLoaded(true); }); }, []); return ( &lt;div style=&gt; &lt;p&gt;KEEP&lt;/p&gt; &lt;/div&gt; )}export default BannerVideo(2) 폰트 사이즈 줄이기2-1. 웹폰트 포멧 사용 파일 크기: EOT &gt; TTF/OTF &gt; WOFF &gt; WOFF2 transfonter.org에서 폰트 포맷을 변환한다.지원하지 않는 브라우저를 생각해야 한다.@font-face { font-family: BMYEONSUNG; src: url('./assets/fonts/BMYEONSUNG.woff2') format('woff2'), url('./assets/fonts/BMYEONSUNG.woff') format('woff'), url('./assets/fonts/BMYEONSUNG.ttf') format('truetype'); font-display: block;}2-2. local 폰트 사용@font-face { font-family: BMYEONSUNG; src: local('BMYEONSUNG') url('./assets/fonts/BMYEONSUNG.woff2') format('woff2'), url('./assets/fonts/BMYEONSUNG.woff') format('woff'), url('./assets/fonts/BMYEONSUNG.ttf') format('truetype'); font-display: block;} local 키워드를 사용하면 이미 사용자가 PC에 존재하는 폰트를 체크해서 네트워크 없이 폰트를 사용할 수 있다.2-3. Subset 사용 사용하는 글자만 일부 가져온다.transfonter.org사이트에서 특정 글자만 가져올 수 있다. Characters칼럼에 작성 폰트 파일 사이즈가 작아지기 때문에 폰트가 엄청 빠르게 로딩된다.2-4. Unicode Range 적용 unicode-range를 사용하여 특정 유니코드 값을 작성하면 지정된 유니코드에만 폰트를 적용한다는 의미이다.@font-face { font-family: BMYEONSUNG; src: local('BMYEONSUNG') url('./assets/fonts/BMYEONSUNG.woff2') format('woff2'), url('./assets/fonts/BMYEONSUNG.woff') format('woff'), url('./assets/fonts/BMYEONSUNG.ttf') format('truetype'); font-display: block; /* 'A'만 폰트를 적용한다.*/ unicode-range: u+0041;} 불필요한 폰트를 로딩하는 것을 막는다.2-5. data-uri로 변환 transfonter.org사이트에서 base64 토클을 키고 변환한다. data-uri는 이미지 등의 외부 바이너리 파일을 웹페이지에 인라인으로 넣기 위해서 사용한다. 네트워크 호출이 아니기 때문에 용량이 커진 대신 별도로 폰트 파일을 가져오지는 않는다. 2-6. 폰트 PreloadCSS보다 먼저 불리기 위해서는 HTML 파일에 알려줘야 한다.&lt;link rel=\"preload\" href=\"./static/mdeia/BMYEONGSUNG.b184ad44.woff2\" as=\"font\" type=\"font/woff2\" crossorigin&gt; html이 로드하자마자 폰트가 어떤 리소스보다 먼저 load한다. (css, js 보다)이는 webpack을 수정해서 적용할 수도 있다.// config-overrides.js const PreloadWebpackPlugin = require('preload-webpack-plugin');module.exports = function override(config, env) { config.plugins.push(new PreloadWebpackPlugin({ rel: 'preload', as: 'font', include: 'allAssets', fileWhitelist: [/(.woff2?)/i] })); return config;}5) 캐시 최적화로딩 성능 최적화 효율적인 캐시 정책이 적용되어 있지 않다. 리소스들의 캐시 설정을 적용해야 한다. cache-control이라는 헤더를 통해 캐시 설정을 할 수 있다.(1) 캐시란 데이터나 값을 미리 복사해 놓는 임시 장소나 그런 동작이다.웹 브라우저는 두 가지 장법으로 캐싱을 한다. 메모리 캐시: RAM에 데이터를 저장해두는 방식 disk: file로 데이터를 저장하고 file을 읽어서 캐시를 불러들인다. 브라우저의 알고리즘에 따라서 알아서 적용된다.(2) cache-control브라우저가 특정 리소스를 요청할 때 cache-control이 http 헤더에 추가하여 캐시 관련 설정을 할 수 있다. 즉, 서버에서 설정을 해주어야 한다.ex) 몇 초 동안 캐시를 유지해~ 속성 설명 no-cache 캐시를 사용하기 전에 서버에 검사 후 사용을 결정한다. max-age=0과 유사하다. no-store 캐시를 사용 안한다. public 모든 환경에서 캐시 사용이 가능하다. private 브라우저 환경에서만 캐시를 사용한다. 외부 캐시 서버에서는 사용 불가하다. max-age 캐시의 유효시간 (sconds기준)캐시가 만료되면 서버에 계속 사용해도 되는 지 물어본다. 서버의 응답에 따라 다시 요청할 지가 결정된다.304: not modified (다시 요청하지 않고 계속 쓴다.) 그렇다면 서버는 어떻게 리소스가 변경되었음을 알 수 있는 걸까? 리소스에는 ETag가 붙어있다. 해쉬와 유사하다. 브라우저가 리소스를 가지고 있을 때 ETag를 가지고 있다. 서버에게 이 이미지 사용해도 괜찮아? 라고 물어볼때 ETag를 보내준다. 서버는 ETag의 변화 상태를 감지하여 브라우저에게 다시 알려주어 브라우저가 리소스를 다시 요청할지 결정하게 된다.(3) node를 활용한 서버 설정//server.jsconst express = require('express')const app = express()const port = 5000const path = require('path')const header = { setHeaders: (res, path) =&gt; { res.setHeader('Cache-Control', 'max-age=20') } },}app.use(express.static(path.join(__dirname, '../build'), header))app.get('*', (req, res) =&gt; { res.sendFile(path.join(__dirname, '../build/index.html'))})app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:${port}`))(4) 리소스별 관리 캐시는 최신 데이터를 어떻게 즉각 반영할 지가 중요하다. 그런데 절대 변경이 발생하지 않는 리소스가 있다면 캐시를 오랫동안 하는 것이 좋다. html 리소스: 즉각 변경을 위해 캐시가 걸려있지 않는 것이 좋다. 수정사항을 바로바로 반영할 수 없다. no-cahe js, css 리소스: 항상 최신으로 유지되어 있어야 한다. 그러나 webpack을 사용하여 번들링 할 때, js가 수정되면 최신의 js 리소스를 생성하기에 수정을 반영할 필요가 없다. 버전을 위해 해쉬를 설정하기 때문 항상 최신의 html을 유지하기에 항상 최신의 js를 요청하게 된다. max-age=30d html: no-cachejs: public, max-age: 3153600css: public, max-age: 3153600img: public, max-age: 3153600//server.jsconst express = require('express')const app = express()const port = 5000const path = require('path')const header = { setHeaders: (res, path) =&gt; { if(path.endsWith('.html')) { res.setHeader('Cache-Control', 'no-cache') } else if(path.endsWith('.js') || path.endsWith('.css') || path.endsWith('.webp')) { res.setHeader('Cache-Control', 'public, max-age=31536000') } else { res.setHeader('Cache-Control', 'no-store') } },}app.use(express.static(path.join(__dirname, '../build'), header))app.get('*', (req, res) =&gt; { res.sendFile(path.join(__dirname, '../build/index.html'))})app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:${port}`))6) 불필요한 CSS 제거로딩 성능 최적화 Coverage 탭을 활용 해당 파일에서 실제로 사용하는 코드의 비율을 보여준다. css 파일 사이즈를 줄이는데 도움을 준다.(1) Purge.css$npm i purgecss --save-devCSS에서 사용하지 않는 선택기를 제거하여 CSS 파일을 더 작게 만든다.2. 이미지 갤러리 서비스 최적화1) Layout Shife 피하기렌더링 성능 최적화랜더링이 느려서, 요소들이 이동하는 현상 화면상에서 위치를 다시 계산해야 한다. 사용성에 큰 영향을 준다.(1) 원인 사이즈가 정해져 있지 않은 이미지 사이즈가 정해져 있지 않은 광고 동적으로 삽입된 콘텐츠 Web font (FOIT, FOUT)(2) 해결방안사이즈가 정해져 있지 않아 문제가 발생하는 경우, 사이즈를 px이나 rem와 같이 고정시키면 된다. 반응형을 한다면, 가로 세로 비율을 고정함으로 사이즈를 정할 수 있다.import React from 'react';import styled from 'styled-components';function PhotoItem({ photo: { urls, alt } }) { return ( &lt;ImageWrap&gt; &lt;Image src={urls.small + '&amp;t=' + new Date().getTime()} alt={alt}/&gt; &lt;/ImageWrap&gt; );}// padding을 활용하여 너비의 56.25만큼 높이를 준다.const ImageWrap = styled.div` width: 100%; padding-bottom: 56.25%; position: relative;`;const Image = styled.img` cursor: pointer; position: absolute; width: 100%; height: 100%; top: 0; left: 0;`;export default PhotoItem;2) 이미지 지연(lazy) 로딩로딩 성능 최적화react-lazyload를 활용하여 좀 더 간편하게 이미지 레이지로딩을 할 수 있다.$ npm install --save react-lazyloadimport styled from 'styled-components';import LazyLoad from 'react-lazyload';function PhotoItem({ photo: { urls, alt } }) { // LazyLoad는 스크롤 이벤트를 사용한다. // offset은 얼마나 미리 로딩하겠는가이다. 1000px이전에 이미지를 미리 불러온다. return ( &lt;ImageWrap&gt; &lt;LazyLoad offset={1000}&gt; &lt;Image src={urls.small + '&amp;t=' + new Date().getTime()} alt={alt} onClick={openModal} /&gt; &lt;/LazyLoad&gt; &lt;/ImageWrap&gt; );}const ImageWrap = styled.div` width: 100%; padding-bottom: 56.25%; position: relative;`;const Image = styled.img` cursor: pointer; position: absolute; width: 100%; height: 100%; top: 0; left: 0;`;export default PhotoItem;3) useSelector 렌더링 문제 해결렌더링 성능 최적화리액트 렌더링 라이프 사이클은 성능에 많은 영향을 미친다.불필요한 시점에 발생하는 렌더링이나 빈번하게 발생하는 렌더링은 성능에 많은 영향을 미친다. 서비스에 어떤 타이밍에 컴포넌트가 렌더링이 되는 지 확인하기위해 ReactDevTool을 사용하면 된다. 의도한 렌더링이 맞는지 확인해야 한다.(1) useSelector 원리 Redux Store에는 다양한 State가 존재한다. 컴포넌트는 State를 구독하고 있다. 만약, State가 변경되어 Store도 변경된다면, 구독된 컴포넌트들에게 State가 변경되었음을 알린다. component는 변경되었다는 State와 이전 State와 비교하여 State가 변경되었으면 리렌더링을 한다. 그런데 useSelector과 값을 비교하는 방식은 return값을 통해 비교한다. a,b의 값을 갖는 객체이다. state가 변하면 객체를 새로 반환한다. 그래서 State가 변하지 않아도 리렌더링 되는 상황이 발생하는 것이다.해결 방안 Object를 새로 만들지 않도록 State 쪼개기 새로운 Equality Function 사용(2) Object를 새로 만들지 않도록 State 쪼개기import React from 'react';import { useSelector } from 'react-redux';import ImageModal from '../components/ImageModal';// 이전 코드function ImageModalContainer() { const { modalVisible, bgColor, src, alt } = useSelector( state =&gt; ({ modalVisible: state.imageModal.modalVisible, bgColor: state.imageModal.bgColor, src: state.imageModal.src, alt: state.imageModal.alt, }), ); return ( &lt;ImageModal modalVisible={modalVisible} bgColor={bgColor} src={src} alt={alt} /&gt; );}export default ImageModalContainer;위와 같이 object로 반환하는 것이 아니라 단일 값으로 만든다.import React from 'react';import { useSelector } from 'react-redux';import ImageModal from '../components/ImageModal';// state를 분리한다. const modlaVisible = useSelector(state =&gt; state.imageModal.modalVisible);const bgColor = useSelector(state =&gt; state.imageModal.bgColor);const src = useSelector(state =&gt; state.imageModal.src);const alt = useSelector(state =&gt; state.imageModal.alt); return ( &lt;ImageModal modalVisible={modalVisible} bgColor={bgColor} src={src} alt={alt} /&gt; );}export default ImageModalContainer;(3) 새로운 Equality Function 사용import React from 'react';import { useSelector, shallowEqual } from 'react-redux';import ImageModal from '../components/ImageModal';// 새로운 값을 비교하는 equality 함수를 useSelector 인자에 추가한다. // 기본적으로는 단순 비교를 한다. function ImageModalContainer() { const { modalVisible, bgColor, src, alt } = useSelector( state =&gt; ({ modalVisible: state.imageModal.modalVisible, bgColor: state.imageModal.bgColor, src: state.imageModal.src, alt: state.imageModal.alt, }),shallowEqual); return ( &lt;ImageModal modalVisible={modalVisible} bgColor={bgColor} src={src} alt={alt} /&gt; );}export default ImageModalContainer; shallowEqual은 단순 비교가 아닌 첫번째 depth에 있는 값들을 각각 비교한다.4) Redux Reselect를 통한 렌더링 최적화렌더링 성능 최적화reselect는 리더스와 같이 사용하는 라이브러리로 state에 있는 값을 가공해야 하는 경우 가공된 값을 state에서 관리할 수 있도록 한다.import React, { useEffect } from 'react';import { shallowEqual, useDispatch, useSelector } from 'react-redux';import PhotoList from '../components/PhotoList';import { fetchPhotos } from '../redux/photos';function PhotoListContainer() { const dispatch = useDispatch(); useEffect(() =&gt; { dispatch(fetchPhotos()); }, [dispatch]); const { category, allPhotos, loading } = useSelector( state =&gt; ({ category: state.category.category, allPhotos: state.photos.data, loading: state.photos.loading, }), shallowEqual ); // photos를 store에서 관리할 수 있도록 한다! const photos = category === 'all' ? allPhotos : allPhotos.filter(photo =&gt; photo.category === category); if (loading === 'error') { return &lt;span&gt;Error!&lt;/span&gt;; } if (loading !== 'done') { return &lt;span&gt;loading...&lt;/span&gt;; } return &lt;PhotoList photos={photos} /&gt;;}export default PhotoListContainer;$ npm install reselect(1) createSelector store에서 데이터를 꺼내오기위한 함수를 selector라고 한다. 우리는 reselctor 라이브러리로 selector를 생성할 수 있다.// 예시createSelector([select할 값], 값에 적용할 함수)const selectFilteredPhotos = createSelector ([state =&gt; state.photos.data], photos =&gt; photos)const photos = useSelector(selectFilteredPhotos);적용해보기// src/redux/photos// createSelector로 로직을 연결하여 값을 가져오기import { createSelector } from 'reselect';export default createSelector( [state =&gt; state.photos.data, state =&gt; state.category.category], (photos, category) =&gt; category === 'all' ? photos : photos.filter(photo =&gt; photo.category === category)); memoization 기법에 의해 reselect는 함수에 똑같은 인자가 들어오면 반환 값을 이미 캐시된 값으로 전달한다. 매번 값을 계산하지 않는다.import React, { useEffect } from 'react';import { useDispatch, useSelector } from 'react-redux';import PhotoList from '../components/PhotoList';import { fetchPhotos } from '../redux/photos';import selectFilteredPhotos from '../redux/selector/selectFilteredPhotos';function PhotoListContainer() { const dispatch = useDispatch(); useEffect(() =&gt; { dispatch(fetchPhotos()); }, [dispatch]); const photos = useSelector(selectFilteredPhotos); const loading = useSelector(state =&gt; state.photos.loading); if (loading === 'error') { return &lt;span&gt;Error!&lt;/span&gt;; } if (loading !== 'done') { return &lt;span&gt;loading...&lt;/span&gt;; } return &lt;PhotoList photos={photos} /&gt;;}export default PhotoListContainer;5) 병목 함수에 memoization 적용렌더링 성능 최적화함수에는 인풋과 아웃풋이 있다. memoization은 특정 input에 따른 output의 값을 미리 저장해 놓는 것을 의미한다.즉, 매번 함수를 실행시키지 않는다.들어오는 input이 매번 같거나 함수가 헤비한 경우 매우 효율적으로 함수를 구현할 수 있다.(1) 예제 input값을 알아야한다. 만약 동일한 input값이 왔다면, 캐시한 데이터를 반환한다. 순수함수여야 memoization을 적용할 수 있다. (동일한 input에 대해서 동일한 output을 보장하는 함수이다.)// 캐시할 데이터 const cache = {};export function getAverageColorOfImage(imgElement) { // input값 체크하여 만약 동일한 input이면 저장된 값을 반환한다. if (cache.hasOwnProperty(imgElement.src)) { return cache[imgElement.src]; } const canvas = document.createElement('canvas'); const context = canvas.getContext &amp;&amp; canvas.getContext('2d'); const averageColor = { r: 0, g: 0, b: 0, }; if (!context) { return averageColor; } const width = (canvas.width = imgElement.naturalWidth || imgElement.offsetWidth || imgElement.width); const height = (canvas.height = imgElement.naturalHeight || imgElement.offsetHeight || imgElement.height); context.drawImage(imgElement, 0, 0); const imageData = context.getImageData(0, 0, width, height).data; const length = imageData.length; for (let i = 0; i &lt; length; i += 4) { averageColor.r += imageData[i]; averageColor.g += imageData[i + 1]; averageColor.b += imageData[i + 2]; } const count = length / 4; averageColor.r = ~~(averageColor.r / count); // ~~ =&gt; convert to int averageColor.g = ~~(averageColor.g / count); averageColor.b = ~~(averageColor.b / count); // 저장! cache[imgElement.src] = averageColor; return averageColor;}(2) memoization 함수 만들기// memoize(func)(arg) === func(arg)function memoize(fn) { const cache={}; return function(...args) { if (args.length !== 1) { return fn(...args); }; if (cache.hasOwnProperty(args)){ return cache[args]; }; const result = fn(...args); cache[args] = result; return result; }; }; 이제 메모이제이션 함수로만 래핑을 하면 캐시를 사용할 수 있다. 팩토리 패턴 활용 메모이제이션은 메모리가 많이든다. input값이 매번 다른 경우에는 사용하지 않는 것을 추천한다.6) 병목 함수 로직 개선하기렌더링 성능 최적화함수의 로직 자체를 최적화 해도 성능이 개선된다. 퍼포먼스 탭을 통한 함수 성능을 분석한 뒤, 어디서 정체가 되는지 파악하고 개선한다.(1) drawImage, getImageData 개선직접 함수의 로직을 개선할 수 없는데 어떻게 성능 최적화를 할 수 있을까. 캔버스에 이미지 데이터를 그리는 작업이기 때문에 이미지 사이즈와 캔버스의 크기가 클 수록 그리는 속도는 느려질 것이다. 이미지를 사이즈를 작게 해서 가져오거나, 캔버스 사이즈를 줄이면 성능이 개선 될 수 있을 것이다.export function getAverageColorOfImage(imgElement) { // .. 생략 // 캔버스 사이즈 줄이기 canvas.width = width / 3; canvas.height = height / 3; context.drawImage(imgElement, 0, 0, canvas.width, canvas.height); const imageData = context.getImageData( 0, 0, canvas.width, canvas.height ).data; //.. 생략 }(2) 반복문 개선 모든 픽셀을 조사할 필요가없다. 띄엄띄엄 조사하자.export function getAverageColorOfImage(imgElement) { // .. 생략 // 이전에는 rgba에서 a를 제외하기 위해 i += 4 였음. // 10개 픽셀중 한개를 조사하기 위해 40으로 수정. for (let i = 0; i &lt; length; i += 40) { averageColor.r += imageData[i]; averageColor.g += imageData[i + 1]; averageColor.b += imageData[i + 2]; } const count = length / 40; averageColor.r = ~~(averageColor.r / count); averageColor.g = ~~(averageColor.g / count); averageColor.b = ~~(averageColor.b / count); //.. 생략 }" }, { "title": "견고한-UI-설계를-위한-마크업-가이드-Part1-HTML", "url": "/posts/performance02/", "categories": "WEB, Performance", "tags": "perfomance", "date": "2022-10-23 00:00:00 +0900", "snippet": "강의 링크 HTML은 문서의 골격, 분위기, 느낌을 제공한다. 웹에서 의사소통을 할 때, 문서의 골격을 제공하고 의미를 제공하여 사용자가 어떻게 읽어야 하는지 제공한다.1. HTML Content 분류 Flow content (플로우 컨텐츠) body에 포함할 수 있는 모든 요소이다. base, style, title 요소를 제외한 나머지 모든 요소. a, abbr, address, area, map, article, aside, audio, b, bdi, bdo,blockquote, br, button, canvas, cite, code, data, datalist, del,details, dfn, dialog, div, dl, em, embed, fieldset, figure,footer, form, h1, h2, h3, h4, h5, h6, header, hgroup, hr, i,iframe, img, input, ins, kbd, label, link, main, map, mark, math,menu, meta, meter, nav, noscript, object, ol, output, p, picture,pre, progress, q, ruby, s, samp, script, section, select, slot,small, span, strong, sub, sup, svg, table, template, textarea,time, u, ul, var, video, wbr, autonomous custom elements, text Metdata content (메타데이터 콘텐츠) 콘텐츠와 문서를 구조화 하는 요소를 의미, 다른 콘텐츠의 표시, 동작, 관계 등을 설정한다. 실제로 화면에 출력하는 요소들은 아니기 때문에, CSS에서는 ✨ display:none처리한다. base, link, meta, noscript, script, style, template, title Heading content (헤딩 콘텐츠) 섹셔닝 콘텐츠의 헤더. 섹셔닝 콘텐츠가 없어도 헤딩 콘텐츠가 있으면 암시적으로 섹션(==문서의 개요)이 형성된다. ✨display: block; h1, h2, h3, h4, h5, h6, hgroup Sectioning content (섹셔닝 콘텐츠) 문서의 개요를 형성. 헤딩, 헤더, 풋터의 범위. 각 섹셔닝 콘텐츠는 암시적인 개요를 형성한다. 또한, 섹셔닝 콘텐츠와 헤딩 콘텐츠를 함께 사용하면 명시적인 개요를 형성. ✨ display: block; article, aside, nav, section Phrasing content (프레이징 콘텐츠) 구문 콘텐츠. 단락을 형성하는 콘텐츠. ✨ display: inline | inline-block | none; a, abbr, area, audio, b, bdi, bdo, br, button, canvas, cite, code,data, datalist, del, dfn, em, embed, i, iframe, img, input, ins,kbd, label, link, map, mark, math, meta, meter, noscript, object,output, picture, progress, q, ruby, s, samp, script, select, slot,small, span, strong, sub, sup, svg, template, textarea, time, u,var, video, wbr, autonomous custom elements, text Embedded content (임베디드 콘텐츠) 외부 자원을 참조하는 콘텐츠. 모든 임베디드 콘텐츠는 구문 콘텐츠이다. 또한, 외부 자원을 지원하지 않는 경우 대체 자원을 명시할 수 있다. ✨ display: inline | inline-block; audio, canvas, embed, iframe, img, math, object, picture, svg, video Interactive content (인터렉티브 콘텐츠) 사용자와 상호 작용할 수 있는 콘텐츠. 입력 장치(키보드, 마우스)로 조작할 수 있다. ✨ display: inline | inline-block; a, audio, button, details, embed, iframe, img, input, label, select, textarea, video2. HTML 명세의 구성HTML Living Standard1) 명세서 분석 예시a element Category: 해당 태그가 어떤 카테고리에 속해있는 지에 대해 할 수 있다. Contexts: 부모 요소의 콘텐츠 모델을 유추할 수 있다. (사용되는 맥락) Contexts in which this elemenet can be used: 보통은 이런 맥락에서 쓰인다. (비 규범적) ContentModel: 자식 요소의 카테고리 (허용하는 자식 요소) Transparent content models (투명 콘텐츠 모델): 투명 콘텐츠 모델. 부모의 콘텐츠 모델을 따르며, 투명한 요소를 제거해도 부모와 자식 관계가 문법적으로 유효해야 한다. Tag omission in text/html: 해당 태그를 생략해도 되는 가 Contect Attributes2. 검색 엔진 밥상 차려주기HTML은 사용자에게 올바른 정보를 전달하기 위함이다. 그런데, 사용자에게 도달하지 않으면 아무런 의미가 없다.그런데 HTML을 사용하면 검색엔진에 잘 노출되도록 도와줄 수 있다.1) SEO에 영향을 주는 요인들 검색 결과 페이지(SERP) 노출 대비 클릭률 백링크(backlink): 다른 웹 페이지로부터 인용(링크)되는 횟수. 도메인 권력(Domain authority): 검색 결과 페이지 순위 예측 점수. 페이지 타이틀 메타 디스크립션 로딩 속도 SSL(https) 사용 여부 콘텐츠의 양, 질, 개연성 사용자 경험: LCP(최대 콘텐츠 블럭 그리기), CLS(누적 배치 변경) …2) 페이지 타이틀(1) 페이지 타이틀 명세 분류: 메타데이터 콘텐츠. 문맥: head 요소의 자식. 콘텐츠 모델: 텍스트. 공백만으로 구성할 수 없음. 태그 생략: 시작 태그와 종료 태그 모두 생략 불가능.(2) 모범 사례 본문을 가장 잘 설명하는 키워드를 중심으로 작성해야 한다. 페이지마다 구체적이고 고유한(흔하지 않은) 키워드를 사용할 수 있다. 페이지마다 반복하는 키워드를 최소화해야 한다. 구체적인 키워드를 앞에 작성해야 한다. 브라우저 탭에도 표시되기 때문에 어떻게 적느냐에 따라 사용자의 경험이 달라진다. 검색 로봇은 JS에 의해 동적으로 생성한 페이지 타이틀도 크롤링을한다.(3) 접근성화면 낭독기 사용자는 웹 페이지 접속 시 페이지 타이틀을 음성으로 전달 받는다.그래서 페이지 타이틀을 통해 요청한 페이지에 접속했는지 빠르게 판단할 수 있다.3) 메타 디스크립션3. HTML 개요 알고리즘 이해 웹 문서의 개요는 헤딩과 섹션으로 형성된다.Chrome HeadingsMap Extension을 활용하여 웹사이트의 Heading을 확인할 수 있다.1) Title과 Heading 헤딩이 없으면 개요가 없다. (문서의 목차가 없다.) &lt;title&gt;요소는 문서의 제목이다. 문서에서 한 번만 사용할 수 있다. &lt;h*&gt; 요소는 섹션의 제목이다. 문서에서 여러 번 사용할 수 있다. 문서의 골격을 설명하는 가장 중요한 태그이기 때문에, 생략하면 안 된다. 헤딩은 1부터 순차적으로 표기하는 것이 좋다. Heading은 문서 개요를 형성하는 기본(필수) 아이템으로 웹 브라우저와 화면 낭독기에 문서 개요를 드러내는 방법이다.2) Sectioning Root HTML 5에서 새롭게 추가된 명세로서 독립적인 개요를 생성하는 개요 컨테이너이다. 브라우저 제조사가 오랜시간 HTML5 아웃라인 알고리즘을 구현하지 않았기 때문에 이 개념을 실무에서 사용하는 것을 권장하지 않는다. 섹셔닝 루트 외부에서 내부 개요에 접근이 불가능하다. 문맥이 아닌 콘텐츠를 전체 개요에서 격리하는 역할이다. ex) 인용문3) Sectioning Content 개요의 범위를 명시적으로 지정하는 역할을 한다. 그 결과, 개요 형성에 많은 도움이 된다. 태그 설명 &lt;article&gt; 기사, 본문, 맥락으로 독립적으로 배포가 가능하다. &lt;aside&gt; 페이지의 주요 내용이 아닐 때 사용된다. &lt;nav&gt; 사이트의 주된 탐색 메뉴이다. &lt;section&gt; 주제 별로 나누거나 묶는다. HTML5에서 새롭게 추가된 명세로서 명시적 개요를 생성하는 개요 컨테이너이다. 적절한 수준의 헤딩을 자식 요소로 사용해야 한다.4) 실제 적용 섹셔닝 요소를 적극 사용하되 아웃라인 알고리즘(섹셔닝 루트, 헤딩 수준 자동 보정) 명세에는 의존하지 말아야 한다. 헤딩을 사용하고 헤딩과 섹션(article, aside, nav, section)을 1:1로 맵핑해야 한다. 헤딩은 순차적으로 적용되어야 한다. HTML5 개요 알고리즘(섹셔닝 루트, 헤딩 수준 자동 보정)에 의존하지 않는다.&lt;h1&gt;A &lt;article&gt;\t&lt;h2&gt;B\t &lt;section&gt;\t\t&lt;h3&gt;C4. HTML 의미론 The div element has no special meaning at all. The span element doesn’t mean anything on its own.즉, &lt;div&gt;와 &lt;span&gt;을 많이 사용하는 것은 HTML 태그를 의미 적절하게 사용하지 않는 것이다.보통은 스크립트나 css로 돔을 선택하거나 래핑할 때 사용해야 한다. (의미를 찾지 못했을 때 사용하는 태그)1) 요소를 대체할 만한 요소들(1) &lt;div&gt;h1, h2, h3, h4, h5, h6, p, ul, ol, li, dl, dt, dd, blockquote, pre, address...article, aside, nav, section, hgroup, header, footer,main, figure, figcaption, details, summary, dialog,datalistUA { display: block }(2) &lt;span&gt;a, em/strong, label, q, sub/sup, ins/del, code, dfn, abbr, cite, kbd, ruby,samp, var, small, b, u, i, s...data, time, mark, output, meter, progress2) HTML Semantics(1) &lt;header&gt;, &lt;footer&gt; &lt;header&gt;: 도입부, 헤딩, 헤딩 그룹, 목차, 검색, 로고 &lt;footer&gt; : 저자, 저작권, 연락처, 관련 문서 섹셔닝 루트(body) 또는 섹셔닝 콘텐츠(article, aside, nav, section)는 아니지만 이런 의미일 때 div 대신 사용하길 권장한다.&lt;body&gt; &lt;header&gt; 페이지 헤더 &lt;/header&gt; ...\t&lt;footer&gt; 페이지 푸터 &lt;/footer&gt;&lt;/body&gt;(2) &lt;section&gt;, &lt;article&gt; &lt;section&gt;: 제목이 있는 주제별 콘텐츠 그룹 또는 응용 프로그램 영역. &lt;article&gt;: 섹션 요소 중 독립적으로 배포 가능한 완결형 콘텐츠. 뉴스 기사, 블로그, 본문, 사용자의 댓글 등. h1~h6 요소를 포함하는 것을 강력하게 권장한다. header, footer 요소를 사용하는 것은 선택 사항&lt;section&gt;\t&lt;h2&gt; 섹션 헤딩 &lt;/h2&gt;&lt;/section&gt;&lt;article&gt;\t&lt;h2&gt; 완결형 콘텐츠 헤딩 &lt;/h2&gt;&lt;/article&gt;(3) &lt;nav&gt; 현재 사이트 또는 현재 페이지 일부를 링크 하고 있는 주요 탐색 섹션이다. 사이트 또는 페이지의 주요 탐색 경로에 해당하지 않는 빵부스러기 링크, 풋터의 약관, 저작권 고지 같은 링크는 nav 요소로 적절하지 않다. h1~h6 요소를 포함하는 것을 강력하게 권장한다.&lt;nav&gt;\t&lt;h2&gt; 섹션 헤딩 &lt;/h2&gt;&lt;/nav&gt;(4) &lt;aside&gt; 페이지의 주된 내용과 관련이 약해서 구분할 필요가 있는 섹션이다. 부수적인 콘텐츠, 관련 기사, 광고 등의 내용을 포함할 수 있다. h1~h6 요소를 포함하는 것을 강력하게 권장한다.&lt;aside&gt;\t&lt;h2&gt; 섹션 헤딩 &lt;/h2&gt;&lt;/aside&gt;(5) &lt;main&gt; 문서의 핵심 주제 또는 애플리케이션의 핵심 기능과 직접 관련 있는 콘텐츠 영역을 의미한다. 페이지마다 반복되지 않는 내용을 포함해야 한다. 섹셔닝 콘텐츠가 아니므로 hx, header, footer 요소의 범위와 관련 없다. 하나의 페이지 안에서 하나의 main 요소만 표시할 수 있고 섹셔닝 관련 요소(article, aside, nav, section, header, footer)의 자식이 될 수 없다. body, div 요소를 제외한 다른 요소의 자손이 될 수 없다.(6) &lt;dialog&gt; dialog 요소는 사용자와 상호 작용하는 응용프로그램 (대화상자)을 의미한다. open 속성을 추가하면 대화 상자가 활성화되고 사용자가 대화 상자를 통해 상호 작용할 수 있다. 보통 입력 양식과 콘트롤을 포함하고 있으며 닫기 기능을 제공한다. 키보드 초점이 dialog 요소 내부에서 순환하도록 처리해야 한다. 키보드 초점이 dialog에서 나가면 안된다. tab만으로도 dialog 내부 간 이동이 가능해야 한다. &lt;dialog &gt;\t&lt;h2&gt; 헤딩을 포함하는 것이 자연스럽다. &lt;/h2&gt;&lt;/dialog &gt;(7) &lt;figure&gt;, &lt;figcaption&gt; 문서의 주된 흐름을 위해 참조하는(부록으로 옮겨도 괜찮은) 독립적인 완결형 요소로서 이미지, 도표, 코드 등의 내용물과 설명(figcaption)을 포함한다. 선택적으로 처음 또는 마지막에 figcaption 요소를 자식 요소로 포함할 수 있고 또는 생략할 수 있다. figure 안에서 figcaption 요소가 선언 된다면 한 번만 선언할 수 있다. figcaption은 부모 figure 요소의 내용에 대한 설명 또는 범례를 의미한다. 반드시 figure 요소의 처음 또는 마지막에 포함할 수 있고 또는 생략할 수 있다. &lt;figure&gt;\t&lt;img&gt; &lt;figcaption&gt;이미지 설명&lt;/figcaption&gt;&lt;/figure&gt;(8) etc 태그 설명 &lt;mark&gt; 독자의 주의를 끌기 위한 하이라이트로 현재 독자의 행위나 관심에 따라 강조한 것이다. 검색 결과 목록에서 사용자가 입력한 키워드이다. &lt;address&gt; 가까운 조상 article 또는 body 요소를 범위로 하는 관련 연락처 정보이다.우편 정보를 의미하는 것이 아님에 유의해야 하며. 흔히 footer 요소에 나타남.p 요소의 자손이 될 수 없다. &lt;ins&gt;, &lt;del&gt; &lt;ins&gt;는 추가한 내용을 의미한다.&lt;del&gt;은 삭제한 내용을 의미한다.콘텐츠 모델이 투명해서 어떤 요소라도 포함할 수 있지만, 여러 단락을 한꺼번에 포함하는 것은 부적절하다. &lt;progress&gt; 계산 또는 사용자 과업의 진척도를 의미한다.원격 호스트의 응답을 기다려야 하는 경우도 있을 수 있기 때문에 진척도는 정확하지 않을 수 있다.낡은 브라우저를 위해 value 값과 별도로 콘텐츠를 제공하는 것이 좋다. &lt;b&gt;, &lt;i&gt;, &lt;s&gt;, &lt;u&gt; &lt;b&gt;: 강조할 의도가 없는 볼드를 의미하며 &lt;strong&gt; 요소를 고려한 뒤 사용하는 것이 좋다. &lt;i&gt;: 현재 맥락과 다른 분위기를 의미하며 &lt;em&gt;요소를 고려한 뒤 사용하는 것이 좋다. &lt;s&gt;: 정확하지 않거나 관련 없는 것을 의미하며 &lt;del&gt;요소를 고려한 뒤 사용하는 것이 좋다. &lt;u&gt;: 오타, 중국 고유 명사 등을 표기할 때 사용하며 &lt;ins&gt; 요소를 고려한 뒤 사용하는 것이 좋다. 5. 상호작용 콘텐츠의 올바른 용법 사용자와 상호 작용하는 부분에 대한 태그가 존재한다. 사용자는 웹페이지를 조작하거나 내용을 입력하기도 한다. 이 과정 중에서 만나는 문제들을 HTML로 처리할 수 있다. 사용자와 상호 작용할 수 있는 콘텐츠. 입력 장치(키보드, 마우스)로 조작할 수 있다.a, audio, button, details, embed, iframe, img, input, label, select, textarea, video1) &lt;a&gt; vs &lt;button&gt; 같은 외형을 지닌 경우라도 a, button 요소를 구별해서 사용해야 한다. 실행 결과를 가리킬 수 있는 URL이 있으면 a 요소를 사용한다. 혹은 대화 상자를 참조하는 경우. a 요소의 href 값은 dialog 요소의 id (해시 URL)를 참조할 수 있다. 링크 위에 마우스를 올리면 웹 브라우저는 상태 표시줄에 목적지 URL을 표시해 준다. 문맥 메뉴를 이용하면 새 탭에서 링크 열기 기능을 사용할 수 있다. 참조할 URL이 없으면 button 요소를 사용한다. 타겟 URL을 설정할 수 없거나, 타겟 URL을 설정하지 않는 게 나은 상황. 커서 모양이 다름에 유의해야 한다. 버튼에 손 모양 커서를 사용하면 안 된다. (1) a target&lt;a href=\"링크\" target=\"_blank\" rel=\"noopener noreferrer\"&gt; 안전하지 않은 외부 페이지 새 창 링크이다. rel속성을 사용하지 않으면, 새 창으로 열린 외부 페이지 B는 자바스크립트 window.opener 객체를 통해 부모 페이지 A의 제어 권한을 획득. 사용자는 탭 가로채기(tabnabbing) 공격에 노출된다. rel속성의 noopener 값은 window.opener 객체를 제거한다. 그리고 noreferrer 값은 window.opener 제어 불능 시킨다. noopener를 지원하지 않는 낡은 브라우저를 위해 noreferrer를 함께 표기한다. 최신 브라우저는 target=”_blank” 링크에 rel=”noopener” 속성을 암시적으로 적용하고 있다.2) &lt;details&gt; 열림 상태일 때 정보를 표시하는 위젯이다. details 요소에 open 속성을 넣으면 열린 상태로 표시한다. summary 요소는 details 요소의 나머지 부분에 대한 요약, 캡션, 범례를 의미한다.&lt;details open&gt;\t&lt;summary&gt;details 요소란?&lt;/summary&gt;\t&lt;p&gt;열림 상태가 아닐 때, 보이지 않는다.&lt;/p&gt;&lt;/details&gt;3) &lt;input&gt; 다양한 쓰임의 type을 아는 것이 input 활용의 모든 것이다.input-type(1) attrs 속성 설명 required 필수 값임을 명시한다. placeholder 콘트롤에 초깃값이 없을 때 사용자에게 데이터 입력을 지원하기 위해 제공하는 짧은 힌트나 샘플이다.&lt;label&gt;의 대안으로 사용하면 안 된다. datalist 다른 콘트롤을 위해 미리 정의된 옵션 세트를 의미한다. &lt;label for=\"local\"&gt;지역 번호&lt;/label&gt;&lt;input type=\"text\" id=\"local\" list=\"local-list\"&gt;&lt;datalist id=\"local-list\"&gt;\t&lt;option value=\"02\" label=\"서울\"&gt;&lt;/option&gt; &lt;option value=\"031\" label=\"경기\"&gt;&lt;/option&gt;&lt;/datalist&gt;6. 이미지 마크업 최적화 이미지 포맷 설명 .jpg, png 모든 브라우저에서 지원하는 폴백 이미지이다. .webp jpg/png 대비 30 ~ 70% 수준의 용량이다. (알파 채널, IE 미지원) .avif 저용량 + 고품질 (알파 채널, 크롬 / 삼성 인터넷 지원) 1) &lt;picture&gt; &lt;picture&gt; 태그의 속성에 따라 분기할 수 있다.(1) 확장자 분기avif 포맷을 제공하고 webp, jpg를 대체 수단으로 제공할 수 있다.if ('avif'를 지원하면) {'avif' 출력} else if ('webp'를 지원하면) {'webp' 출력} else {'jpg' 출력}&lt;picture&gt;\t&lt;source srcset=\"x.avif\" type=\"image/avif\"&gt; &lt;source srcset=\"x.webp\" type=\"image/webp\"&gt; &lt;source srcset=\"x.jpg\" alt &gt;&lt;/picture&gt;(2) media 쿼리에 따른 사이즈 분기&lt;picture&gt; &lt;source srcset=\"samll.webp\" media=\"(max-width:960px)\"&gt; &lt;source srcset=\"large.webp\" alt &gt;&lt;/picture&gt;(3) 해상도 분기2x는 사용자가 레티나 디스플레이를 사용할 때를 의미한다.&lt;picture&gt; &lt;source srcset=\"retina.webp 2x, default.webp\" &gt; &lt;img srcset=\"retina.jpg 2x\" src=\"default.jpg\" alt&gt;&lt;/picture&gt;(4) 성능 개선빠른 로딩 속도를 통해 이미지 전송 비용(User/Service)을 절약할 수 있다.&lt;img\tloading=\"lazy\" // 지연 로딩 decoding=\"async\" // 디코딩 지연&gt;" }, { "title": "실전-웹-성능-최적화-(feat. React)-Part1", "url": "/posts/performance01/", "categories": "WEB, Performance", "tags": "perfomance", "date": "2022-10-15 00:00:00 +0900", "snippet": "강의 링크웹 성능은 크게 두 가지로 분류할 수 있다.바로, 로딩 성능과 렌더링 성능이다. 로딩 성능: 각 리소스를 불러오는 성능을 의미한다. 렌더링 성능: 불러온 리소스를 화면에 보여주는 성능을 의미한다.1. 블로그 사이트 최적화총 4 가지의 분석 툴을 사용하여 사이트의 최적화를 진행한다. 크롬 Network 탭 크롬 Performance 탭 크롬 Light house 탭 webpack-bundle-analyzer 추천: 로딩 성능 최적화와 관련된 내용 진단: 렌더링 성능 최적화와 관련된 내용1) 이미즈 사이즈 최적화로딩 성능 최적화최저화가 필요한 이미지의 리스트를 볼 수 있다. 실제로 사용되는 이미지 사이즈보다 과도하게 큰 사이즈의 이미지를 불러오면 안 된다. ex) 120 x 120 이미지일 경우, 2배 정도 더 큰 이미지를 사용하는 것이 좋다./* 파라미터 참고: https://unsplash.com/documentation#supported-parameters */function getParametersForUnsplash({ width, height, quality, format }) { return `?w=${width}&amp;h=${height}&amp;q=${quality}&amp;fm=${format}&amp;fit=crop`;}// width 와 height를 240으로 제한한 것 만으로 성능이 개선된다. &lt;img src={props.image + getParametersForUnsplash({ width: 240, height: 240, quality: 80, format: \"jpg\" })} alt=\"thumbnail\"/&gt;만약, 이미지를 api를 통해 가져오는 경우 어떻게 해야 할까?Image CDN를 사용하여 해결한다. 이미지에 전처리를 하여 사용자에게 제공한다.일반적으로 CDN은 물리적 거리의 한계를 극복하기 위해 유저와 가까운 곳에 콘텐츠 서버를 두는 것을 의미하지만, Image CDN은 이미지를 전처리하여 사용자에게 제공하는 것을 의미한다.실제로 브런치에서도 이미지 CDN을 활용하고 있다.ex) http://cdn.image.com?src=[img.cdn]&amp;width=200&amp;height=1002) Code Split로딩 성능 최적화자바스크립트 파일이 다운로드가 된 이후부터 JS를 평가하고 코드가 실행되기 때문에, 다운로드가 걸리는 시간만큼 화면이 뜨는 시간도 오래 걸리게 된다.번들 analyzer를 통해 번들 파일을 분석할 수 있다. WebpackBundleAnalyzer CRA를 사용하는 경우 Chunk.js &gt; node_modules 이기 때문에, 우리가 설치한 모듈들이 chunk.js를 차지하는 것을 알 수 있다. 그 중에서도 refractor가 많은 비중을 차지하고 있다. package-lock.json에서는 설치한 모듈들의 하위 디펜던시를 확인할 수 있는데, refractor라는 라이브러리를 확인할 수 있다. 그러나, 해당 모듈은 특정 페이지에서만 사용하기 때문에 필요할 때만 로드하면 성능을 개선할 수 있다. 즉, 페이지 별로 코드를 분할하거나 모듈 별로 코드를 분할할 수 있다.여기서 중요한 것은, 불필요한 코드 또는 중복되는 코드가 없이 적절한 사이즈의 코드가 적절한 타이밍에 로드될 수 있도록 하는 것이다.리액트 공식 문서 / webpack 공식 문서//* lazyloading과 Suspense를 활용하여 성능을 개선한다. import React, { Suspense, lazy } from \"react\";import { Switch, Route } from \"react-router-dom\";const ListPage = lazy(() =&gt; import(\"./pages/ListPage/index\"));const ViewPage = lazy(() =&gt; import(\"./pages/ViewPage/index\"));function App() { return ( &lt;div className=\"App\"&gt; &lt;Suspense fallback={&lt;div&gt;로딩중&lt;/div&gt;}&gt; &lt;Switch&gt; &lt;Route path=\"/\" component={ListPage} exact /&gt; &lt;Route path=\"/view/:id\" component={ViewPage} exact /&gt; &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/div&gt; );}export default App;위의 이미지를 보면, react-dom과 refactor가 분리된 것을 확인할 수 있다.3) 텍스트 압축로딩 성능 최적화웹 페이지를 로드할 때는 html, js, css와 같은 텍스트들로 이루어진 리소스를 다운 받는다. 해당 문서의 사이즈를 줄이면 당연히 로딩 성능이 개선된다.텍스트 압축이란 말 그대로 서버에서 보내는 리소스를 압축해서 보낸다. 네트워크 탭을 통해 압축을 하고 있는지 확인 할 수 있다.텍스트 압축은 크게 두 가지 방법이 있다. GZIP: Deflate보다 좋은 압축률을 갖고 있다. Deflate그래서 압축이 되어 있지 않는 파일들을 압축하여 성능을 개선할 수 있다. 그런데 압축을 푸는 데도 시간이 걸리기 때문에, 무조건 압축을 하는 것은 좋지 않다.파일 크기가 2KB이상이 되면 인코딩을 하는 것이 좋다.4) Bottleneck 코드 최적화렌더링 성능 최적화Perfomance 탭을 보면 Article이 굉장히 오랫동안 렌더링 되는 것을 알 수 있다.이는 아래에 있는 removeSpecialCharacter함수가 원인으로 보이기 때문에 해당 로직을 수정하면 해결된다.로직을 효율적으로 작성하고 작업하는 양을 줄여 아래와 같이 성능을 개선할 수 있다./* * 파라미터로 넘어온 문자열에서 일부 특수문자를 제거하는 함수 * (Markdown으로 된 문자열의 특수문자를 제거하기 위함) * */function removeSpecialCharacter(str) { const removeCharacters = [\"#\", \"_\", \"*\", \"~\", \"&amp;\", \";\", \"!\", \"[\", \"]\", \"`\", \"&gt;\", \"\\n\", \"=\", \"-\"]; let _str = str; let i = 0, j = 0; for (i = 0; i &lt; removeCharacters.length; i++) { j = 0; while (j &lt; _str.length) { if (_str[j] === removeCharacters[i]) { _str = _str.substring(0, j).concat(_str.substring(j + 1)); continue; } j++; } } return _str;}// 위의 로직은 replace와 정규식을 활용하여 더 효율적으로 개선할 수 있다. // sbustring을 활용하여 로직에 적용하는 문자열을 2000자로 제한한다.function removeSpecialCharacter(str) { let _str = str.substring(0, 2000) _str = _str.replace(/[\\#\\_\\*\\~\\&amp;\\;\\!\\[\\]\\`\\&gt;\\/n\\=\\-]/g, \"\"); return _str;}2. 통계사이트 최적화1) 애니메이션 최적화 (Reflow, Repaint)렌더링 성능 최적화애니메이션은 여러 장의 이미지가 반복적으로 바뀌면서 움직이는 것처럼 보이는 트릭이다. 그런데, 중간의 프레임이 유실되면 뭔가 중간에 뚝 끊기는 느낌이 든다. Display: 일반적으로 초당 60Frame이다. 일초에 60개의 화면을 보여준다. 브라우저도 초당 60Frame으로 화면을 랜더링 하려고 한다. 그러나, 브라우저가 초당 60Frame의 화면을 그리지 못하기 때문에 애니메이션이 버벅이게 보이는 것이다. 쟁크 현상: 애니메이션이 버벅이는 현상 그렇다면, 왜 브라우저가 60Frame으로 그리지 못하는 걸까? 이를 위해서는 브라우저 렌더링 과정에 대해서 알아야 한다.(1) 브라우저 렌더링 과정Critical Rendering Path, Pixel Pipeline브라우저는 기본적으로 위의 과정을 거쳐서 화면을 그리게 된다. HTML, CSS, JS와 같은 기본적인 파일을 리소스로 받는다. HTML은 DOMTree, CSS 는 CSSOMTree의 데이터 타입으로 변환한다. DOM: 요소들간의 관계를 트리구조로 만든다. CSSOM: 각 요소의 스타일을 트리 구조로 만든다. DOM과 CSSOM을 조합하여 RenderTree를 만든다. 요소에 대한 컨텐츠와 스타일을 합친다. Layout: 위치, 크기를 계산한다. 어느 위치에 해당 요소가 어느 사이즈로 위치해야 할 지 계산한다. Paint: 색을 채워 준다. Composite: 각 레이어를 합성한다. 브라우저가 화면을 그릴 때, Layouy과 Paint는 레이어로 쪼개져서 진행이 된다. 이렇게 여러 개로 쪼개진 레이어를 하나로 합쳐서 최종적인 화면을 그리게 된다. 만약, 이렇게 완성된 화면에서 일부 스타일이 변경된다면 변화된 내용을 가지고 다시 DOM, CSSOM을 만들고 렌더링 과정을 다시 진행하게 된다.초당 60Frame (0.016초)안에 화면을 재빠르게 보여주어야 하는데, 짧은 시간에 렌더링을 다시 진행하여 일부 Frame이 유실 되는 것이다.(2) Reflow와 Repaint그래서 우리는 브라우저가 맡은 일을 줄여 성능을 개선할 수 있다. 스타일의 width, height가 변경되면 Pixel Pipeline을 다시 실행(Reflow) 스타일의 색상이 변경되면 Layout을 생략한 pixel Pipeline을 다시 실행(Repaint) GPU의 도움을 받아 Reflow와 Repaint를 피할 수 있다. transform, opacity를 변경 하면, Layout과 Paint가 생략된 Pixel Pipeline을 다시 실행한다. GPU가 직접 관여하여 바로 Compositie단계로 넘겨준다. (3) transform을 사용하여 성능 개선const BarGraph = styled.div` position: absolute; left: 0; top: 0; width: ${({width}) =&gt; width}%; transition: width 1.5s ease; height: 100%; background: ${({isSelected}) =&gt; isSelected ? 'rgba(126, 198, 81, 0.7)' : 'rgb(198, 198, 198)'}; z-index: 1;`// transform을 사용하여 성능을 개선const BarGraph = styled.div` /*.. 생략 */ transform: scaleX(${({ width }) =&gt; width / 100}); transform-origin: left; transition: transform 1.5s ease;`; width로 애니메이션에서는 Frame드롭이 발생하는 것을 확인할 수 있다. 또한, 보라색 영역 (메인 스레드)에서 주로 처리한다.2. 컴포넌트 Lazy Loading(Code Splitting)로딩 성능 최적화Gallery 모듈은 모달이 보일때만 사용하는 모듈이기 때문에 처음에 로드할 필요가 없다. ImageModal을 레이지 로드하면, 아래의 이미지와 같이 분리된다.로딩속도나 자바스크립트 평가 속도가 빨라져서 더 빠르게 화면을 render할 수 있다.3. 컴포넌트 Preloading로딩 성능 최적화위에서 모달을 레이지 로딩 하였기 때문에, 모달을 열기 위해 클릭하면 그때 Modal과 관련된 모듈을 받게 되고 이를 평가 한 뒤 모달을 렌더하게 된다.즉, 최초 페이지에서는 성능이 좋아졌지만 모달에서는 성능이 나빠졌다.그래서 Preloading을 통해 버튼을 클릭하여 모달을 열기 전에 미리 모달과 관련된 코드를 load를 할 수 있다.문제는 사용자가 버튼을 언제 클릭할 지 모르기 때문에 언제 미리 로딩할 지 모른다. 그래서 컴포넌트를 Preloading하는 타이밍은 총 두 가지로 나눌 수 있다. 버튼 위에 마우스를 올려 놨을 때 최초 페이지가 로드되고, 모든 컴포넌트의 마운트가 끝났을 때(1) 버튼 위에 마우스를 올려 놨을 때const LazyImageModal = lazy(() =&gt; import(\"./components/ImageModal\")); const handleMouseEnter = () =&gt; { const component = import(\"./components/ImageModal\"); };(2) 모든 컴포넌트가 로드가 완료 된 후, 모듈을 미리 로드한다.const LazyImageModal = lazy(() =&gt; import(\"./components/ImageModal\"));useEffect(() =&gt; import(\"./components/ImageModal\"), []);// 만약 여러개의 컴포넌트를 import한다면, function lazyWithPreload(importFunction) { const Component = React.lazy(importFunction); Component.preload = importFunction; return Component;}const LazyImageModal = lazyWithPreload(() =&gt; import(\"./components/ImageModal\")); useEffect(() =&gt; { LazyImageModal.preload(); }, []);4. 이미지 Preloading로딩 성능 최적화네트워크에서 캐시 사용 중지를 통해 캐시를 리셋하면, 모달 안에 있는 이미지 로딩이 느린 것을 확인할 수 있다.이미지는 이미지를 화면에 노출하는 시점이 아니면, 로드 하지 않는다.대신 JS의 image 객체를 사용하면 미리 로딩할 수 있다.// 이미지를 미리 불러와서 캐시해 두고 사용한다. // 그래서 이미지가 캐시가 잘 되고 있는지 확인해야 한다. 그렇지 않으면 다시 또 요청한다. useEffect(() =&gt; { LazyImageModal.preload(); const img = New Image(); img.src = 이미지 링크 }, []);" }, { "title": "운영체제-Deadlocks", "url": "/posts/operationsystem07/", "categories": "CS, 운영-체제", "tags": "cs, 운영-체제", "date": "2022-09-20 00:00:00 +0900", "snippet": "7장-Deadlocks (교착 상태)강의 링크1. Deadlock Problem1) 정의 데드락이란 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태를 의미한다.여기서 자원이란 하드웨어, 소프트웨어 등을 포함하는 개념 ex) I/O Device, CPU Cycle, Memory Space, Semaphore 등프로세스가 자원을 사용하는 절차는 크게 4단계를 거치게 된다. 자원 요청 Request 자원 할당 Allocate 자원 사용 Use 자원 반납 Release2) 발생 조건4가지 조건을 모두 충족시켜야 데드락이 발생한다. Mutual Exclusion (상호 배제) 매 순간 하나의 프로세스만이 자원을 독점적으로 사용한다. No Preemption (비선점) 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지는 않는다. Hold and Wait (보유대기) 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있다. Circular Wait (자원 대기) 자원을 기다리는 프로세스간에 사이클이 형성되어야 한다. 3) 자원 할당 그래프 자원(R) -&gt; 프로세스(P): 해당 자원이 해당 프로세스에 속해있다. 프로세스(P) -&gt; 자원(R): 해당 프로세스가 해당 자원을 요청했다. (아직 미획득 상태)자원 할당 그래프에서 Cycle이 없으면 데드락이 아니다. 만약 사이클이 있다면 다음의 조건을 충족하면 데드락이다. 만약 자원당 instance(점)이 하나밖에 없으면 데드락이다. 자원당 인스턴스가 여러개일 경우에는 데드락일 수도 있고 아닐수도 있다.2. Deadlock의 처리 방법 Deadlock Prevention 자원 할당 시 Deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것 Deadlock Avoidance 자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당한다. 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원을 할당한다. Deadlock Detection and Recovery Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견 시 recover한다. Deadlock Ignoracne Deadlock을 시스템이 책임지지 않는다. Deadlock을 방지하는 것이 오버헤드가 너무 많이 들기 때문에 유저가 해결하도록 한다. UNIX를 포함한 대부분의 OS가 채택한다. 1) Deadlock Prevention (미연에 방지한다) Deadlock 필요조건 중 하나를 충족시키지 않게 하여 미연에 방지한다. Mutual Exclusion 공유해서는 안되는 자원의 경우 반드시 성립해야 한다. Hold and Wait 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 한다. 방법1 프로세스 시작 시 모든 필요한 자원을 할당 받게 하는 방법이다. 방법2 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청한다. (자진해서 반납을 함으로 해결한다.) No Preemption Process가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점된다. 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다. State를 쉽게 save하고 restore할 수 있는 자원에서 주로 사용한다. (CPU, memory) Circular Wait 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원을 할당한다. 예를 들어 순서가 3인 자원 R3을 보유 중인 프로세스가 순서인 1인 자원 R1를 할당받기 위해서는 우선 R3를 Release해야 한다. 원천적으로 Deadlock을 막을 수 있지만, 굉장히 비효율적이다. (자원에 제약을 두기 때문이다)2) Deadlock Avoidance 프로세스가 시작될 때, 평생에 쓸 자원을 알고 있다고 가정한다. Deadlock이 될 수있는 자원 할당 요구를 허락하지 않음으로 Deadlock을 피한다. 자원당 인스턴스가 1개일 때는 자원 할당 그래프를 활용한다. 자원당 인스턴스가 여러개일 때는 Banker’s Algorithm을 활용한다. 자원 요청에 대한 부가 정보를 이용해서 자원 할당이 deadlock으로부터 안전(safe)한지를 동적으로 조사해서 안전한 경우에만 할당한다. 가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하도록 하는 방법이다.✅ Deadlock Avoidance는 safe한 상태를 유지하는 것이다safe state는 시스템 내의 프로세스에 대한 safe sequence가 존재하는 상태이다.safe sequence란 프로세스의 sequence가 safe하려면 프로세스의 자원 요청이 가용자원 + 모든 프로세스의 보유자원에 의해 충족되어야 한다. 조건을 만족하면 다음 방법으로 모든 프로세스의 수행을 보장한다. Pi의 자원 요청이 즉시 충족될 수 없으면 모든 Pj (j &lt; i )가 종료될 때까지 기다린다. Pi-1이 종료되면 Pi의 자원요청을 만족시켜 수행한다. 3) Deadlock Detection and recovery Deadlock은 빈번히 발생하는 이벤트가 아니기 때문에, 미연에 방지 하기 위해 처리를 하기보다 발생하면 처리를 한다.우측을 Wait for graph라고 부른다. Wait for graph는 사이클을 빠르게 찾을 수 있기 때문에, Deadlock이 발생하는 지를 빠르게 확인할 수 있다.자원 당 인스턴스가 여러 개있을 때는 위와 같은 발견으로 deadlock을 찾기 어렵고 다른 방법으로 찾는다.여튼 deadlock을 발견하면 이를 recovery해야 한다. ProcessTermination 프로세스를 종료시킨다. Resouces Preemption 프로세스에서 자원을 뺏는다. 비용을 최소화할 victim을 선정한하고 safe state로 rollback하여 process를 restart한다. Starvation문제가 발생할 수 있다.. 동일한 프로세스가 계속해서 victim으로 선정되는 경우 cost factor에 rollback 횟수도 같이 고려한다. 4) Deadlock Ignoracne Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는다. Deadlock이 매우 드물게 발생하므로 deadlock에 대한 조치 자체가 더큰 오버헤드일 수도 있다. 만약, 시스템 deadlock이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처한다. UNIX, WIndows등 대부분의 범용 OS가 채택하고 있다." }, { "title": "운영체제-Process-Synchronization", "url": "/posts/operationsystem06/", "categories": "CS, 운영-체제", "tags": "cs, 운영-체제", "date": "2022-09-20 00:00:00 +0900", "snippet": "6장-Process-Synchronization강의 링크 공유데이터의 동시 접근은 데이터의 불일치 문제를 발생시킨다. 일관성 유지를 위해서는 협력 프로세스 간의 실행 순서를 정리해주는 메커니즘이 필요하다.1. 기본 개념1) Race Condition Race Condition(경쟁 상태)는 여러 프로세스들이 동시에 데이터를 접근하는 상황에서 어떤 순서로 접근하느냐에 따라 결과가 달라지는 상황을 의미한다.여러 프로세스들이 동시에 공유 데이터를 접근하는 상황으로 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라진다. Kernel 수행 중 인터럽트 발생 커널모드 running 중 인터럽트가 발생하여 인터럽트 처리 루틴이 수행되면 양쪽 다 커널 코드이므로 kernel address space를 공유한다. 해결책: 커널모드의 수행이 끝나기 전에는 인터럽트를 받지 않는다. (disable/enable) Process가 System call을 해서 kernel mode로 수행 중인데 context swtich가 일어난 경우 두 프로세스의 주소 공간에서ㄷ는 데이터를 공유하지 않지만 시스템 콜을 수행할 때는 둘 다 커널 주소 공간의 데이터에 접근한다. 커널 주소 공간에 작업을 수행하는 도중에 CPU를 빼앗으면 race condition이 발생한다. 해결책: 커널 모드를 수행 중일 땐 CPU가 preempt 하지 않고, 커널 모드에서 유저 모드로 돌아갈 때 preempt 한다. Multiprocessor에서 shared-memory 내의 kernel data 해결책: 커널 내부에 있는 공유 데이터에 접근할 때마다 그 데이터에 대해서 lock/unlock 한다. race condition을 막기 위해서는 concurrent process는 동기화 되어야 한다.2) Critical-Section n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우로 race condition이 발생할 수 있는 특정 부분을 의미한다. 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재한다. 해결 법의 충족 조건 Mutual Exclusion (상호 배제): 프로세스가 critical section 부분을 수행 중이면 다른 프로세스들은 그들의 critical section에 들어가면 안된다. Progress (진행): 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 포르세스가 있으면 critical section에 들어가게 해주어야 한다. Bounded Waiting (유한 대기): 프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 떄까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다. 하드웨어적으로 현재 상태를 확인하고 변경하는 Test &amp; modify를 atomic하게 수행할 수 있도록 지원하면 간단하게 해결할 수 있다. 소프트웨어적으로 알고리즘을 통해 해결할 수 있지만, 하드웨어적으로 해결하는 것이 더 간편하다. 데이터를 읽으면서 동시에 쓰는 것이 하나의 instruction으로 수행이 가능하다면, 수행 중 CPU를 빼앗기지 않는다. Test_and_set(a): a의 값을 읽고 a의 값을 1로 세팅한다. =&gt; 하나의 instruction이다. lock이 안 걸렸다면, 걸고 들어간다. lock이 걸려있으면, while 문을 돌면서 기다린다. // Synchronization variable: boolean lock = false;// Process Pido { while(Test_and_Set(lock)); critical section lock = false; remainder section}2. Semaphores 앞서 말한 방법을 추사화한 것으로, 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는다. 소프트웨어상에서 Critical Section 문제를 해결하기 위한 동기화 도구로 공유 자원을 획득하고 반납하는 것을 처리한다. 주로 S라는 정수형 변수로 나타내며, 이는 사용 가능한 자원의 개수를 의미한다. Counting Semaphore 자원의 개수가 여러 개 있다. (여분의 자원을 사용 가능) 도메인이 0 이상인 임의의 정수 값 주로 resource counting에 사용한다. Binary Semaphore 변수가 0 혹은 1인 경우이다. (자원의 개수가 1개인 경우) 0 또는 1 값만 가질 수 있는 Semaphore 주로 mutual exclusion에 사용한다. 세마포어 변수는 오직 두 개의 atomic 한 연산을 통해서 접근할 수 있다. P연산 V연산으로 동기화를 한다.procedure P(S)while S=0 do wait // S가 0이면 대기S := S-1 // S가 1이면 0으로 만들고 진입end P p 연산: 공유 데이터를 획득 하는 과정 같이 들어갈 수 없는 임계영역에 들어가고자 하는 프로세스는 P를 거쳐야 한다. 하나의 프로세스만 P연산 (나머지는 대기) procedure V(S) // 현재상태는 S가 0S := S+1 // S를 1로 해제end V // 이제는 다른 프로세스가 들어 올수 있음 v 연산: 공유 데이터를 반납하는 과정 P연산을 통과해 임계영역의 연산을 끝낸 프로세스가 V연산을 수행하게 된다. 1) Busy-wait// Synchronization variable: sempaphore mutex; ProcessPido { P(mutex); // if positive, dec-&amp;-enter, Othrewise, wait critical section V(mutex); // Increment semaphore remainder section}white(1); Busy Waiting이 발생한다. Busy Waiting: Critical Section 에 진입해야하는 프로세스가 진입 코드를 계속 반복 실행해야 하여 CPU 시간을 낭비하는 것. 그래서 Block &amp; Wake up 방식을 사용한다.2) Block &amp; Wake up Critical Section으로의 진입에 실패한 프로세스를 기다리게 하지 않고 Block 시킨다. Critical Section에 자리가 나면 다시 깨워줌으로써 Busy waiting에서의 CPU 낭비 문제를 해결한다.semaphore를 획득 하지 못하면 block 되고 PCB를 큐에 넣고 semaphore를 기다린다.typedef struct{ int value; // semaphore struct process *L; // process wait queue} 단어 설명 block 커널은 block을 호출한 프로세스를 suspend 시킨다. 이 프로세스의 PCB를 semaphore에 대한 wait queue에 넣는다. wakeup block된 프로세스 P를 wakeup시킨다.이 프로세스의 PCB를 ready queue로 옮긴다. // P(S)S.value++; // prepare to enterif (S.value &lt; 0) // Oops, negative, I cannot enter{ add this process to S.L; block();}// V(S)S.value++; if (S.value &lt;= 0) { remove a prosess P from S.L; wakeup(P);} 3) Busy-wait vs Block/Wakeup Critial Section의 길이가 긴 경우 Block/Wakeup이 적당하다. Critial Section의 길이가 매우 짧은 경우 Block/Wakeup 오버 헤드가Busy-Wait 오버헤드보다 더 커질 수 있다. 일반적으로는 Block/Wakeup방식이 더 좋다.4) 문제점 Deadlock 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상 세마포어가 Ready Queue 를 가지고 있고, 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있어서 Critical Section에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되야만 빠져나올 수 있는 상황을 지칭한다. Starvation 프로세스가 suspend된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상 (Indefinite blocking) 3. 고전적인 문제들공유데이터에서 싱크로나이즈와 관련하여 발생할 수 있는 여러 문제가 있다.1) Bounded-Buffer ProblemProducer (데이터): 데이터를 만들어서 넣는 주체Consumer (데이터): 데이터를 꺼내서 소비하는 주체 공유 버퍼 문제 생산자 여러 명이 한 공간에 접근하여 데이터를 저장하려고 하면 문제가 발생한다. 소비자 여러 명이 한 공간에 접근하여 데이터를 꺼내가려고 하면 문제가 발생한다. 버퍼가 유한성 (Bounded-Buffer) 생산자가 빈 버퍼가 있으면 데이터를 넣을 수 있는데, 빈 버퍼의 수가 없으면 기다려야 한다. =&gt; 자원의 여분이 생길 때 까지! 소비자 입장에서도 자원의 여분이 없으면 내용이 들어있는 버퍼가 있을 때까지 기다려야 한다. 그래서 세마포어는 두 가지 역힐을 해야 한다. 동시 접근을 막기 위해 lock을 거는 것, 가용자원의 개수를 세는 카운팅 Producer Consumer 1. Empty 버퍼가 있는지 체크 1. Full 버퍼가 있는제 체크 2. 공유데이터에 lock을 건다 2. 공유 데이터에 lock을 건다 3. Empty 버퍼에 데이터 입력 및 버퍼 조작 3. Full 버퍼에서 데이터를 꺼내고 버퍼를 조작한다. 4. lock을 푼다 4. lock을 푼다 5. Full buffer가 하나 증가한다. 5. Empty butter가 하나 증가한다. 2) Readers-Writers ProblemReader: DB를 읽는 주체Writer: DB에 데이터를 넣는 주체 한 process가 DB(공유데이터)에 write 중일 떄 다른 process가 접근하면 안된다. 그러나 Read는 동시에 여럿이 해도 된다. Writer가 DB에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기 중인 Reader들을 다 DB에 접근하게 해준다. Writer는 대기 중인 Reader가 하나도 없을 때 DB 접근이 허용된다. 일단 Writer가 DB에 접근 중이면 Reader들은 접근이 금지된다. Writer가 DB에 빠져나가야만 Reader의 접근이 허용된다. DB에 lock을 거는 용도로 db라는 바이너리 세마포어를 사용하여 Reader와 Writer가 공유 DB 자체를 올바르게 접근하도록 한다.또한, readcount(현재 DB에 접근 중이 Reader의 수)에 lock을 거는 용도로mutex라는 바이너리 세마포어를 사용한다.(Writer가 지나치게 기다리는 Starvation 문제가 발생할 수 있다. )3) Dining-Philosophers Problem철학자 5명이 원탁에서 식사를 하고 있다. 철학자의 업무는 다음과 같다. 생각을 한다. 밥을 먹는다.그런데, 철학자마다 생각을 하거나 밥을 먹는 주기가 다르다. 밥을 먹을 때 어느 쪽 젓가락(공유 자원)을 잡아야 하는가.// 세마 포어 활용do { P(chopstick[i]); P(chopstick[(i+1) % 5]); ... eat(); ... V(chopstick[i]); V(chopstick[(i+1) % 5]); ... think() ...}while(1)그러나 위의 방법은 Deadlock의 가능성이 있다. 철학자가 모두 한번에 왼쪽 젓가락만 잡으면 오른쪽 젓가락을 잡지 않는다.해결방안 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다. 젓거락을 두 개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 한다. 비대칭 (짝수 철학자는 왼쪽 젓가락만 집도록, 홀수 철학자는 오른쪽 젓가락만 집도록..)4. Monitor 프로그래밍 언어 차원에서 싱크로나이즈를 해결하는 방법으로, 동시 수행 중인 프로세스 사이에서 abstract data type의 안전한 공유를 보장한다.1) 세마포어의 문제점 코딩하기 어렵다 정확성의 입증이 어렵다. 자발적인 협력이 필요하다. 한번의 실수가 모든 시스템에 치명적 영향을 미친다.2) 특징 모니터 내에서 한 번에 하나의 프로세스만이 활동이 가능하다. 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요가 없다. 기본적으로 모니터에 대한 동시 접근을 막기 때문에 lock을 걸 필요가 없다. 프로세스가 모니터 안에서 기다릴 수 있도록 하기 위해 condition을 사용한다. condition var은 값을 가지지 않고 자신의 큐에 프로세스를 매달아서 sleep시키거나 큐에서 프로세스를 깨우는 역할만 한다. condition variable은wait()와 signal() 연산을 통해서만 접근이 가능하다. x.wait(): x조건을 만족하지 않으면 sleep할 때 호출 (x.signal()을 invoke하기 전까지 일시 중지) x.signal(): x를 다 쓰고 빠져나갈때 sleep중인 프로세스가 있으면 그 중 하나를 깨워준다. (일시중지된 프로세스를 resume) " }, { "title": "운영체제-CPU-스케쥴링", "url": "/posts/operationsystem05/", "categories": "CS, 운영-체제", "tags": "cs, 운영-체제", "date": "2022-09-13 00:00:00 +0900", "snippet": "5장-CPU-스케줄링강의 링크1. CPU Scheduling의 필요성1) CPU burst, I/O burst 프로그램 실행 중 주어진 명령문의 종류에 따라 구분한다. I/O burst: I/O를 실행하고 있는 단계 CPU burst: CPU만 연속적으로 사용하면서 명령어를 실행하는 단계 CPU burst와 I/O burst를 번갈아가면서 프로그램을 실행한다.2) CPU -burst Time 여러 종류의 job(=process)이 섞여 있기 때문에 CPU 스케쥴링이 필요하다. CPU과 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용해야 한다. I/O bound job interactive한 job이 많다. (interative job에게 적절한 response 제공 요망) CPU를 잡고 계산하는 시간 보다 I/O에 많은 시간이 필요한 job이다. I/O 요청이 주를 이루어 CPU를 사용하는 시간은 짧지만 많은 명령을 수행한다.(빈도가 높다) many short CPU bursts (large number of short CPU bursts) CPU bound job 계산위주의 job이다. few very long CPU bursts (small number of long CPU bursts) 2. CPU Scheduler1) 기본 개념 Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다.CPU를 누구에게 줄 지 결정했으면, Dispatcher를 통해 CPU제어권을 CPU Scheduler에 의해 프로세스를 넘긴다. 이 과정을 문맥 교환이라고 한다.CPU 스케줄링이 필요한 경우는 프로세스에게 다음과 같은 상태 변화가 있는 경우이다. Running =&gt; Blocked (예: I/O 요청하는 시스템 콜) nonpreemptive (자발적) Running =&gt; Ready (예: 할당시간 만료로 timer interrupt) preemptive (비자발적) Blocked =&gt; Ready (예: I/O 완료 후 인터럽트) preemptive(비자발적) Terminate nonpreemptive(자발적)2) CPU 성능 척도 성능 척도에 따라 어떤 스케쥴링 알고리즘이 우수한지 판단한다. CPU 성능 척도 설명 CPU 이용률 (CPU Utilization) 쉬지 않고 얼마나 일을 했는가.전체 시간 대비 이용률 처리량 (Throughput) 몇 개의 일을 처리했는가. 주어진 시간에 얼마나 일을 처리했는가. 소요 시간 (Turnaround Time) CPU를 사용하러 와서 CPU burst를 다하고 나가는 시간 대기 시간 (Wating Time) ready 큐에서 줄 서서 기다리는 시간 응답 시간 (Response Time) ready 큐에 들어와서 처음으로 CPU를 얻기까지 걸리는 시간timeSharing환경에서 중요하기에 대기 시간과 별도로 따로 따진다. 3) CPU 알고리즘 비선점형 (Non-Preemptrive) 특정 프로세스의 작업이 끝날 때 까지 CPU를 독점한다. 빼앗을 수 없다. 선점 (Preemitive) 하나의 프로세스가 CPU를 점유할 떄 다른 프로세스가 CPU를 빼앗을 수 있다. timer를 활용 CPU 스케쥴링 분류 설명 FCFS (First-Come First-Served) 비선점형 프로세스의 도착 순서에 따라서 실행한다. (선입선출법)Conboy Effect(호위 효과): short process after long process먼저 도착한 프로세스의 burst시간이 길면 뒤에 있는 프로세스가 매우 오랜 시간을 기다려야 할 수 있다. SJF (Shorest-Job-First) 비 선점형선점형 각 프로세스의 다음번 CPU burst time을 가지고 CPU에 활용한다.CPU burst가 가장 짧은 프로세스를 먼저 스케쥴한다. 주어진 프로세스들에 대해 minimum average waiting time을 보장한다. - 비 선점형 : 일단 CPU를 잡으면 CPU burst가 완료될 때까지 CPU를 선점 당하지 않는다. - 선점형:현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 빼앗긴다. (shortest Remaining TIme First)Starvation 현상: long process는 평생 CPU를 사용하지 못할 수도 있다… 🙃다음 CPU burst 예측: CPU burst타임을 미리 알수는 없지만 추정한다. (과거의 기록을 활용) Priority   높은 우선순위를 가진 Process에 할당한다. SJF는 일종의 priority 스케쥴링이다. (predicted net CPU burstTime)Starvation 현상: 우선 순위가 낮은 프로세스는 평생 CPU를 사용하지 못할 수도 있다… 🙃Aging: 기아 현상을 해결하기 위한 방법으로 대기 시간이 길어지면 우선순위를 높여준다. Round Robin(RR) 선점형 현대에서 사용하는 CPU 스케쥴링의 기반각 프로세스는 동일한 크기의 할당 시간을 가진다. 할당 시간이 지나면 프로세스는 선점당하고 레디큐의 제일 뒤에가서 다시 줄을 슨다.예측할 필요가 없고 응답시간이 빠르다는 장점이 있다. 대기시간이 cpu를 사용하는 시간에 비례하여 증가한다. 할당시간이 너무 크게 설정하면 성능이 FCFS와 같아진다. 할당시간이 너무 적으면 문맥 교환 오버헤드가 커진다. 4) Real-Time Scheduling Hard real-time systems Hard real-time task는 정해진 시간 안에 반드시 끝내도록 스케쥴링 해야 한다. 데드라인을 꼭 지켜야 한다. Soft real-time computing Soft real-time task는 일반 프로레스에 비해 높은 우선순위를 갖도록 해야 한다. 5) Thread Scheduling Local Scheduling User level thread의 경우 사용자 수준의 thread library에 의해 어떤 thread를 스케쥴할지 결정한다. OS가 아니라 사용자 프로세스가 직접 결정한다. Global Sheduling Kernel level thread의 경우 일반 프로세스와 마찬 가지로 커널의 단기 스케쥴러가 어떤 thread를 스케쥴을 할지 결정한다. 프로세스 스케쥴링 하듯이 OS가 알고리즘에 근거해서 스케쥴링을 한다. 6) Algorithm 평가 Queueing models 이론가들이 사용하는 방법 확률 분포로 주어지는 arrival rate와 service rate 등을 통해 각종 perfomance index를 계산한다. Implemetation(구현), Measurement(성능 측정) 실제 시스템에 알고리즘을 구현하여 실제 작업(workload)에 대해서 성능을 측정하고 비교한다. Simulation (모의 실험) 알고리즘을 모의 프로그램으로 작성 후 trace를 입력으로 하여 결과를 비교한다. 3. Ready Queue1) Multilevel Queue Ready Queue를 여러개로 분할되어 있다.프로세스의 우선 순위에 따라 큐가 정해진다. 큐에 대한 스케쥴링이 필요하다. 각 큐에 CPU time을 적절한 비율로 할당한다. foreground queue interactive RR 스케쥴링 알고리즘을 사용한다. background queue batch - no human interaction FCFS 스케쥴링 알고리즘을 사용한다. 2) Multilevel Feedback Queue Multilevel Queue와 마찬가지로 프로세스 우선 순위에 따라 큐가 정해진다. 프로세스가 다른 큐로 이동이 가능하다. 에이징을 이와 같은 방식으로 구현할 수 있다. Multilevel-feedback-queue scheduler를 정의하는 파라미터들 Queue의 수 각 큐의 scheduling algorithm Process를 상위 큐로 보내는 기준 Process를 하위 큐로 내쫓는 기준 프로세스가 CPU 서비스를 받으려 할 떄 들어갈 큐를 결정하는 기준 4. Multiple-Processor Scheduling CPU가 여러 개인 경우 스케쥴링은 더욱 복잡해진다. Homogeneous Process인 경우 Queue에 한 줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있다. 반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더 복잡해진다. Load Sharing 일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘이 필요하다. 별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법 Symmetric Multiprocessing (SMP) 모든 CPU가 대등하다. 각 프로세서가 각자 알아서 스케쥴링을 결정한다. Asymmetric Multiprocessing 하나의 CPU가 전체적인 컨트롤을 담당한다. 하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따른다. " }, { "title": "09-Redux를-활용한-비동기-요청", "url": "/posts/react09/", "categories": "WEB, React", "tags": "React", "date": "2022-09-11 00:00:00 +0900", "snippet": "강의 링크리듀서 함수는 다음과 같은 특징이 있다. 순수 함수이다 부수 효과가 없다. 동기식이여야 한다.즉, 인풋을 받아 아웃풋을 생성해내는 순수하고 부수 효과가 없는 동기식 함수이다. (예측 가능해야 하기 때문에 Redux는 동기식으로 처리한다. )그런데 리덕스로 작업할 때 HTTP 요청과 같이 부수 효과가 수반되는 일부 작업을 전달할 때 어떻게 해야 할까.1. Redux를 활용하여 HTTP 요청 처리하기우선 리듀서는 순수 함수여야 하고, 부수 효과도 없고 동기식이어야 한다는 점을 유념해야 한다.따라서 부수 효과를 생성하거나 http 요청을 보내는 것과 같이 비동기식인 코드는 리듀서 함수에 들어가서는 안 된다.import { useEffect } from 'react';import { useSelector } from 'react-redux';import Cart from './components/Cart/Cart';import Layout from './components/Layout/Layout';import Products from './components/Shop/Products';function App() { const showCart = useSelector((state) =&gt; state.ui.cartIsVisible); const cart = useSelector((state) =&gt; state.cart); useEffect(() =&gt; { fetch('https://react-http-6b4a6.firebaseio.com/cart.json', { method: 'PUT', body: JSON.stringify(cart), }); }, [cart]); return ( &lt;Layout&gt; {showCart &amp;&amp; &lt;Cart /&gt;} &lt;Products /&gt; &lt;/Layout&gt; );}export default App; redux 스토어를 업데이트 할 때 마다, http 요청을 보냄으로 redux와 서버에 있는 데이터를 맞춘다.1) useEffect를 활용하여 데이터 보내기// src/App.jsimport { useEffect } from 'react';import { useSelector, useDispatch } from 'react-redux';let isInitial = true;function App() { const dispatch = useDispatch(); const reduxState = useSelector((state) =&gt; state.reduxState); useEffect(() =&gt; { dispatch(action 객체 생성) // 비동기 작업 수행 const sendHttp = async () =&gt; { //.. 생략 // 처음 렌더링 될때 요청을 보내고 싶지 않기 때문에, 바로 return 한다. if (isInitial) { isInitial = false; return; } // 만약 내부에서 dispath함수를 사용하면, dispatch 함수는 이제 종속 항목이다.(useDispatch에 의해 생성된) // Redux는 이것은 절대 변경되지 않는 함수임을 보장하기 때문에 이것을 의존성 배열에 안전하게 추가할 수 있다. }, [reduxState, dispatch]); return ( //.. 생략 );}export default App; useEffect를 활용하여 Redux의 State가 변경되면 비동기 작업을 수행한다. 데이터를 추가, 수정, 삭제 =&gt; Redux에 반영 Redux가 변경되면 서버와 통신 2) action을 활용하여 데이터 보내기 redux state가 변경될 때, 비동기 함수를 dispatch한다.// src/store/state-actions.jsimport { createSlice } from '@reduxjs/toolkit';import { uiActions } from './ui-slice';const stateSlice = createSlice({ name: 'reduxState', //.. 생략});// action creatorexport const sendData = (slice) =&gt; { // 리덕스 툴킷을 통해 자동으로 action을 dispatch한다. // action 객체를 생성하는 것이 아닌 함수를 dispatch할 수 있다. // 함수를 dispatch하면 함수를 자동으로 실행하고 자동으로 dispatch를 인수로 제공한다. // 실행된 함수에서 우리는 다시 디스패치 할 수 있다. return async (dispatch) =&gt; { dispatch(action 객체 생성) // 비동기 작업 수행 const sendHttp = async () =&gt; { //.. 생략 }};export const stateActions = stateSlice.actions;export default cartSlice;// src/App.jsimport { useEffect } from 'react';import { useSelector, useDispatch } from 'react-redux';import { sendData } from './store/cart-slice';let isInitial = true;function App() { const dispatch = useDispatch(); const reduxState = useSelector((state) =&gt; state.reduxState); useEffect(() =&gt; { const sendHttp = async () =&gt; { if (isInitial) { isInitial = false; return; }\tdispatch(sendData(reduxState)) }, [reduxState, dispatch]); return ( //.. 생략 );}export default App; 비동기 작업을 컴포넌트가 아닌 Redux Action을 dispatch하는 함수에서 관리한다. (컴포넌트의 코드가 훨씬 가벼워진다.) useEffect()를 활용하여, Redux의 state가 변경되면 dispatch를 한다. dispatch 하는 함수에 비동기 작업을 하는 함수를 실행한다.3) 데이터 fetch 하기// src/store/state-actions.jsexport const fetchData = () =&gt; { return async (dispatch) =&gt; { const fetchData = async () =&gt; { const response = await fetch( 'https://react-http-6b4a6.firebaseio.com/cart.json' );\t //.. 생략 const data = await response.json(); return data; }; try { const newData = await fetchData(); // 새로 받은 데이터를 Redux에 payload로 전달하고 데이터를 변경한다. dispatch(Redux에 있는 stateData를 newData로 교체) ); } catch (error) { //.. 생략 ); } };}; 데이터를 fetch해서 Redux에 반영한다. 이는 데이터의 값을 변경하는 Actions를 dispatch하여 진행한다. dispatch할 때, fetch한 데이터를 전달하여 값을 변경한다. // src/App.jsimport { useEffect } from 'react';import { useSelector, useDispatch } from 'react-redux';import { sendData } from './store/cart-slice';let isInitial = true;function App() { const dispatch = useDispatch(); const reduxState = useSelector((state) =&gt; state.reduxState); // 처음 컴포넌트가 생성될 때, 데이터를 fetch 한다. useEffect(() =&gt; { dispatch(fetchData()); }, [dispatch]); return ( //.. 생략 );}export default App;2. RTK 활용하기공식 문서1) RTKimport axios from \"axios\";import {createAsyncThunk, createSlice} from \"@reduxjs/toolkit\"import { useDispatch, useSelector } from 'react-redux';// 비동기 action creator이다. export const fetchNumber = createAsyncThunk( \"counter/fetchNumber\", async {payload, thunkAPI} =&gt; { const data = await axios(\"api 링크\"); return data.number })const initialCounterState = { counter: 0, showCounter: true, loading: null, error: null };const counterSlice = createSlice({ name: 'counter', initialState: initialCounterState, // sync reducers: { increase(state, action) { state.counter = state.counter + action.payload; }, toggleCounter(state) { state.showCounter = !state.showCounter; }, }, // async extraRedcers: { [fetchNumber.pending]: (state, action ) =&gt; { state.loading = true; }, [fetchNumber.fulfilled]: (state, action) =&gt; { state.loading = false; state.counter = action.payload; }, [fetchNumber.rejected]: (state, action) =&gt; { state.loading = false; state.error = true; } }});// custom 훅 생성하여 componenet에서 사용// const {loading, error, counter} = useFecthNumber(); export const useFecthNumber = () =&gt; { const {loading, error, counter} = useSelector(selectCounter); const dispatch = useDispatch(); useEffect(()=&gt; { dispatch(fetchNumber()) // async action thunk }) return {loading, error, counter}}// 성능 관리 (캐시: 메모이제이션 활용)// 상태가 변하지 않으면 캐시된 데이터를 반환한다.export const selectCounter = createSelector( // 입력 셀렉터 (state) =&gt; state.counter, // 출력 셀렉터 (counter) =&gt; counter) 메서드 설명 createAsyncThunk() 비동기 처리할 때 사용한다. 액션 타입 문자 값과 Promise를 반환하는 함수이다.pending, fulfilled, rejected action 타입을 dispatch하는 Thunk를 생성한다. createSelector(입력 셀렉터, 출력 셀렉터) useSelector()를 사용하면, 특정 state를 가져올 수 있다. useSelector를 사용하기 전, 상태에 처리작업을 하고 이를 메모이제이션 하는 함수이다.컴포넌트가 상태를 처리하여, 컴포넌트가 리렌더링되는 것을 막는다.입력 셀렉터는 모든 인자와 하께 호출된다. 입력 셀렉터 반환 값이 변경될 경우, 출력 셀렉터가 다시 실행된다. 출력 셀렉터의 반환 값은 캐시된다. ✅ Tip: LocalStorage 사용하기// src/utils/LocalStorag.jsconst STORE_KEY = 'redux/store';export const loadState = (key = STORE_KEY) =&gt; { const storeData = localStorage.getItem(key); return storeData ? JSON.parse(storeData) : undefined;};export const saveState = (storeState, key = STORE_KEY) =&gt; { const serializedState = JSON.stringify(storeState); localStorage.setItem(key, serializedState);};export const removeState = (key = STORE_KEY) =&gt; { localStorage.removeItem(key);};// src/store.index.jsimport { configureStore } from '@reduxjs/toolkit';import { loadState, saveState } from 'utils';import counterReducer from './counter';import authReducer from './auth';const store = configureStore({ reducer: { counter: counterReducer, auth: authReducer }, // 로컬스토리지에 데이터가 있으면 우선 기본 값으로 가져온다. preloaded: loadState() ?? {},});// 구독을 통해 store가 변경되면 saveState를 실행한다. export const subscription = () =&gt; { return store.subscribe(throttle(() =&gt; saveState(store.getState()), 1000));};export const unsubscription = subscription();export default store;2) RTK 쿼리 데이터를 로딩하는 흔한 케이스를 간단하게 하는 도구이다.공식 문서어떤 컴포넌트든 같은 쿼리를 구독하면 항상 같은 데이터를 사용할 수 있도록 보장한다. 중복 요청을 자동 제거 하기 때문에 성능에도 좋다.import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';export const contactsApi = createApi({ reducerPath: 'contactsApi', baseQuery: fetchBaseQuery({ baseUrl: \"베이스 URL\", }), tagTypes: ['Contact'], endpoints: (builder) =&gt; ({ // QUERY contacts: builder.query({ query: () =&gt; '/contacts', providesTags: ['Contact'], }), // MUTATION addContact: builder.mutation({ query: (newContact) =&gt; ({ url: '/contacts', method: 'POST', body: newContact, }), invalidatesTags: ['Contact'], }), updateContact: builder.mutation({ query: ({ id, ...willUpdateContact }) =&gt; ({ url: `/contacts/${id}`, method: 'PUT', body: willUpdateContact, }), invalidatesTags: ['Contact'], }), deleteContact: builder.mutation({ query: (id) =&gt; ({ url: `/contacts/${id}`, method: 'DELETE', }), invalidatesTags: ['Contact'], }), }),});export const { useContactsQuery, useAddContactMutation, useUpdateContactMutation, useDeleteContactMutation,} = contactsApi; 메서드 설명 createApi() 데이터를 패치하고 변환하는 설정을 포함해서 엔드포인트들에서 어떻게 데이터를 패치하는지 정의한다. api를 생성하는 function이다. Query (Read), Mutation(Create, Update, Delete) 을 반환한다. fetchBaseQuery() baseUrl을 등록할 수 있다. setupListeners() refetchOnMount와 refetchOnReconnect기능을 위해 사용되는 유틸리티이다. " }, { "title": "08-Redux와-RTK", "url": "/posts/react08/", "categories": "WEB, React", "tags": "React", "date": "2022-09-11 00:00:00 +0900", "snippet": "강의 링크1. Redux란1) 정의 React의 상태 관리 시스템이다.React의 상태는 세 가지 이다. 로컬 상태: 하나의 컴포넌트와 연결된 State useState를 사용하여 컴포넌트 안에서 로컬 상태를 관리한다. 크로스 컴포넌트 상태: 다수의 컴포넌트에 영향을 미치는 State props체인을 구축하여 컴포넌트 간 State를 통신한다. 앱 와이드 상태: 애플리케이션의 모든 컴포넌트에 영향을 미치는 State리액트 Context를 통해 크로스 컴포넌트 상태나 앱 와이드 상태를 쉽게 관리하도록 한다. 리덕스도 마찬가지이다.모든 상태 변경은 Store에서 관리하며 Store의 상태를 변경하는 유일한 방법을 Action객체를 전달하는 방법 뿐이다. 그러므로 예측 불가능한 상태 변경이 발생하는 것을 막을 수 있다.Action은 엄격한 순서에 의해 동기적으로 실행되므로 관리가 용이하다. 또한, Action객체는 자바스크립트의 객체이므로 기로깅 가능하고 시리얼라이즈 할 수 있다는 특징이 있다.2) 필요성리액트 Context에는 잠재적인 단점이 있다. 대형 프로젝트의 경우 상태관리가 매우 복잡하다. 다음과 같은 코드가 나올 수도 있다.// 다양하고 많은 ContextProvider가 구축된다. return ( &lt;AuthContextProvider&gt; &lt;ThemeContextProvider&gt; &lt;MultiStepFormContextProvider&gt; &lt;MYserRegistration /&gt; &lt;/MultiStepFormContextProvider&gt; &lt;/ThemeContextProvider&gt; &lt;/AuthContextProvider&gt;) 하나의 컨텍스트만 사용한다 하더라도, ContextProvider컴포넌트 하나가 다양하고 많은 것을 관리해야 하기 때문에 그 자체를 유지하기가 어려울 수 있다. 데이터가 자주 변경되는 경우, 성능이 좋지 않다. 반면에 리덕스는 유동적인 상태 관리 라이브러리이다.3) 작동 방식 리덕스는 하나의 중앙 데이터(상태) 저장소 이다.한 저장소에 전체 애플리케이션의 모든 상태를 저장한다. 그럼에도 관리가 쉬운 이유는 저장소 전체를 항상 직접 관리할 필요가 없기 때문이다. 컴포넌트가 저장소를 구독하고 데이터가 변경될 때마다 Store가 컴포넌트에 알려준다. 그러면 컴포넌트는 필요한 데이터를 받게 된다. 여기서 중요한 규칙이 있다. 절대로 저장된 데이터를 직접 조작하지 않는다. 데이터는 절대로 반대 방향으로 흐르지 않는다. 리듀서 함수가 저장소 데이터의 업데이트를 담당한다. 리듀서가 해야하는 작업을 액션이라고 부르며, 컴포넌트가 특정 액션객체를 dispatch한다. action을 전달받은 reducer는 상태를 수정하여 Store를 업데이트 한다.즉, 직접 업데이트 하지 않고, 액션에는 수행해야 할 작업이 설명되어 있고 이 액션들을 리듀서로 전달해서 리듀서가 수행한다.그 후, 리듀서는 새로운 상태를 도출하고 이것이 중앙 데이터 저장소의 기존 상태를 대체하게 된다. 데이터 저장소의 상태가 업데이트 되면 구독중인 컴포넌트가 알림을 받게 되어 컴포넌트를 업데이트하게 되는 것이다.2. Redux 기초1) Redux 메서드$ npm install redux react-reduxinterface Store { getState(): State; dispatch(action: Action): Dispatch; subscribe(listener: Listener): Unsubscribe; replaceReducer(nextReducer: Reducer): void;}// redux의 주요 메서드를 직접 구현해보기 const createStore = (reducer, preloadedState, enhancer) =&gt; { if (!reducer || typeof reducer !== \"function\") throw new Error(\"...\") // 외부에서 접근이 불가능한 상태 let state = preloadedState ?? {}; const listeners = []; const getState = () =&gt; state; // reducer를 통해서만 state를 업데이트 한다. const dispatch = (action) =&gt; { if(!(\"type\" in action)) throw new Error (\"...\"); state = reducer(getState(), action); listeners.forEach(listener =&gt; listener()); } const subscribe = (listener) =&gt; { listeners.push(listener); return { function unscribe() { listeners.filter((l) =&gt; !Object.is(l, listener)); } } } // store 객체를 반환한다. return { getState, dispatch subscribe }}; 메서드 설명 const store = redux.createStore(reducer, [초기 상태]) store와 reducer를 연결하여 store를 생성한다.store객체를 반환한다.store는 앱의 전체 상태를 가지고 있는 객체이다. 이 객체의 상태를 바꾸는 유일한 방법은 action을 보내는 것이다. UI를 업데이트 하기위해 상태를 구독할 수도 있다. store.getState() 현재 State를 가져온다. store.subscribe(listener) 변경사항에 대한 리스터를 추가한다. 구독을 취소하는 함수를 반환한다. 리스너는 State가 변경될 때 호출된다. 콜백 안에서 현재 상태 트리를 읽으려면 getState()를 호출하면 된다. store.dispatch(action) 리듀서에 action을 보낸다. 2) 시작 하기const redux = require(\"redux\");// 새로운 상태 스냅샷을 도출하는 리듀서 함수// 인자로 oldState와 DispatchedAction을 받는다.// 최초 실행시, state의 값이 있게 하기 위해 기본값이 필요하다. // 새로운 State 객체를 return 한다. const counterReducer = (state = {counter: 0}, action) =&gt; { if (action.type === \"increment\") { return { counter: state.counter + 1, }; } if (action.type === \"decrement\") { return { counter: state.counter - 1, } } return state}; // 저장소를 생성하는 메서드// 어떤 reducer가 해당 저장소의 데이터를 조작하는 지 기입한다. const store = redux.createStore(counterReducer);// getState()는 createState()로 생성된 저장소에서 사용할 수 있는 메서드 이다. // 업데이트 후에 최신 스냅샷을 제공한다. const counterSubscriber = () =&gt; { const latestState = store.getState(); console.log(latestState)}// Redux가 구독 함수를 인식하고 상태가 변경할 떄 마다 해당 함수를 실행하라고 알려준다. // subscribe(listener) =&gt; unsubscribestore.subscribe(counterSubscriber);// action을 발송한다. store.dispatch({type: \"increment\"})sotre.dispatch({type: \"decrement\"}) 리듀서 함수는 순수 함수여야 한다. 순수 함수: 동일한 인자가 주어졌을 때 항상 동일한 결과를 반환하고 외부의 상태를 변경하지 않는다. 즉, 순수 함수는 함수 내 변수 외에 외부 값을 참조, 의존하거나 변경하지 않아야 한다. Redux의 State는 불변해야 한다. 즉 State가 수정되서는 안되기 때문에 순수 함수여야 하는 것이다. 인자로 들어온 State를 수정하지 않고, State를 새로 할당하는 이유이다. 이전의 State와 다른 주소 값을 가지고 있기 때문에 State가 변경되었다고 판단하는 것이다. // 순수 함수function double(z) { return z*z}// 순수 함수const squareAll = (items) =&gt; items.map(square);// 비순수 함수function double(z) { fetchUpdate(z) // side effect: 부수 효과 return z * z}3) 예시✅ Store 생성한다.// src/store/index.jsimport { createStore } from 'redux';const counterReducer = (state = { counter: 0 }, action) =&gt; { if (action.type === 'increment') { return { counter: state.counter + 1, }; } if (action.type === 'decrement') { return { counter: state.counter - 1, }; } return state;};const store = createStore(counterReducer);// store를 내보낸다. export default store; reducer(prevState, actionObject){}: 이전 State와 action객체를 인자로 받는다. action을 식별하기 위해 type 속성을 사용한다.✅ Store 앱과 연결한다.// src/index.jsimport React from 'react';import ReactDOM from 'react-dom/client';import { Provider } from 'react-redux';import './index.css';import App from './App';import store from './store/index';const root = ReactDOM.createRoot(document.getElementById('root'));root.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;); 래핑된 컴포넌트만이 리덕스에 접근할 수 있다. 래핑된 컴포넌트의 자식. 자손 컴포넌트도 접근이 가능하다. ✅ 컴포넌트에서 Store에 있는 State를 구독한다.// src/components/counter.jsimport { useSelector } from 'react-redux';// 구독const Counter = () =&gt; { const counter = useSelector(state =&gt; state.counter); return ( &lt;main&gt; &lt;div&gt;{counter}&lt;/div&gt; &lt;/main&gt; );};export default Counter; useStore: 스토어에 바로 접근한다. useSelector: 자동으로 스토어가 관리하는 상태를 일부 선택하게 한다. 전체 상태 객체에서 일부만 받을 수 있다. 컴포넌트가 스토어의 특정 State에 구독 =&gt; 스토어가 업데이트 되면 자동으로 컴포넌트도 업데이트 된다.✅ Store에 있는 State를 업데이트 하기 위해 action을 dispatch 한다.// src/components/counter.jsimport { useSelector, useDispatch } from 'react-redux';const Counter = () =&gt; { const dispatch = useDispatch(); const counter = useSelector(state =&gt; state.counter); const incrementHandler = () =&gt; { dispatch({ type: 'increment' }); }; const decrementHandler = () =&gt; { dispatch({ type: 'decrement' }); }; return ( &lt;main&gt; &lt;div&gt;{counter}&lt;/div&gt; &lt;div&gt; &lt;button onClick={incrementHandler}&gt;Increment&lt;/button&gt; &lt;button onClick={decrementHandler}&gt;Decrement&lt;/button&gt; &lt;/div&gt; &lt;/main&gt; );};export default Counter; useDispatch: 실행할 수 있는 dispatch function을 반환한다. dispatch함수를 통해 action객체를 리듀서에 전달한다.4) action에 페이로드 연결하기// src/store/index.jsimport { createStore } from 'redux';const initialState = { counter: 0, showCounter: true };const counterReducer = (state = initialState, action) =&gt; { // payload를 사용하여 코드의 중복을 막는다. if (action.type === 'increase') { // 새로운 state객체를 반환한다. return { counter: state.counter + action.amount, showCounter: state.showCounter }; } if (action.type === 'toggle') { return { showCounter: !state.showCounter, counter: state.counter }; } return state;};const store = createStore(counterReducer);export default store; 중요한 것은 기존 state와 병합되지 않고 기존 state를 덮어쓴다는 것이다. 원본의 state를 절대 변경해서는 안된다. 새로운 state객체를 반환하여 재정의해야 한다. 절대 기존의 객체 속성이 변경되게 해서는 안된다.// src/components/counter.jsimport { useSelector, useDispatch } from 'react-redux';const Counter = () =&gt; { const dispatch = useDispatch(); const counter = useSelector((state) =&gt; state.counter); const show = useSelector((state) =&gt; state.showCounter); // payload를 전달한다. const increaseHandler = () =&gt; { dispatch({ type: 'increase', amount: 10 }); }; const toggleCounterHandler = () =&gt; { dispatch({ type: 'toggle' }); }; return ( &lt;main&gt; {show &amp;&amp; &lt;div&gt;{counter}&lt;/div&gt;} &lt;div&gt; &lt;button onClick={increaseHandler}&gt;Increment&lt;/button&gt; &lt;/div&gt; &lt;button onClick={toggleCounterHandler}&gt;Toggle Counter&lt;/button&gt; &lt;/main&gt; );};export default Counter; payload를 전달하여 리듀서 함수를 좀 더 간편하게 사용할 수 있다.3. Redux Toolkit 리덕스를 더 쉽고 편리하게 사용할 수 있게 하는 추가 패키지이다.공식 문서1) 필요성 프로젝트 규모가 더 커지면 리덕스에서 관리해야 하는 상태가 많아져 복잡해진다. action 타입이 너무 다양져서 관리가 어렵다. 상태 객체가 너무 커진다. (ActionType, ActionCreator, Reducer 등.. ) 리덕스는 항상 새로운 상태를 반환해야 하는데 상태에 중첩된 데이터가 많아 복잡할 경우 관리가 어렵다.2) 메서드// 1. createActionfunction createAction(type, prepareFn) { const action = { type }; const actionCreator = (payload) =&gt; { if (payload) action.payload = payload; const preapreAction = prepareFn?.(payload) ?? {}; return { ...action, ...preapreAction }; }; actionCreator.type = type; actionCreator.toString = () =&gt; type; return actionCreator;}export default createAction;// 예시: no RTK const INCREASE_NUMBER = \"counter/increase\";const increaseNumber = () =&gt; ({ type: INCREASE_NUMBER, payload})// 예시: RTK// createAction을 사용하면 type, action 정의를 간편히 할 수 있다. const increaseNumber = createAction(\"counter/increase\");//2. createReducerfunction createReducer(initialState, reducers) { const combinedReducer = (state = initialState, action) =&gt; { const reducersPathValue = Object.entries(reducers); let index = reducersPathValue.findIndex( ([reducerPath]) =&gt; reducerPath === action.type ); if (index &gt; -1) { const reducer = reducersPathValue[index][1]; return reducer(state[action.type], action); } else { return state; } }; return combinedReducer;}export default createReducer;// 예시const counterReducer = createReducer( // 초기 값 {counter: 0}, // reducer 함수 객체 { [increase.type]: (state, action)=&gt; { state.counter = state.counter + action.payload; } })//3. createSliceimport createAction from './createAction';import createReducer from './createReducer';function createSlice({ name, initialState, reducers }) { const slice = { actions: Object.keys(reducers).reduce( (actions, reducerPath) =&gt; (actions[reducerPath] = createAction(reducerPath)), {} ), reducer: createReducer({ [name]: initialState }, reducers), }; return slice;}export default createSlice; 메서드 설명 createActions() action type, action creator를 간편하게 생성한다. createReducer() initialState, reducer를 간편하게 생성한다. immer라이브러리를 사용해서 mutation이 가능하다. createSlice() action type, action creator, initialState, reducer를 간편하게 생성한다. immer라이브러리를 사용해서 mutation이 가능하다. actions와 reducer가 있는 객체를 반환한다. 3) 시작하기$ npm install @reduxjs/toolkit# 리덕스 툴킷에 이미 리덕스가 설치되어 있다. $ npm uninstall redux// src/store/index.jsimport { createSlice, configureStore } from '@reduxjs/toolkit';const initialCounterState = { counter: 0, showCounter: true };// slice는 식별하기 위한 이름과 초기 상태, 리듀서가 필요하다.const counterSlice = createSlice({ name: 'counter', initialState: initialCounterState, reducers: { increase(state, action) { // 여전히 기존 상태를 변경할 수 없다. // redux는 immer라는 패키지를 사용하는데, 이런 코드를 감지하고 자동으로 원래 상태를 복제하여 새로운 상태 객체를 생성하여 오버라이드한다. state.counter = state.counter + action.payload; }, toggleCounter(state) { state.showCounter = !state.showCounter; }, },});// reducer를 store와 연결한다. // key로 reducer를 매핑한다.const store = configureStore({ reducer: {counter: counterSlice.reducer}});// 액션을 export (오타 방지)// dispatch(actionCreator(payload))를 위해 export!export const counterActions = counterSlice.actions;export default store; createSlice({name: 이름, initialState: 초기값, reducer:{리듀서}}) Reducer를 조각낸다. initialState, reducer, action type, action creators를 한 번에 관리할 수 있도록 도와주는 함수이다. Reducer에 정의된 여기 이 메서드를 호출하면, Action 객체가 생성된다. 여러 개의 Reducer를 생성하여 기능 별로 관리하고 이를 Store와 연결한다. 이외에도 createAction, createReducer함수가 있지만 createSlice로 통합해서 관리하는 것이 편하다.// src/components/counter.jsimport { useSelector, useDispatch } from 'react-redux';import { counterActions } from '../store/index';const Counter = () =&gt; { const dispatch = useDispatch(); const counter = useSelector((state) =&gt; state.counter.counter); const show = useSelector((state) =&gt; state.counter.showCounter); const increaseHandler = () =&gt; { // increase()는 액션 객체를 자동으로 생성한다. // payload가 필요할 경우 인자로 넣으면 이를 참고하여 자동으로 액션 객체를 생성한다. dispatch(counterActions.increase(10)); // { type: SOME_UNIQUE_IDENTIFIER, payload: 10 } }; const toggleCounterHandler = () =&gt; { dispatch(counterActions.toggleCounter()); }; return ( &lt;main&gt; {show &amp;&amp; &lt;div&gt;{counter}&lt;/div&gt;} &lt;div&gt; &lt;button onClick={increaseHandler}&gt;Increment&lt;/button&gt; &lt;/div&gt; &lt;button onClick={toggleCounterHandler}&gt;Toggle Counter&lt;/button&gt; &lt;/main&gt; );};export default Counter;2) 기능별로 파일 분할 기능에 따라 Slice를 분할하고 파일도 나눌 수 있다. 이렇게 할 경우, index.js에서 이들을 합쳐서 Store와 연결한다.vuex와 마찬가지로 Redux도 기능에 따라 파일을 나눠서 관리하는 것이 편리하다. 파일마다 각자 집중하고 있는 것이 다르기때문에, 한 눈에 코드를 파악하기도 쉽다.// src/store.index.jsimport { configureStore } from '@reduxjs/toolkit';import counterReducer from './counter';import authReducer from './auth';const store = configureStore({ reducer: { counter: counterReducer, auth: authReducer },});export default store;//===============================================================// configureStoreimport { combineReducers, createStore } from 'redux';import { devToolsEnhancer } from '@redux-devtools/extension';function configureStore({ reducer, preloadedState, devTools }) { let rootReducer; if (typeof reducer === 'function') { rootReducer = reducer; } if (reducer &amp;&amp; !Array.isArray(reducer) &amp;&amp; typeof reducer) { rootReducer = combineReducers(reducer); } const enhancer = devTools ? devToolsEnhancer() : undefined; return createStore(rootReducer, preloadedState, enhancer);}export default configureStore; index.js에서는 메인 스토어를 만드는데 집중한다. createStore, combineReducers가 없이 Reducer를 결합하고 Store를 생성할 수 있다. Redux 미들웨어 추가도 손쉬워졌다." }, { "title": "06-React.memo를-사용하여-성능-최적화-하기", "url": "/posts/react06/", "categories": "WEB, React", "tags": "React", "date": "2022-09-10 00:00:00 +0900", "snippet": "강의 링크리액트는 사용자 인터페이스 구축을 위한 자바스크립트 라이브러리이다.리액트는 컴포넌트를 효과적으로 구성하여 인터페이스를 구축한다.업데이트 역시 컴포넌트를 통해 한다. react: 컴포넌트에 신경을 쓴다. props, 상태 또는 컨텍스트가 변경이 되면 이런 것들을 사용하는 컴포넌트 역시 리액트를 통해 변경된다. 재평가 화면에 새로운 것을 표시하는지에 대해 확인합니다 이렇게 화면에 뭔가를 그리려 한다면 리액트는 리액트 DOM에 이를 알린다. react-dom: 새로운 화면과 새로운 컴포넌트가 화면에 보이도록 한다. 리액트가 컴포넌트 트리를 통해 구성한 가상 DOM과 실제 DOM이 일치하도록 조작한다. 리액트가 구성한 컴포넌트의 이전 상태와 트리, 그리고 현재의 상태간의 차이점을 기반으로 변경이 필요할 때만 업데이트 된다. 이전과 현재의 상태를 가상으로 비교한다. (메모리 내부) 1. React.memo()부모컨포넌트가 변경되어 재평가가 되어 함수를 재실행하면, 자식 컴포넌트 함수도 재실행한다.즉, 컴포넌트 함수가 재실행 되면 연결된 컴포넌트 함수들도 가상 비교하면 재실행 한다. 이능 성능 이슈를 유발할 수 있다.프로젝트가 커질 수록 최적화를 해야 하는데 이는 react.memo()로 해결할 수 있다.1) 기본 개념import React from 'react';import MyParagraph from './MyParagraph';const DemoOutput = (props) =&gt; { console.log('DemoOutput RUNNING'); return &lt;MyParagraph&gt;{props.show ? 'This is new!' : ''}&lt;/MyParagraph&gt;;};export default React.memo(DemoOutput); 함수형 컴포넌트에서 작동한다. React.memo(컴포넌트): 인자로 컴포넌트를 넣을 수 있다. 인자로 들어간 컴포넌트에 어떤 props가 입력되는지 확인한다. 해당 props의 값이 바뀐 경우에만 컴포넌트를 재 실행 및 재 평가하게 된다. 즉, 부모 컴포넌트가 변경되어도 해당 컴포넌트의 prosp값이 바뀌지 않으면 컴포넌트 실행은 건너 뛴다. React.memo는 props와 prevProps를 ===로 비교하여 동일한지 확인한다. 그래서 객체, 함수, 배열은 props가 변하지 않아도 같지 않다고 평가하는 이슈가 있다. 이는 자바스크립트 문법 상, 원시 타입이 아닌 참조 타입 데이터에 대해 한정하는 문제이다. 참조타입은 주소를 참조하고 있기 때문에, 같은 주소를 참조하지 않고 있으면 동일하다고 보지 않는다. 참조 동일성 2) 고려 사항그렇다면, 왜 이걸 모든 컴포넌트에 적용하지 않는걸까?최적화에는 비용이 따르기 때문이다. 리액트는 기존의 props를 저장할 공간도 필요하고 비교하는 작업이 필요하다.React.memo()는 컴포넌트를 재평가 하는데 필요한 성능 비용과 props를 비교하는 성능 비용을 서로 맞바꾸는 것이다.props의 개수와 컴포넌트의 복잡도 그리고 자식 컴포넌트의 숫자에 따라서 효율이 다르기 때문에 React.memo()를 사용하는 것이 무조건 성능이 좋다고 할 수는 없다.물론, 자식 컴포넌트가 많아서 컴포넌트 트리가 매우 크다면 React.memo는 매우 유용할 수 있다.이와는 반대로 부모 컴포넌트를 매 번 재 평가할 때마다 컴포넌트의 변화가 있거나 props의 값이 변화하는 경우라면 React.memo()는 큰 의미가 없다.모든 컴포넌트를 React.memo()로 래핑할 필요는 없다. 그 대신, 컴포넌트 트리에서 잘라낼 수 있는 몇 가지의 주요 컴포넌트 부분을 선택해서 사용하면 된다.2. useCalllback() 컴포넌트 실행 전반에 걸쳐 함수를 저장할 수 있게 해주는 훅이다. 리액트에게 우리는 이 함수를 저장하고 매번 실행할 때마다 이 함수를 재생성할 필요가 없다는 것을 알린다. 이렇게 되면 동일한 함수 객체가 메모리의 동일한 위치에 저장되므로 비교 작업을 할 수 있다.1) 기본 개념함수가 절대 변경되어서는 안된다면 useCallback을 사용해 함수를 저장하면 된다. 즉, 함수를 저장하고 이를 재사용할 수 있다.함수가 재 정의 되는 비용을 줄여주므로 메모리 누수를 방지할 수 있고, 나아가 불필요하게 다시 렌더링 되는 컴포넌트로 인해 성능이 저하되는 문제를 해결할 수 있다.하위 컴포넌트(예: )에 ‘함수’ 타입을 prop으로 전달해야 할 때 useCallback 훅을 사용하는데 반해, 표준 HTML 요소(예: )를 사용할 때는 useCallback 훅을 사용하지 않는 것이 권장된다. HTML 표준 요소는 앞서 말한 문제가 없으므로 useCallback 훅 없이 사용하는 것이 더 낫다.import React, { useState, useCallback } from 'react';import Button from './components/UI/Button/Button';import DemoOutput from './components/Demo/DemoOutput';import './App.css';function App() { const [showParagraph, setShowParagraph] = useState(false); const toggleParagraphHandler = useCallback(() =&gt; { setShowParagraph((prevShowParagraph) =&gt; !prevShowParagraph); }, []); return ( &lt;div className=\"app\"&gt; &lt;h1&gt;Hi there!&lt;/h1&gt; &lt;DemoOutput show={false} /&gt; &lt;Button onClick={toggleParagraphHandler}&gt;Toggle Paragraph!&lt;/Button&gt; &lt;/div&gt; );}export default App; useCallback(함수, 의존성 배열) 항상 같은 함수 객체가 사용되게끔 한다. useCallback()을 사용하면 props가 함수인 경우에도 useMemo()를 사용할 수 있다.2) 의존성 배열import React, { useState, useCallback } from 'react';import Button from './components/UI/Button/Button';import DemoOutput from './components/Demo/DemoOutput';import './App.css';function App() { const [showParagraph, setShowParagraph] = useState(false); const [allowToggle, setAllowToggle] = useState(false); // 의존성 배열로 []를 하게 되면, 함수 내부에서 사용되는 allowToggle 값은 초기 렌더링 때의 값으로 고정된다. const toggleParagraphHandler = useCallback(() =&gt; { if (allowToggle) { setShowParagraph((prevShowParagraph) =&gt; !prevShowParagraph); } }, [allowToggle]); const allowToggleHandler = () =&gt; { setAllowToggle(true); }; return ( &lt;div className=\"app\"&gt; &lt;h1&gt;Hi there!&lt;/h1&gt; &lt;DemoOutput show={showParagraph} /&gt; &lt;Button onClick={allowToggleHandler}&gt;Allow Toggling&lt;/Button&gt; &lt;Button onClick={toggleParagraphHandler}&gt;Toggle Paragraph!&lt;/Button&gt; &lt;/div&gt; );}export default App; 자바스크립트의 함수는 클로저이다. 즉, 함수가 정의되면 함수가 정의될 때 함수 블록에서 사용되는 모든 변수를 잠그게 된다. 만약, 의존성 배열을 따로 추가 하지 않는다면 위의 toggleParagraphHandler함수 내부에서 사용되는 allowToggle변수 값은 false로 고정된다.3. useMemo() useCallback이 함수에 대한 것을 저장하듯, UseMemo는 모든 종류의 데이터를 저장할 수 있다.import React, { useMemo } from 'react';import classes from './DemoList.module.css';const DemoList = (props) =&gt; { const { items } = props; const sortedList = useMemo(() =&gt; { console.log('Items sorted'); return items.sort((a, b) =&gt; a - b); }, [items]); console.log('DemoList RUNNING'); return ( &lt;div className={classes.list}&gt; &lt;h2&gt;{props.title}&lt;/h2&gt; &lt;ul&gt; {sortedList.map((item) =&gt; ( &lt;li key={item}&gt;{item}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; );};export default React.memo(DemoList); useMemo(함수, 의존성 배열) 이 함수가 저장하고 싶은 것을 반환한다. useMemo()는 물론 데이터 재계산과 같은 성능 집약적 작업 때문에 데이터를 저장해야 할 필요도 있지만 이런 경우가 아니면 별로 사용하지 않는다. useMemo()를 사용해 데이터를 저장하면 이는 메모리를 사용하는 것이고 이런 함수 저장 또한 일정 성능을 사용하는 것을 잊으면 안된다. " }, { "title": "07-http-요청과-커스텀-훅", "url": "/posts/react07/", "categories": "WEB, React", "tags": "React", "date": "2022-09-06 00:00:00 +0900", "snippet": "강의 링크1. 요청 보내고 응답 처리 하기import React, { useState, useEffect, useCallback } from 'react';import MoviesList from './components/MoviesList';import './App.css';function App() { const [movies, setMovies] = useState([]); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState(null); async function fetchMoviesHandler() =&gt; { // 초기화 setIsLoading(true); setError(null); try { // 데이터 fetch const response = await fetch('https://swapi.dev/api/films/'); if (!response.ok) { throw new Error('Something went wrong!'); } const data = await response.json(); // 받아온 정보를 저장한다. const transformedMovies = data.results.map((movieData) =&gt; { return { id: movieData.episode_id, title: movieData.title, openingText: movieData.opening_crawl, releaseDate: movieData.release_date, }; }); // 데이터를 가져오면 transformedMovies에 저장하고 loading은 끝난다. setMovies(transformedMovies); setIsLoading(false); } // 데이터를 못가져오면 에러 메시지를 저장한다. catch (error) { setError(error.message); } }); let content = &lt;p&gt;Found no movies.&lt;/p&gt;; // 정상적으로 데이터를 fetch 해왔을 때 if (movies.length &gt; 0) { content = &lt;MoviesList movies={movies} /&gt;; } // error가 발생했을 때 if (error) { content = &lt;p&gt;{error}&lt;/p&gt;; } // 로딩중 일 때 if (isLoading) { content = &lt;p&gt;Loading...&lt;/p&gt;; } return ( &lt;React.Fragment&gt; &lt;section&gt; &lt;!--버튼을 누르면 데이터를 fetch 한다. --&gt; &lt;button onClick={fetchMoviesHandler}&gt;Fetch Movies&lt;/button&gt; &lt;/section&gt; &lt;section&gt;{content}&lt;/section&gt; &lt;/React.Fragment&gt; );}export default App;2. useEffect() 활용하기 특정 컴포넌트가 로딩되자마자 데이터를 가져오기도 한다. 이 때 사용할 수 있는게 useEffect()이다.import React, { useState, useEffect, useCallback } from 'react';import MoviesList from './components/MoviesList';import './App.css';function App() { const [movies, setMovies] = useState([]); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState(null); // useCallback을 사용하는 이유는 참조 동일성 때문이다. // 함수가 변경되면 useEffect가 재실행되기 때문에 useCallback을 사용하지 않으면 무한루프의 위험이 있다. const fetchMoviesHandler = useCallback(async () =&gt; { setIsLoading(true); setError(null); try { const response = await fetch('https://swapi.dev/api/films/'); if (!response.ok) { throw new Error('Something went wrong!'); } const data = await response.json(); const transformedMovies = data.results.map((movieData) =&gt; { return { id: movieData.episode_id, title: movieData.title, openingText: movieData.opening_crawl, releaseDate: movieData.release_date, }; }); setMovies(transformedMovies); } catch (error) { setError(error.message); } setIsLoading(false); }, []); // 함수가 의존성 배열에 들어가있으므로, 함수는 useCallback을 사용해야 한다. useEffect(() =&gt; { fetchMoviesHandler(); }, [fetchMoviesHandler]); let content = &lt;p&gt;Found no movies.&lt;/p&gt;; if (movies.length &gt; 0) { content = &lt;MoviesList movies={movies} /&gt;; } if (error) { content = &lt;p&gt;{error}&lt;/p&gt;; } if (isLoading) { content = &lt;p&gt;Loading...&lt;/p&gt;; } return ( &lt;React.Fragment&gt; &lt;section&gt; &lt;button onClick={fetchMoviesHandler}&gt;Fetch Movies&lt;/button&gt; &lt;/section&gt; &lt;section&gt;{content}&lt;/section&gt; &lt;/React.Fragment&gt; );}export default App; HTTP 요청 전송은 일종의 사이드 이펙트로 컴포넌트의 상태를 바꿔버리기 때문에 useEffect()를 사용할 수 있다.3. 커스텀 훅 제작하기1) 커스텀 훅이란 커스텀 훅이란 상태를 설정할 수 있는 로직을 포함한 함수이다. 커스텀 훅을 만들어서, 재 사용 가능한 함수에 상태를 설정하는 로직을 아웃소싱할 수 있다.// src/hooks/use-counter.js// 위의 예시는 props로 넘기는 값에 따라 +를 하는 카운터를 만들거나 -를 하는 카운터를 만든다.import { useState, useEffect } from 'react';// 함수 인자를 통해 재활용성을 높일 수 있다. const useCounter = (forwards = true) =&gt; { const [counter, setCounter] = useState(0); useEffect(() =&gt; { const interval = setInterval(() =&gt; { if (forwards) { setCounter((prevCounter) =&gt; prevCounter + 1); } else { setCounter((prevCounter) =&gt; prevCounter - 1); } }, 1000); return () =&gt; clearInterval(interval); }, [forwards]); return counter;};export default useCounter; 커스텀 훅을 통해, 다른 컴포넌트에서 사용할 수 있는 로직을 커스텀 훅으로 아웃 소싱 할 수 있다. 함수 이름은 use로 시작해야 한다. 리액트에게 이 함수가 커스텀 훅임을 알려주며 이는 리액트가 해당 함수를 훅의 규칙에 따라 사용하겠다고 보장하는 것이다. 2) useHttp// src/hooks/use-http.jsimport { useState, useCallback } from 'react';const useHttp = () =&gt; { const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState(null); // useCallback을 사용하는 이유는 다음과 같다. // 훅을 사용할 때, useEffect로 해당 함수를 의존성 배열에 추가하게 되는데 참조 동일성을 지켜 무한 루프에 빠지지 않도록 한다. const sendRequest = useCallback(async (requestConfig, applyData) =&gt; { setIsLoading(true); setError(null); try { const response = await fetch(requestConfig.url, { method: requestConfig.method ? requestConfig.method : 'GET', headers: requestConfig.headers ? requestConfig.headers : {}, body: requestConfig.body ? JSON.stringify(requestConfig.body) : null, }); if (!response.ok) { throw new Error('Request failed!'); } const data = await response.json(); applyData(data); } catch (err) { setError(err.message || 'Something went wrong!'); } setIsLoading(false); }, []); return { isLoading, error, sendRequest, };};export default useHttp;// src/App.jsimport React, { useEffect, useState } from 'react';import Tasks from './components/Tasks/Tasks';import NewTask from './components/NewTask/NewTask';import useHttp from './hooks/use-http';function App() { const [tasks, setTasks] = useState([]); const { isLoading, error, sendRequest: fetchTasks } = useHttp(); useEffect(() =&gt; { const transformTasks = (tasksObj) =&gt; { const loadedTasks = []; for (const taskKey in tasksObj) { loadedTasks.push({ id: taskKey, text: tasksObj[taskKey].text }); } setTasks(loadedTasks); }; // 훅에서 정의된 함수들은 훅이 사용되는 곳에서 호출할 수 있다. `` // 즉, 훅을 사용하는 컴포넌트에서 호출할 수 있다. fetchTasks( { url: 'https://react-http-6b4a6.firebaseio.com/tasks.json' }, transformTasks ); }, [fetchTasks]); const taskAddHandler = (task) =&gt; { setTasks((prevTasks) =&gt; prevTasks.concat(task)); }; return ( &lt;React.Fragment&gt; &lt;NewTask onAddTask={taskAddHandler} /&gt; &lt;Tasks items={tasks} loading={isLoading} error={error} onFetch={fetchTasks} /&gt; &lt;/React.Fragment&gt; );}export default App; 컴포넌트가 생성되면서 useHttp함수를 호출되고 useEffect가 실행된다. 그 결과, isLoading, error, sendRequest(fetchTask)가 반환된다. useEffect가 실행되면서 sendRequest(fetchTask)함수가 실행된다. 데이터를 fetch하고 데이터를 state에 저장하는 함수 데이터가 state에 저장되면 state가 변경되어 컴포넌트가 리랜더링된다." }, { "title": "운영체제-프로세스-관리", "url": "/posts/operationsystem04/", "categories": "CS, 운영-체제", "tags": "cs, 운영-체제", "date": "2022-09-06 00:00:00 +0900", "snippet": "4장-프로세스-관리강의 링크1. 프로세스 관리1) 프로세스 생성 부모 프로세스가 자식 프로세스를 생성한다. (시스템 콜을 통해 요청)프로세스의 트리 (계층 구조)가 형성된다. 프로세스는 자원을 필요로 한다. 운영체제로부터 받는다. 부모와 공유한다. 자원의 공유 부모와 자식이 모든 자원 을 공유하는 모델 일부를 공유하는 모델 전혀 공유하지 않는 모델 수행 (Execution) 부모와 자식은 공존하면서 수행되는 모델 자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델 주소 공간 (Address space) 자식은 부모의 공간을 복사한다 (binary and OS data) 자식은 그 공간에 새로운 프로그램을 올린다. 예시 - 유닉스 fork()시스템 콜이 새로운 프로세스를 생성한다. 부모를 그대로 복사한다. 주소 공간을 할당한다. fork()다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올린다.2) 프로세스 종료 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려준다 exit 시스템 콜 자식이 부모에게 output data를 보내게 된다. (via wait) 자식이 부모보다 항상 먼저 종료된다. 프로세스의 각종 자원들이 운영체제에게 반납된다. 부모 프로세스가 자식의 수행을 종료시킨다. aboart 시스템 콜 자식이 할당 자원의 한계치를 넘었거나 자식에게 할당된 태스크가 더 이상 필요하지 않을 때 종료된다. 부모가 (exit)하면 자동으로 자식도 종료된다. 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다. 단계적인 종료이다. 2. 프로세스와 관련된 시스템 콜 프로세스와 관련한 시스템 콜   fork() create a child exec() overlay new image wait() sleep until child is done exit() frees all the resources, notify parent 1) fork() 프로세스를 생성할 때 호출하는 시스템 콜 새롭게 생성된 자식 프로세스는 새로운 PID를 갖게 되어 호출한 부모 프로세스를 복사한다. 자식 프로세스는 부모와 독립되 물리 메모리 공간을 갖게 된다.// fork() 시스템 콜// creates new address space that is a duplicate of the caller.int main(){ int pid; pid = fork(); // parent면 양수를 반환, child면 0을 반환한다. if (pid==0) printf(\"\\n Hello, I am child\\n\") else if (pid &gt; 0) printf(\"\\n Hello, I am parent\\n\")}2) exec() 현재 프로세스 공간을 새로운 프로세스 이미지로 덮어버린다.// exec() 시스템 콜// replaces the memory image of the caller with a new programint main(){ int pid; pid = form(); if (pid==0) { printf(\"\\n Hello, I am child! Now I'll run date\\n\") execl(\"/bin/date\", \"/bin/date\", (char*)0); } else if (pid &gt;0) printf(\"\\n Hello, I am parent\\n\")}3) wait() 자식 프로세스가 종료되기 전까지 부모 프로세스가 기다리게 하는 시스템 콜프로세스 A가 wait()시스템 콜을 호출하면 커널은 child가 종료될 때까지 프로세스 A를 sleep 시킨다 (block 상태) child process가 종료되면 커널은 프로세스 A를 깨운다 (ready 상태)// 예시int main(){ int pid; pid = fork(); if (pid==0) printf(\"\\n Hello, I am child\\n\") else if (pid &gt; 0) printf(\"\\n Hello, I am parent\\n\") wait() // parent면 wait() 호출}4) exit() 프로세스를 종료시킬 때 호출하는 시스템 콜 자발적인 종료 마지막 statement 수행 후 exit() 시스템 콜을 통해 호출한다. 프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어준다. 비자발적인 종료 부모 프로세스가 자식 프로세스를 강제 종료한다. 자식프로세스가 한계치를 넘어서는 자원 요청 자식에게 할당된 태스크가 더 이상 필요하지 않음 키보드로 kill, break 등을 친 경우 부모가 종료하는 경우 부모 프로세스가 종료하기 전에 자식들이 먼저 종료된다. 3. 프로세스 간 협력1) 프로세스 종류 독립적 프로세스 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다. 협력 프로세스 프로세스 협력 매커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다. 2) 프로세스 간 협력 메커니즘 (IPC: Interprocess Communication) 메시지를 전달하는 방법 (message passing): 커널을 통해 메시지를 전달한다. 프로세스 사시의 공유 변수를 일체 사용하지 않고 통신하는 시스템이다. Direct Communication: 통신하려는 프로세스의 이름을 명시적으로 표시한다. Indirect Communication: mailbox (또는 port)를 통해 메시지를 간접적으로 전달한다. 주소 공간을 공유하는 방법 (shared memory) : 서로 다른 프로세스 간에도 일부 주소 공간을 공유한다. (커널의 도움을 받아서 공유) 프로세스는 각자 주소 공간이 있어서 원래 서로 접근할 수 없다. 물리적인 메모리에 매핑할 때 공유하도록 생성한다. threadthread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 process를 thread들 간에는 주소 공간을 공유하므로 협력이 가능하다." }, { "title": "운영체제-프로세스", "url": "/posts/operationsystem03/", "categories": "CS, 운영-체제", "tags": "cs, 운영-체제", "date": "2022-09-06 00:00:00 +0900", "snippet": "3장-프로세스강의 링크1. 프로세스 기본 개념 실행 중인 프로그램. (Process is a program in execution) 운영체제가 프로그램을 메모리에 할당하여 실행하면 이를 프로세스라고 한다. 프로세스의 문맥 (context): 프로세스의 현재 상태를 나타내는 데 필요한 요소 CPU 수행 상태를 나타내는 하드웨어 문맥 프로세스는 CPU를 잡고 매 순간 instrtuction을 실행하기 때문에 현재 얼마나 instruction을 실행 했는 지를 확인하기 위해 Program Counter: 현재 어디를 가르키는가 각종 register: register가 어떤 값을 가지고 있는가 프로세스의 주소 공간 code, data, stack: 어떤 내용이 들어 있는가 프로세스 관련 커널 자료 구조 PCB (Process Control Block): 해당 프로세스의 PCB Kernel stack: 해당 프로세스의 커널 스택 프로세스들이 time-sharing하면서 계속 번갈아 가면서 실행되기 때문에 프로세스의 문맥을 파악해야 다시 실행할 수 있다.1) 프로세스의 상태 (Process State) 프로세스는 상태가 변경되며 수행된다. Running CPU를 잡고 instruction을 수행 중인 상태 usermode, monitor mode Ready (in memory) CPU를 기다리는 상태 모든 준비는 끝나있고 CPU만 할당하면 instruction을 실행할 수 있다. 메모리에 물리적으로 올라가 있는 상태이다. Blocked (wait, sleep) CPU를 주어도 당장 isntrtuction을 수행할 수 없는 상태 Process 자신이 요청한 event (예: I/O)가 즉시 만족되지 않아 이를 기다리는 상태 ex) 디스크에서 file을 읽어 와야 하는 경우 자신이 요청한 event가 만족되면 ready된다. Suspended (stopped) 외부적인 이유로 프로세스의 수행이 정지된 상태 프로세스는 통째로 디스크에 swap out 된다. ex) 사용자가 프로그램을 일시 정지 시킨 경우 (break key) ex) 메모리에 너무 많은 프로세스가 올라와 프로세스를 잠시 중단 시킨다. 외부에서 resume을 해주어야 active된다. New 프로세스가 생성 중인 상태 Terminated 수행이 끝난 상태 2) Process Control Block (PCB) 운영체제가 각 프로세스를 관리하기 위해 프로세스 당 유지하는 정보 (data부분에 할당되어 있다.) OS가 관리상 사용하는 정보 Proces State, Process ID scheduling Information, Priority CPU 수행 관련 하드웨어 값 Program counter, registers 메모리 관련 Code, data, stack의 위치 정보 파일 관련 Open file descriptors.. 3) 문맥 교환 (Context Switch ) CPU를 한 프로레스에서 다른 프로세스로 넘겨 주는 과정이다.CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행한다. CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장한다. CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어온다.즉, 다음에 해당 프로세스의 실행을 재개하기 위해서 프로세스 문맥을 저장해야 한다.시스템 콜이나 인터럽트 발생 시 반드시 문맥 교환이 발생하는 것은 아니고 다른 프로세스에 CPU를 넘겨주어야 문맥 교환이 발생하는 것을 유념해야 한다.4) 프로세스를 스케줄링하기 위한 큐 프로세스들은 각 큐들을 오가며 수행된다. Job queue: 현재 시스템 내에 있는 모든 프로세스의 집합 Ready queue: 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합 Device queues: I/O device의 처리를 기다리는 프로세스의 집합5) 스케줄러 Long-tem scheduler (장기 스케줄러 or JOB scheduler) 시작 프로세스 중 어떤 것들을 ready queue로 보낼 지 결정한다. 프로세스에 momory(및 각종 자원)을 주는 문제 degree of Multiprogramming을 제어한다. 메모리에 올라가 있는 프로세스의 수를 제어한다 메모리에 프로그램이 너무 많이 올라가면 성능이 좋지 않다. 메모리에 프로그램이 너무 적게 올라가도 성능이 좋지 않다. time sharing system에는 보통 장기 스케줄러가 없다. (무조건 ready이다.) Short-term scheduler (단기 스케줄러 or CPU scheduler) 어떤 프로레스를 다음 번에 running 시킬 지를 결정한다. 프로레스에 CPU를 주는 문제 충분히 빨라야 한다. (ms 단위) Medium-term scheduler (중기 스케줄러 or Swapper) 여유 공간을 마련 하기 위해서 프로세스를 통쨰로 메모리에서 디스크로 쫓아낸다. 프로세스에게서 memory를 뺏는 문제 degree of Multiprogramming을 제어한다. time sharing system에서는 장기 스케줄러가 없기 때문에 중기 스케줄러로 제어한다. 2. Thread 프로세스(process) 내에서 실행되는 흐름의 단위로 실질적인 CPU 수행 단위라고 생각하면 된다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다. 프로세스 내부에서 Thread들 끼리 공유하는 부분 (task) code section data section OS resources 별도로 갖고 있는 것 CPU 수행과 관련된 정보 (PC, register) stack section 1) 스레드 사용 이점 멀티 스레드로 구성된 task 구조에서는 하나의 서버 스레드가 blocked(wait)상태인 동안에도 동일한 task 내의 다른 스레드가 실행(running)되어 빠른 처리를 할 수 있다. 빠른 응답속도 ex) 웹 브라우저 사용시 네트워크에서 웹페이지를 읽어오는 동안 해당 스레드가 blocked상태가 되어도 다른 스레드는 일을 할 수 있음. 동일한 일을 수행하는 멀티 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다. 자원 절약, 자원 공유 동일한 일을 하는 여러 프로세스를 사용하면 프로세스만의 독자적인 주소공간이 만들어져야 하고 이는 메모리를 차지하게 된다. 각각의 메모리에 code, data, stack이 올라가야 한다. (메모리 낭비가 심하다) ex) 웹브라우저 여러개 띄우는 경우 프로세스를 만드는 것과 문맥 교환을 overhead가 비싸다. (30배, 5배) 효율 쓰레드 생성은 간단하다. 쓰레드 간의 CPU 스위치는 간단하다. (동일한 주소 공간을 사용하고 있기에) 스레드를 사용하면 병렬성을 높일 수 있다. CPU가 여러 개라면, 병렬적으로 실행할 수 있다. 2) 스레드 종류 커널 스레드 (Kernel Threads) 커널이 스레드의 존재를 안다. 유저 스레드 (User Threads) 커널의 지원을 받지 않고 사용자 차원에서 생성한 스레드이다. 구현상의 제약점이 있다. " }, { "title": "03-webPack-기초-속성", "url": "/posts/bundler03/", "categories": "WEB, Bundler", "tags": "Bundler, WebPack", "date": "2022-09-04 00:00:00 +0900", "snippet": "참고자료 / 강의 링크 / 공식문서// webpack.config.jsconst path = require('path');module.exports = { // 선택한 모드를 통해 webpack이 알맞은 내장 최적화를 사용 mode: \"production\", // \"production\" | \"development\" | \"none\" // ./src 를 기본으로 함 // 애플리케이션이 여기에서 실행되며 webpack이 번들링을 시작 entry: \"./app/entry\", // string | object | array // webpack이 결과를 내보내는 방법과 관련된 옵션 output: { // 모든 출력 파일의 대상 디렉터리는 반드시 절대 경로 여야함 (Node.js의 path 모듈을 사용) path:path.resolve(__dirname, \"dist\"), // string (기본값) filename: \"[name].js\", // string (기본값) } }, // 모듈 관련 설정 module: { \t// 모듈에 대한 규칙 (로더 설정, 파서 옵션 등) rules: [ { // 각각의 정규식 또는 문자열을 허용하는 일치 조건 // test 및 include 동작은 동일하며 둘 다 일치해야함 // exclude는 일치하지 않아야함 (test 및 include 보다 우선함) test: /\\.js$/, loader: \"babel-loader\", include: [ path.resolve(__dirname, \"app\") ], exclude: /node_modules/ }, { test: /\\.(png|jpg|gif|svg)$/, loader: 'file-loader', options: { name: '[name].[ext]?[hash]' } } }, // 파일의 연관관계를 해석할 때의 해석 방식을 지정 // 모듈 요청 해석 옵션 resolve: { // 모듈을 해석할 때 검색할 디렉터리 modules: [\"node_modules\",path.resolve(__dirname, \"app\")], // 사용자가 import할 때 확장자를 생략 할 수 있도록 한다. extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 모듈 이름 별칭 목록 // 현재 컨텍스트 기준으로 별칭을 import alias: { \"@\": path.resolve(__dirname, \"src/\") }, }, // 브라우저 devtools에 대한 메타 정보를 추가하여 디버깅 향상 // 빌드 속도는 느리나 가장 상세한 소스맵. devtool: \"source-map\", // enum // devServer 설정 devServer: { port: 9000, }, plugins: [ // ... ],}1. entry webpack이 번들 빌드를 시작하는 곳이다.1) entry 유형 SPA(Single Page Application): 엔트리 포인트가 1개이다. MPA(Multi Pate Application): 다중 엔터리 포인트를 갖고 있다.// 다중 엔트리 포인트module.exports = { //... entry: { home: './home.js', about: './about.js', contact: './contact.js', },};2) entry 파일 entry 속성에 지정된 파일에는 애플리케이션의 전반적인 구조와 내용이 담겨야 한다.웹 팩이 해당 파일을 가지고 애플리케이션에서 사용되는 모듈의 연관 관계를 이해하고 분석하기에 애플리케이션을 동작시킬 수 있는 내용이 담겨야 한다.// 예시) vue의 main.jsimport { createApp } from \"vue\";import App from \"./App.vue\";import router from \"./router\";import store from \"./store\";const app = createApp(App);app.use(store).use(router);app.mount(\"#app\");2. output output속성에는 웹팩으로 번들링 한 결과물을 저장하는 파일 경로를 의미한다.1) Path캐싱 가이드모든 출력 파일의 대상 디렉터리는 반드시 절대 경로여야 한다. (Node.js의 path 모듈을 사용)2) 파일 이름 옵션 단일 엔트리 포인트의 경우, 정적인 이름으로 설정할 수 있다. 그러나 둘 이상의 엔트리 포인트 , 코드 뿐할 또는 다양한 플러그인을 통해 여러 번들을 생성할 때 다음과 같은 파일 이름 옵션을 사용하여 각 번들에 고유한 이름을 부여해야 한다.module.exports = { output: { // 엔트리의 이름을 사용 filename: '[name].bundle.js' // 내부 청크 id를 사용 filename: '[id].bundle.js' // 여러 옵션을 조합해서 사용 filename: '[name].[hash].bundle.js' // 생성된 콘텐츠에서 생성된 해시를 사용 filename: '[chunkhash].bundle.js' }};3. module 프로젝트 내에서 다른 유형의 모듈을 처리하는 방법을 결정한다.공식문서// webpack.config.jsmodule.exports = { module: { rules: [] }}1) rules 모듈이 생성될 때 요청과 일치하는 Rule의 배열이다. 이러한 규칙은 모듈 생성 방법을 수정할 수 있다. 로더를 모듈에 적용시키거나 파서를 수정할 수 있다. test: loader를 적용할 모듈 (정규식 사용) use: 해당 모듈에 적용되는 Loader의 배열 use: [\"style-loader\"] 는 use:[{loader: \"style-loader\"}]와 같다. 여러 로더를 전달하여 연결할 수 있으며, 맨 오른쪽에서 부터 순차적으로 로더가 적용된다. ex) use: [\"style-loader\", \"css-loader\", \"scss-loader\"] exclude: 조건과 일치하는 모든 모듈을 제외한다. include: 조건과 일치하는 모든 모듈을 포함한다.2) loader가 필요한 이유만약 loader없이, 다른 유형의 모듈 파일을 엔트리 파일에 import하려고 하면 다음과 같은 에러가 발생한다.ERROR in ./base.css 1:2Module parse failed: Unexpected token (1:2)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders 이는 base.css를 loader없이 index.js(엔트리 파일)에 import하려고 해서 발생한 오류이다. 해당 파일 타입을 다루기 위해 loader를 사용하라는 의미이다.4. plugin 다양한 방법으로 webpack 빌드 프로세스를 사용자 정의하는 데 사용된다.공식 문서// webpack.config.jsmodule.exports = { plugins: []} 웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성이다. 플러그인은 해당 결과물의 형태를 바꾸는 역할을 한다. 플러그인의 배열에는 생성자 함수로 생성된 객체 인스턴스만 추가될 수 있다. 플러그인 목록 1) 플러그인 예시MiniCssExtractPlugin을 사용한다면 다음과 같이 코드를 작성할 수 있다.// webpack.config.jsvar path = require(\"path\");var MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");module.exports = { mode: \"none\", entry: \"./index.js\", output: { filename: \"bundle.js\", path: path.resolve(__dirname, \"dist\"), }, module: { rules: [ { test: /\\.css$/, use: [{ loader: MiniCssExtractPlugin.loader }, \"css-loader\"], }, ], }, // 결과물에 대한 정보를 바꾼다. plugins: [new MiniCssExtractPlugin()],};해당 플러그인의 사용 전 후는 다음과 같다.사용 전사용 후이렇게 dist 폴더의 구조가 변경된다. 해당 플러그인은 CSS파일을 필요로하는 JS파일만 CSS파일을 생성한다. 그 결과, bundle.js에는 css가 포함되어 있지 않다.해당 플러그인을 사용하면 html에 직접 스타일 시트를 추가해야 한다. 이전에는 bundle.js에 css가 포함되어 있어서 style-loader를 사용하면 추가할 필요가 없었다.&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;CSS &amp; Libraries Code Splitting&lt;/title&gt; &lt;!-- style-loader를 사용하지 않고 직접 추가한다. --&gt; &lt;link rel=\"stylesheet\" href=\"./dist/main.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h3&gt;CSS Code Splitting&lt;/h3&gt; &lt;/header&gt; &lt;div&gt; &lt;p&gt;This text should be colored with blue after injecting CSS bundle&lt;/p&gt; &lt;/div&gt; &lt;!-- 웹팩의 빌드 결과물을 로딩하는 스크립트 --&gt; &lt;script src=\"./dist/bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;5. devServer공식 문서개발을 할 때, 수정한 코드를 확인하려면 매번 빌드를 해야 한다. 이런 불편함을 없애기 위해 webpack의 dev 서버를 사용할 수 있다. webpack dev 서버는 빌드를 매번 안 해도 코드의 변경 사항을 확인 할 수 있다. npm run dev 명령어는 dist 폴더를 생성하지 않는다. 즉, 메모리에서 빌드 결과물을 그냥 올려놓는다. 메모리 상으로만 빌드 결과물 올려놓아 실시간 확인이 가능하다.# 필요한 라이브러리 설치$ npm i webpack webpack-cli webpack-dev-server html-webpack-plugin -D// package.json{ \"name\": \"devserver\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", // dev 서버를 여는 명령어 추가 \"dev\": \"webpack-dev-server\", \"build\": \"webpack\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.42.0\", \"webpack-cli\": \"^3.3.11\", \"webpack-dev-server\": \"^3.10.3\" }// webpack.config.js const path = require('path');module.exports = { mode: 'developement', entry: './index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), }, devServer: { port: 9000, },};6. merge merge를 활용하면 Webpack 설정 파일을 나눠서 관리할 수 있다.1) 폴더 생성# Webpack 개발, 서버, 빌드, 유틸리티 구성 파일을 webpack 디렉토리 안에 생성한다. $ code webpack/config.{dev,server,build,utils}.js2) 각 파일 설정// webpack/config.utils.jsconst path = require('path');const getAbsPath = (dirOrFile) =&gt; path.resolve(process.cwd(), dirOrFile);exports.getAbsPath = getAbsPath;// 개발 구성// webpack/config.dev.jsconst { getAbsPath } = require('./utils');const devConfig = { target: 'web', mode: 'development', devtool: 'eval-source-map', entry: { main: getAbsPath('src/index.js'), }, output: { path: getAbsPath('public'), filename: 'js/main.js', }};module.exports = devConfig;// 서버 구성// webpack/config.server.jsconst { merge } = require('webpack-merge');const devConfig = require('./dev');const serverConfig = { devServer: { static: ['public'], client: { overlay: true, }, compress: true, host: 'localhost', port: 3000, open: false, },};module.exports = merge(devConfig, serverConfig);// 빌드 구성// webpack/config.build.jsconst { merge } = require('webpack-merge');const { getAbsPath } = require('./utils');const devConfig = require('./dev');const buildConfig = { mode: 'production', devtool: false, output: { path: getAbsPath('public'), filename: 'js/bundle.min.js', },};module.exports = merge(devConfig, buildConfig);// package.json {\t\"scripts\": {\t\t\"start\": \"npm run dev -- --open\", \"bundle\": \"webpack --config webpack/config.dev.js\", \"dev\": \"webpack serve --config webpack/config.server.js\", \"build\": \"webpack build --config webpack/config.build.js\" },}" }, { "title": "02-webPack-튜토리얼", "url": "/posts/bundler02/", "categories": "WEB, Bundler", "tags": "Bundler, WebPack", "date": "2022-09-04 00:00:00 +0900", "snippet": "참고자료 / 강의 링크 웹팩은 가장 많이 사용되는 모듈 번들러이다.$ npm install webpack webpack-cli -D$ npm install lodash1. 파일 설정&lt;!-- index.html --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Webpack Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"./dist/main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;// src/index.jsimport _ from \"lodash\";function component() { var element = document.createElement(\"div\"); /* lodash is required for the next line to work */ element.innerHTML = _.join([\"Hello\", \"webpack\"], \" \"); return element;}document.body.appendChild(component());2. 빌드 명령어 설정// package.json{ \"name\": \"npm\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", // 커스텀 명령어 설정 \"build\": \"webpack --mode=none\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^5.74.0\", \"webpack-cli\": \"^4.10.0\" }, \"dependencies\": { \"lodash\": \"^4.17.21\" }, // false 로 설정하면 사용하지 않는 export는 제거해도 괜찮다는 것을 webpack에게 알릴 수 있다. // TreeShaking \"sideeffects\": false} script속성에 build 명령어를 설정한다. 만약 build 명령어에 --mode=none이 설정하지 않고 명령어를 사용하면 다음과 같은 에러 메시지가 뜬다.# mode를 설정하지 않으면 결과물이 난독화 되어있음. WARNING in configurationThe 'mode' option has not been set, webpack will fallback to 'production' for this value.Set 'mode' option to 'development' or 'production' to enable defaults for each environment.You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/# 스크립트에서 정의한 빌드 명령어$ npm run build build하면 dist 폴더가 생성된다. 결과 파일은 dist 폴더 밑의 main.js로 생성되어 있다.3. 설정 파일결과물의 파일 경로나 웹 자원의 대상을 지정하고 싶으면 다음과 같이 package.json의 script속성을 수정할 수 있다. \"scripts\": { \"build\": \"webpack --mode=none --entry=src/index.js --output=dist/main.js\" },그런데 이는 일일이 작성하기 불편하기 때문에 웹팩 설정 파일webpack.config.js을 사용할 수 있다.// webpack.config.jsvar path = require('path');module.exports = { mode: 'none', entry: './src/index.js', output: { filename: 'main.js', // __dirname: 현재 실행 중인 폴더 경로를 의미한다. path: path.resolve(__dirname, 'dist') }}; path 라이브러리 output: entry에 있는 파일을 대상으로 webpack을 돌려서 결과물을 만드는 경로를 지정할 수 있다. webpack으로 변환한 결과 파일이 저장되는 경로 // package.json의 script 수정 \"scripts\": { \"build\": \"webpack\" },4. 웹팩 변환 전후 비교변환 전변환 후요청 수가 줄어든 것을 확인할 수 있다. 현재는 라이브러리를 1개만 설치해서 큰 효과가 없지만 프로젝트 규모가 커질 수록 효과는 클 것이다." }, { "title": "01-Bundler-등장-배경", "url": "/posts/bundler01/", "categories": "WEB, Bundler", "tags": "Bundler", "date": "2022-09-03 00:00:00 +0900", "snippet": "참고 자료1. Node.js와 NPM1) Node.js Node.js란 브라우저가 아닌 환경에서 JS를 실행할 수 있도록 하는 환경이다. JavsScript 런타임 환경으로 React.js 더 편리하게 사용할 수 있도록 해주는 도구를 제공해 준다. 이전에는 JS가 브라우저에서만 실행할 수 있었지만 Node.js로 자바스크립트를 브라우저 밖에서도 실행할 수 있게 되었다. Node.js를 설치시 NPM이라고 불리는 패키지 매니저도 자동으로 설치 된다. 2) NPM NPM 패키지 매니저를 통해 React에 필요한 다양한 모듈을 다운, 업데이트 할 수 있도록 한다.전 세계 자바스크립트 개발자들이 모두 자바스크립트 라이브러리를 공개된 저장소에 올려놓고 npm 명령어로 라이브러리를 다운받을 수 있다.# NPM 프로젝트 초기화 명령 실행 (package.json 파일 생성)$ npm init-y// package.json { \"name\": \"webpack\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": [ ], \"devDependencies\": [ ],} scripts: 해당 속성에 실행을 원하는 명령어를 설정할 수 있다. npm run + 실행 이름으로 가동된다. dependencies: npm install을 통해 설치되는 모듈 리스트 (애플리케이션의 로직과 관련있는 라이브러리) ex) react, angular, chart 등 devDependencies npm install -D를 통해 설치되는 모듈 리스트 (개발 보조 라이브러리) ex) webpack, js-compression, sass, eslint, imagein 등 개발용 라이브러리와 배포용 라이브러리 구분하기 NPM 지역설치를 할 때에는 해당 라이브러리가 배포용(dependencies)인지 개발용 (devDependencies)인지 꼭 구분해야 한다. 배포용 라이브러리는 npm run build로 빌드를 하면 최종 애플리케이션 코드에 포함된다. 개발용 라이브러리는 빌드하고 배포할 때 애플리케이션 코드에서 빠지게 된다.# 모듈 설치$ npm install 모듈이름$ npm install 모듈이름 --save-prod# 모듈 삭제$ npm uninstall 모듈이름# 전역 설치 명령어$ npm install 모듈이름 --global # dev 설치$ npm install 모듈이름 -D$ npm install 모듈이름 --save-dev 지역 설치 node_modules 폴더가 생성되고 그 하위에 라이브러리 파일들이 설치된다. package.json의 dependencies에 추가된다. global 설치 windwo 전역 설치 경로: %USERPROFILE%\\AppData\\Roaming\\npm\\node_modules mac 전역 설치 경로: /usr/local/lib/node_modules 시스템 레벨에 전역으로 설치하기 위함이다. dev 설치 node_modules 폴더가 생성되고 그 하위에 라이브러리 파일들이 설치된다. package.json의 devDependencies에 추가된다. 2. Module Module이란 여러 기능들에 관한 코드가 모여있는 하나의 파일이다.애플리케이션의 규모가 커짐에 따라 JS코드를 여러 파일과 폴더에 나누어 작성하고 서로를 효율적으로 불러올 수 있도록 하는 시스템이 필요했고 이를 해결하기 위해 ES6부터 JS는 모듈 기능을 사용할 수 있게 되었다.1) Module의 특징 유지 보수성 코드를 다시 작성하지 않고도 쉽게 의존성을 변경할 수 있다. 애플리케이션을 유지 보수할 때 관련 있는 모듈만 업데이트 하면 된다. 네임 스페이스 JS는 파일 스코프가 존재하지 않는다. 변수는 모두 전역변수를 사용하기 때문에 애플리케이션이 커질 수록 변수명이 겹치는 경우가 많아질 수 있다. Module은 Module만의 네임 스페이스를 갖고 있기 때문에 위와 같은 문제를 해결할 수 있다. 재 사용성 Module로 분리 시켜 필요할 때마다 다시 재 사용할 수 있다. 2) 번들러 등장 배경 브라우저별 HTTP 요청 숫자의 제약 TCP 스펙에 따라 브라우저에서 한 번에 서버로 보낼 수 있는 HTTP 요청 숫자는 제약되어 있다. HTTP 요청 숫자를 줄이는 것이 웹 애플리케이션의 성능을 높여줄 뿐만 아니라 사용자가 사이트를 조작하는 시간을 당길 수 있다. **프로젝트 규모가 커지면서 많은 모듈을 사용하게 되었고 수 많은 모듈을 일일이 요청하는 것을 피하기 위해 번들러의 필요성이 대두되었다. ** 트리 쉐이킹, 코드 스플릿, 소스맵, 코드 최적화 필요성 대두 (추후 서술)3. Bundler1) Bundling 애플리케이션을 구성하는 수 많은 자원들을 하나의 파일로 병합 및 압축해주는 동작을 Module Budling이라고 한다.번들링은 웹 애플리케이션을 동작시키기 위한 자원 (HTML, CSS, JS, Images 등)들을 각각의 모듈로 보고 하나로 묶고 조합해서 하나의 정적인 결과물을 만든다. 많은 자원들의 연관관계를 파악한 후, 묶고 조합한다. 하나로 묶여있지 않으면, 그만큼 서버에 필요한 자원을 여러번 요청해야 하다. 하나로 묶어서 경량화 시켜주면 그만큼 서버에 가하는 부하도 적어지고 로딩시간도 높일 수 있어 성능적으로 유리하다.또한, 앱에 많은 기능이 필요해질수록 모듈 종속성의 올바른 순서를 추적하고 로드하는 번거로움이 더 커지게 된다. 코드 베이스를 모듈로 분할 관리하고 묶어 주어야 한다.2) 번들러의 부가 기능 번들러는 애플리케이션에 필요한 모든 모듈을 알아서 매핑하며 매핑된 결과를 가지고 하나 이상의 번들을 생성한다. 트리 쉐이킹 (Tree Shaking) 트리쉐이킹은 최종 번들에서 사용되지 않을 코드를 제거한다. 애플리케이션에서 사용되지 않는 코드가 번들에 포함될 수도 있다. 사용되지 않는 코드 조각은 번들 크기를 불필요하게 키우므로 번들 과정에서 제거해야 한다. 이런 과정이 마치 나무 흔들기와 비슷해서 TreeShaking이라고 부른다. JS 번들 크기를 줄여 앱의 실행 속도를 향상시킬 수 있다. 코드 분할 (Code Spliting) 코드 분할은 런타임 중에 나뉘어진 chunk 파일을 동적으로 불러오는 것을 말한다. 즉, 사용자가 애플리케이션을 모듈이 필요해지면 번들러가 필요한 하위 번들을 처리한다. (Dinamic Loading, Lazy Loading) 앱이 커지면 결국 번들 또한 사이즈가 커진다. 특히 3rd-party 라이브러리를 추가할 때 앱이 더욱 커져서 로드 시간이 길어질 수 있다. 번들이 거대해지는 것을 방지하기 위해 좋은 방법은 코드를 나누는 것이다. 앱의 코드 양을 줄이지 않고도 사용자가 필요하지 않은 코드를 불러오지 않게 하며 앱의 초기화 로딩에 필요한 비용을 줄여준다. 코드 최적화, 소스맵 (Code Optimization, SourceMap) 수많은 모듈을 번들하는 동안 수행해야 하는 코드 최적화(코드 압축)를 할 수 있다. 번들 파일이 생성되면 브라우저에서 이를 해석하여 처리 하는데, 코드 최적화를 위해 주석, 공백 또는 긴 변수, 함수 이름 등을 모두 축소 또는 제거하여 파일의 크기를 크게 줄일 수 있다. 하지만, 이 코드는 압축되었기에 사람이 읽기 매우 어렵다. 사람이 읽기 어려운 코드는 디버깅도 쉽지 않아 코드를 추적 가능한 소스맵을 제공하는 기능이 필요하다. 즉, 소스맵은 배포할 때 성능최적화를 위해 압축한 코드를 원본 파일과 연결시켜준다. " }, { "title": "05-useEffect-useReducer-useContext", "url": "/posts/react05/", "categories": "WEB, React", "tags": "React", "date": "2022-09-01 00:00:00 +0900", "snippet": "강의 링크1. useEffect1) SideEffect react의 메인 업무: UI를 렌더링하고 사용자에 반응하여 리렌더링한다. JSX 코드와 DOM을 평가하고 렌더링한다. state와 props를 관리한다. SideEffect: 애플리케이션에서 일어나는 다른 모든 것 화면에 렌더링하는 것을 제외하고 애플리케이션에서 일어나는 다른 모든 일 ex) http request를 보내는 것 ex) 로컬 스토리지에 저장하는 것 SideEffect는 직접적으로 컴포넌트 함수에 들어가면 안된다. 버그나 무한 루프가 발생할 수 있기 때문이다.예를 들어, http 리퀘스트에 대한 응답으로 어떤 state를 변경한다면 리퀘스트를 보낸다. 리퀘스트를 받아 state를 변경한다. state를 변경하면 해당 컴포넌트를 다시 렌더링 한다. 재 렌더링 되었기에 다시 리퀘스트를 보낸다 무한 루프…2) useEffect React의 내장 훅으로 사이드 이펙트를 처리하는 데 사용한다.useEffect(()=&gt; {...}, [dependencies])useEffect(() =&gt; { console.log('EFFECT RUNNING'); return () =&gt; { console.log('EFFECT CLEANUP'); };}, []); 두 가지의 인수와 같이 호출된다. 함수: 모든 컴포넌트 평가 후에 실행되어야 하는 함수 clean up함수를 반환한다. clean up 함수는 컴포넌트가 언마운트 될 때 실행된다. 혹은 다음 이펙트 함수가 실핼될 때 마다 클린 업 함수가 먼저 실행 되어 이전 이펙트를 정리한다. 지정된 의존성: 의존성으로 구성된 배열 지정된 의존성이 변경될 때마다 함수가 다시 실행된다. 컴포넌트 렌더링 주기 이후에 실행된다.import React, { useState, useEffect } from 'react';import Login from './components/Login/Login';import Home from './components/Home/Home';import MainHeader from './components/MainHeader/MainHeader';function App() { const [isLoggedIn, setIsLoggedIn] = useState(false); // 모든 컴포넌트가 재평가된 후에 실행된다. // 혹은 의존성이 변경된 경우에만 실행된다. useEffect(() =&gt; { const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn'); if (storedUserLoggedInInformation === '1') { setIsLoggedIn(true); } }, []); const loginHandler = (email, password) =&gt; { // We should of course check email and password // But it's just a dummy/ demo anyways localStorage.setItem('isLoggedIn', '1'); setIsLoggedIn(true); }; const logoutHandler = () =&gt; { localStorage.removeItem('isLoggedIn'); setIsLoggedIn(false); }; return ( &lt;React.Fragment&gt; &lt;MainHeader isAuthenticated={isLoggedIn} onLogout={logoutHandler} /&gt; &lt;main&gt; {!isLoggedIn &amp;&amp; &lt;Login onLogin={loginHandler} /&gt;} {isLoggedIn &amp;&amp; &lt;Home onLogout={logoutHandler} /&gt;} &lt;/main&gt; &lt;/React.Fragment&gt; );}export default App; 의존성을 빈 배열로 설정하면, 의존성이 변경되는 경우가 없기 때문에 컴포넌트가 재평가된 후에 실행된다. 즉, 실제로 해당 컴포넌트가 렌더링될 때 한 번만 실행된다. (의존성이 절대 변경되지 않기 때문이다)3) 의존성import React, { useState, useEffect } from 'react';import Card from '../UI/Card/Card';import classes from './Login.module.css';import Button from '../UI/Button/Button';const Login = (props) =&gt; { const [enteredEmail, setEnteredEmail] = useState(''); const [emailIsValid, setEmailIsValid] = useState(); const [formIsValid, setFormIsValid] = useState(false); // 입련된 값이 변경되면, 유효성 검사를 다시 실행한다. useEffect(() =&gt; { setFormIsValid( enteredEmail.includes('@') &amp;&amp; enteredPassword.trim().length &gt; 6 ); }, [enteredEmail, enteredPassword]); const emailChangeHandler = (event) =&gt; { setEnteredEmail(event.target.value); }; const passwordChangeHandler = (event) =&gt; { setEnteredPassword(event.target.value); }; const submitHandler = (event) =&gt; { event.preventDefault(); props.onLogin(enteredEmail, enteredPassword); }; return ( &lt;Card className={classes.login}&gt; &lt;form onSubmit={submitHandler}&gt; &lt;div className={`${classes.control} ${ emailIsValid === false ? classes.invalid : '' }`} &gt; &lt;label htmlFor=\"email\"&gt;E-Mail&lt;/label&gt; &lt;input type=\"email\" id=\"email\" value={enteredEmail} onChange={emailChangeHandler} onBlur={validateEmailHandler} /&gt; &lt;/div&gt; &lt;div className={`${classes.control} ${ passwordIsValid === false ? classes.invalid : '' }`} &gt; &lt;label htmlFor=\"password\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" id=\"password\" value={enteredPassword} onChange={passwordChangeHandler} onBlur={validatePasswordHandler} /&gt; &lt;/div&gt; &lt;div className={classes.actions}&gt; &lt;Button type=\"submit\" className={classes.btn} disabled={!formIsValid}&gt; Login &lt;/Button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/Card&gt; );};export default Login; 이제 useEffect 함수는 enteredEmail 또는 enteredPassword가 바뀔 때마다 다시 실행된다. 일반적으로 특정 데이터, 예를 들어 어떤 state나 프롭이 변경될 때 로직을 다시 실행하기 위해서도 사용된다. 어떤 액션에 대한 응답으로 실행되는 액션이 있다면 그것은 사이드이펙트이다.4) clean up 과도한 함수 실행을 막기 위해, 디바운싱을 할 수 있다.키보드를 입력할 때마다 함수를 실행하면, 과도한 함수 실행이 될 수 있다.그래서 키보드를 입력 후, 특정 시간이 지나도 다시 키보드 입력이 발생하지 않으면 키보드 입력이 끝난 것으로 인식하고 함수를 실행 시키는 로직을 구현할 수 있다.// 위의 useEffect를 다음과 같이 수정할 수 있다. useEffect(() =&gt; { const identifier = setTimeout(() =&gt; { setFormIsValid( enteredEmail.includes('@') &amp;&amp; enteredPassword.trim().length &gt; 6 ); }, 500); // clean up 함수 return () =&gt; { clearTimeout(identifier); }; }, [enteredEmail, enteredPassword]); setTimeout은 일정 시간이 지난 후에 함수가 실행되도록 처리하는 역할을 한다. clearTimeout은 setTimeout을 취소하는 역할을 한다. useEffect와 유사한 useLayoutEffect()라는 훅이 존재한다. 둘의 차이는 함수가 실행되는 시기의 차이이다. useLayOutEffect(): Dom에 렌더링 되고 페인팅 되기 직전에 실행 useEffect(): 페인팅 이후 실행 2. useReducer state관리를 도와주는 훅이다.state가 복잡하다면 useReducer()를 사용할 수 있다.1) useReducer()const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn); state: 최신의 state 값 dispatchFn: action을 dispatch 한다. reducerFn: 최근 state를 가져오는 함수 dispatch 요청을 감지후 상태, 액션을 전달받아 조건 처리한 다음 결과 값으로 상태를 반환한다. action은 type을 가진 자바스크립트 객체의 형태로 필요한 경우 payload를 전달할 수 있다. (prevState, action) =&gt; newState initialState: 초기 값 initFn: 초기 state를 설정하기 위해 실행하는 함수import React, { useState, useEffect, useReducer } from 'react';import Card from '../UI/Card/Card';import classes from './Login.module.css';import Button from '../UI/Button/Button';// reducerFn: 새로운 state를 반환한다. const emailReducer = (state, action) =&gt; { if (action.type === 'USER_INPUT') { return { value: action.val, isValid: action.val.includes('@') }; } if (action.type === 'INPUT_BLUR') { return { value: state.value, isValid: state.value.includes('@') }; } return { value: '', isValid: false };};const passwordReducer = (state, action) =&gt; { if (action.type === 'USER_INPUT') { return { value: action.val, isValid: action.val.trim().length &gt; 6 }; } if (action.type === 'INPUT_BLUR') { return { value: state.value, isValid: state.value.trim().length &gt; 6 }; } return { value: '', isValid: false };};const Login = (props) =&gt; { const [formIsValid, setFormIsValid] = useState(false); // useReducer 활용 const [emailState, dispatchEmail] = useReducer(emailReducer, { value: '', isValid: null, }); const [passwordState, dispatchPassword] = useReducer(passwordReducer, { value: '', isValid: null, }); const emailChangeHandler = (event) =&gt; { // 값을 업데이트 할 때, dispatch. dispatchEmail({type: 'USER_INPUT', val: event.target.value}); }; const passwordChangeHandler = (event) =&gt; { // 값을 업데이트 할 때, dispatch. dispatchPassword({ type: 'USER_INPUT', val: event.target.value }; const validateEmailHandler = () =&gt; { dispatchEmail({type: 'INPUT_BLUR'}); }; const validatePasswordHandler = () =&gt; { dispatchPassword({ type: 'INPUT_BLUR' }); }; // useEffect const { isValid: emailIsValid } = emailState; const { isValid: passwordIsValid } = passwordState; useEffect(() =&gt; { const identifier = setTimeout(() =&gt; { setFormIsValid(emailIsValid &amp;&amp; passwordIsValid); }, 500); return () =&gt; { clearTimeout(identifier); }; }, [emailIsValid, passwordIsValid]); const submitHandler = (event) =&gt; { event.preventDefault(); props.onLogin(emailState.value, enteredPassword); }; return ( &lt;Card className={classes.login}&gt; &lt;form onSubmit={submitHandler}&gt; &lt;div className={`${classes.control} ${ emailState.isValid === false ? classes.invalid : '' }`} &gt; &lt;label htmlFor=\"email\"&gt;E-Mail&lt;/label&gt; &lt;input type=\"email\" id=\"email\" value={emailState.value} onChange={emailChangeHandler} onBlur={validateEmailHandler} /&gt; &lt;/div&gt; &lt;div className={`${classes.control} ${ passwordIsValid === false ? classes.invalid : '' }`} &gt; &lt;label htmlFor=\"password\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" id=\"password\" value={enteredPassword} onChange={passwordChangeHandler} onBlur={validatePasswordHandler} /&gt; &lt;/div&gt; &lt;div className={classes.actions}&gt; &lt;Button type=\"submit\" className={classes.btn} disabled={!formIsValid}&gt; Login &lt;/Button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/Card&gt; );};export default Login; 개별 state를 관리하는 데에는 useState()가 적합하다. 연관된 state 조각으로 구성된 state 관련 데이터를 다루면 useReducer()사용이 편하다.3. useContext useContext는 vue3의 provide/inject와 유사한 개념이다.1) Props 드릴링일반적으로 데이터는 props를 통해 컴포넌트에 전달된다. 프로젝트의 사이즈가 커지면 props를 전달하는 경로가 길어질 수 있다.앱의 규모가 커지고 컴포넌트 트리의 중첩도가 깊어짐에 따라 상태 관리가 어려워진다. props를 아래 방향으로 한 단계씩 전달 하기 때문에 불필요하게 중간에서 전달 받아 다시 아래 방향으로 전달하는 경우도 빈번하게 발생하게 된다. useContext는 props를 실제로 필요한 컴포넌트에서만 사용할 수 있도록 한다. 이를 위해 컴포넌트 전체에 사용할 수 있는 리액트에 내장된 내부적인 state 저장소가 존재한다. 이를 사용하면 긴 props 체인없이 관련된 컴포넌트에 직접 전달할 수 있다.2) contextAPI공식문서Store 생성 파일 이름을 케밥케이스의 형태로 저장한다. store &gt; auth-context.js 파스칼 형태로 저장하면 컴포넌트와 헷갈릴 수 있기 때문이다.// src/store/auth-context.jsimport React from 'react';const AuthContext = React.createContext({ isLoggedIn: false onLogout: () =&gt; {}});export default AuthContext; createContext: 컨텍스트 객체를 생성한다. 컴포넌트가 되거나 컴포넌트를 포함하는 객체가 된다.컨텍스트 공급자// src/App.jsimport React, { useState, useEffect } from 'react';import Login from './components/Login/Login';import Home from './components/Home/Home';import MainHeader from './components/MainHeader/MainHeader';import AuthContext from './store/auth-context';function App() { const [isLoggedIn, setIsLoggedIn] = useState(false); const logoutHandler = () =&gt; { localStorage.removeItem('isLoggedIn'); setIsLoggedIn(false); };// ... 생략 return ( &lt;AuthContext.Provider value= &gt; &lt;MainHeader /&gt; &lt;main&gt; {!isLoggedIn &amp;&amp; &lt;Login onLogin={loginHandler} /&gt;} {isLoggedIn &amp;&amp; &lt;Home onLogout={logoutHandler} /&gt;} &lt;/main&gt; &lt;/AuthContext.Provider&gt; );}export default App; 생성된 컨텍스트 객체는 Provider 컴포넌트를 포함하여 이 컴포넌트를 통해 하위 컴포넌트에게 값을 공급한다. JSX로 감싸서 값을 공급한다. 감싸지지 않은 컴포넌트는 리스닝할 수 없다. value로 context에 저장된 값을 전달한다. (모든 자식 컴포넌트에서 리스닝할 수 있다.) 컴포넌트에서 context를 업데이트 해야 할 때가 있다. 그럴 때는 context를 통해 매서드를 보내면 된다. 변경이 잦은 경우에는, 리액트 컨텍스트는 그다지 적합하지 않다. 컨텍스트 수요자import React, { useContext } from 'react';import AuthContext from '../../store/auth-context';import classes from './Navigation.module.css';const Navigation = (props) =&gt; { const ctx = useContext(AuthContext); return ( &lt;AuthContext.Consumer&gt; {(context)=&gt; { return ( // 반환하는 JSX 코드 ) }} &lt;/AuthContext.Consumer&gt; );};export default Navigation; 콜백함수의 매개변수로 context가 전달되고 이를 사용할 수 있다. useContext를 사용하면 더 깔끔하게 코딩이 가능하다.3) useContext useContext는 컨텍스트를 활용하고 리스닝할 수 있게 해준다.import React, { useContext } from 'react';import classes from './Navigation.module.css';const Navigation = (props) =&gt; { const ctx = useContext(AuthContext); return ( &lt;nav className={classes.nav}&gt; &lt;ul&gt; {ctx.isLoggedIn &amp;&amp; ( &lt;li&gt; &lt;a href=\"/\"&gt;Users&lt;/a&gt; &lt;/li&gt; )} {ctx.isLoggedIn &amp;&amp; ( &lt;li&gt; &lt;a href=\"/\"&gt;Admin&lt;/a&gt; &lt;/li&gt; )} {ctx.isLoggedIn &amp;&amp; ( &lt;li&gt; &lt;button onClick={props.onLogout}&gt;Logout&lt;/button&gt; &lt;/li&gt; )} &lt;/ul&gt; &lt;/nav&gt; );};export default Navigation;4) provider 컴포넌트 많은 로직을 사용할 경우, provider 컴포넌트를 구현하여 사용할 수 있다.import React, { useState, useEffect } from 'react';const AuthContext = React.createContext({ isLoggedIn: false, onLogout: () =&gt; {}, onLogin: (email, password) =&gt; {}});export const AuthContextProvider = (props) =&gt; { const [isLoggedIn, setIsLoggedIn] = useState(false); useEffect(() =&gt; { const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn'); if (storedUserLoggedInInformation === '1') { setIsLoggedIn(true); } }, []); const logoutHandler = () =&gt; { localStorage.removeItem('isLoggedIn'); setIsLoggedIn(false); }; const loginHandler = () =&gt; { localStorage.setItem('isLoggedIn', '1'); setIsLoggedIn(true); }; return ( &lt;AuthContext.Provider value= &gt; {props.children} &lt;/AuthContext.Provider&gt; );};export default AuthContext; 관련 state를 이 별도의 공급자 컴포넌트에서 관리한다. AuthContextProvider 컴포넌트에서 전체 로그인 state를 관리할 수도 있다. 한 곳에 다 모여있기 때문에 앱 컴포넌트가 더 간결해진다. // src/app.jsimport React, { useContext } from 'react';import Login from './components/Login/Login';import Home from './components/Home/Home';import MainHeader from './components/MainHeader/MainHeader';import AuthContext from './store/auth-context';function App() { const ctx = useContext(AuthContext); return ( &lt;React.Fragment&gt; &lt;MainHeader /&gt; &lt;main&gt; {!ctx.isLoggedIn &amp;&amp; &lt;Login /&gt;} {ctx.isLoggedIn &amp;&amp; &lt;Home /&gt;} &lt;/main&gt; &lt;/React.Fragment&gt; );}export default App;// src/index.jsimport React from 'react';import ReactDOM from 'react-dom/client';import './index.css';import App from './App';import { AuthContextProvider } from './store/auth-context';const root = ReactDOM.createRoot(document.getElementById('root'));root.render( &lt;AuthContextProvider&gt; &lt;App /&gt; &lt;/AuthContextProvider&gt;);" }, { "title": "04-Fragments-Portals-useRef", "url": "/posts/react04/", "categories": "WEB, React", "tags": "React", "date": "2022-08-31 00:00:00 +0900", "snippet": "강의 링크1. Fragments1) 필요성JSX 제한 사항// root요소는 1개여야 한다. return ( &lt;h2&gt;Root&lt;/h2&gt; &lt;p&gt;ERROR!!!&lt;/p&gt;) 자바스크립트는 둘 이상을 반환할 수 없기 때문이다. 즉, 단 1개의 리액트 createElement 호출만 반환되어야 한다.해결방안1 div로 묶기// root요소는 1개여야 한다. return ( &lt;div&gt; &lt;h2&gt;Root&lt;/h2&gt; &lt;p&gt;ERROR!!!&lt;/p&gt; &lt;/div&gt;) 그러나 div지옥이 발생할 수 있다는 문제가 있다.해결방안2 배열 사용하기// 일반적으로 사용되지 않는 방법이다. return ( [ &lt;h2 key=\"h2\"&gt;Root&lt;/h2&gt; &lt;p key=\"p\"&gt;ERROR!!!&lt;/p&gt; ])2) wrapper wrapper 컴포넌트를 추가하여 위에서 언급된 문제를 해결할 수 있다.// 빈 컴포넌트 이다. // props.children을 반환한다.const Wrapper = props =&gt; { return props.children;};export default Wrapper; JSX 요구사항을 충족하기 위해 있는 div태그의 대안으로 사용할 수 있다. 빈컴포넌트이기 때문에 DOM에 아무것도 렌더링 하지 않는다.3) Fragmentss 리액트에는 wrapper 컴포넌트인 Fragments 컴포넌트를 제공한다.import {Frament} from \"react\"return ( &lt;Frament&gt; &lt;h2 key=\"h2\"&gt;Root&lt;/h2&gt; &lt;p key=\"p\"&gt;ERROR!!!&lt;/p&gt; &lt;/Frament&gt;) Frament를 사용하면 더 깔끔한 코드를 작성할 수 있다. 최종 페이지에 불필요한 HTML 요소들이 줄어든다.2. Portals vue3의 teleport와 유사한 개념이다.1) 필요성import {Frament} from \"react\"return ( &lt;Frament&gt; &lt;MyModal /&gt; &lt;MyInputForm /&gt; &lt;/Frament&gt;) 기본적으로 Modal은 페이지 위에 표시되는 오버레이다. 실제 DOM에 표시 될 때, 현재의 구조로는 페이지에 대한 오버레이로 인식하지는 않을 것이다. ex) 스크린 리더가 렌더링되는 HTML 코드를 해석할 때 일반적인 오버레이라고 인식하지 않는다. HTML문서를 보았을 때, Modal이 해당 페이지에 대한 오버레이인지를 확실히 표현해야 한다.2) 사용법 해당 컴포넌트의 HTML 내용을 다른 곳으로 포털, 즉 이동시킬 수 있다.import {Frament} from \"react\"import {createPortal} from \"react-dom\"const MyModal = (props) =&gt; { return( &lt;Frament&gt;\t {createPortal(렌더링 되어야 하는 노드, 렌더링 되어야할 실제 DOM 컨테이너)} &lt;/Frament&gt; )} 포털에는 두 가지가 필요하다. 컴포넌트를 이동시킬 장소 컴포넌트에게 그 곳에 포털을 가져야 한다고 알려줘야 한다. createPortal 메서드는 2개의 인수를 취한다. 렌더링 되어야 하는 리액트 노드 포인터 (렌더링 되어야 하는 실제 DOM 컨테이너) =&gt; document.getElementById()로 접근할 수 있다. 3. useRef 직접 DOM 요소에 접근하여 작업할 수 있다.공식문서// state 없이 input 다루기import React, { useState, useRef } from 'react';import Card from '../UI/Card';import Button from '../UI/Button';import Wrapper from '../Helpers/Wrapper';import classes from './AddUser.module.css';const AddUser = (props) =&gt; { const nameInputRef = useRef(); const ageInputRef = useRef(); const addUserHandler = (event) =&gt; { event.preventDefault(); const enteredName = nameInputRef.current.value; const enteredUserAge = ageInputRef.current.value; props.onAddUser(enteredName, enteredUserAge); nameInputRef.current.value = ''; ageInputRef.current.value = ''; }; return ( &lt;Wrapper&gt; &lt;Card className={classes.input}&gt; &lt;form onSubmit={addUserHandler}&gt; &lt;label htmlFor=\"username\"&gt;Username&lt;/label&gt; &lt;input id=\"username\" type=\"text\" ref={nameInputRef} /&gt; &lt;label htmlFor=\"age\"&gt;Age (Years)&lt;/label&gt; &lt;input id=\"age\" type=\"number\" ref={ageInputRef} /&gt; &lt;Button type=\"submit\"&gt;Add User&lt;/Button&gt; &lt;/form&gt; &lt;/Card&gt; &lt;/Wrapper&gt; );};export default AddUser; ref의 반환 값은 객체로 current속성을 가지고 있다. current 속성에 연결된 실제 DOM 노드를 가져온다. 해당 노드를 조작, 작업할 수 있다. 리액트 없이 DOM을 조작할 수 있다. ref로 제어되는 컴포넌트는 리액트로 제어되지 않는 컴포넌트라고 부른다. 주로 노드 참조 목적으로 사용되지만, 컴포넌트 렌더링에 영향을 끼치지 않는 값을 참조하기 위해 사용된다. useState와 달리 current 값이 변경되어도 컴포넌트가 다시 렌더링되지 않는다. 불필요한 렌더링을 방지하여 성능을 최적화 할 수 있다. " }, { "title": "03-컴포넌트-스타일링", "url": "/posts/react03/", "categories": "WEB, React", "tags": "React", "date": "2022-08-30 00:00:00 +0900", "snippet": "강의 링크1. 동적 스타일1) 동적 인라인 스타일공백을 입력하면 테두리 색이 변하는 input 컴포넌트를 만들어보자.import React, { useState } from 'react';import Button from '../../UI/Button/Button';import './CourseInput.css';const CourseInput = props =&gt; { const [enteredValue, setEnteredValue] = useState(''); const [isValid, setIsValid] = useState(true); const goalInputChangeHandler = event =&gt; { if (event.target.value.trim().length &gt; 0) { setIsValid(true); } setEnteredValue(event.target.value); }; const formSubmitHandler = event =&gt; { event.preventDefault(); if (enteredValue.trim().length === 0) { setIsValid(false); return; } props.onAddGoal(enteredValue); }; return ( &lt;form onSubmit={formSubmitHandler}&gt; &lt;div className=\"form-control\"&gt; {/* state를 활용한 동적 인라인 스타일*/} &lt;label style=&gt;Course Goal&lt;/label&gt; &lt;input style= type=\"text\" onChange={goalInputChangeHandler} /&gt; &lt;/div&gt; &lt;Button type=\"submit\"&gt;Add Goal&lt;/Button&gt; &lt;/form&gt; );};export default CourseInput; 인라인 스타일은 객체의 key-value로 추가할 수 있다. key는 카멜 표기법으로 입력한다. 삼항 연산자를 활용하여 조건에 따라 state의 값이 변하고 state 값에 따라 스타일을 다르게 설정할 수 있다. 그러나 이 방법은 인라인으로 사용되기 때문에, CSS에 최우선 순위가 되어 모든 스타일에 오버라이드 된다.2) 동적 CSS 클래스특정 클래스에 CSS 스타일을 지정하고 클래스를 state에 따라 변경시켜 스타일을 동적으로 바꿀 수 있다.import React, { useState } from 'react';import Button from '../../UI/Button/Button';import './CourseInput.css';const CourseInput = props =&gt; { const [enteredValue, setEnteredValue] = useState(''); const [isValid, setIsValid] = useState(true); const goalInputChangeHandler = event =&gt; { if (event.target.value.trim().length &gt; 0) { setIsValid(true); } setEnteredValue(event.target.value); }; const formSubmitHandler = event =&gt; { event.preventDefault(); if (enteredValue.trim().length === 0) { setIsValid(false); return; } props.onAddGoal(enteredValue); }; return ( &lt;form onSubmit={formSubmitHandler}&gt; {/* state를 활용한 동적 클래스*/} &lt;div className={`form-control ${!isValid ? 'invalid' : ''}`}&gt; &lt;label&gt;Course Goal&lt;/label&gt; &lt;input type=\"text\" onChange={goalInputChangeHandler} /&gt; &lt;/div&gt; &lt;Button type=\"submit\"&gt;Add Goal&lt;/Button&gt; &lt;/form&gt; );};export default CourseInput; 이렇게 css파일로 작업할 때 클래스만으로도 작업할 수 있다.2. Styled Components공식문서컴포넌트 파일에 css파일들을 임포트하여 사용하면, 해당 스타일의 범위를 import한 컴포넌트에만 국한시키지는 않는다.css 파일은 전역적으로 영향을 미친다. 프로젝트가 커지면 많은 사람들이 같은 코드에서 작업을 하게 되고 이는 css 선택자가 중복될 수도 있다는 의미이다.Styled Components는 이와 같은 문제를 해결할 수 있다.1) 기본 개념 Styled Components는 스타일이 첨부되는 컴포넌트에만 영향을 미치고 다른 컴포넌트에는 전혀 영향을 미치지 않는다.$ npm install --save styled-compontsStyled Component는 설정한 스타일을 보고 생성된 클래스 이름을 생성하고 컴포넌트에 적용한다.모든 클래스는 고유한 이름을 갖기 때문에 앱에 있는 다른 컴포넌트에 영향을 주지 않는다.import styled from 'styled-components';// button은 Styled 객체의 메서드이다. // ()를 사용하여 호출 하는 대신 ``를 사용하여 호출한다. const Button = styled.button` font: inherit; padding: 0.5rem 1.5rem; border: 1px solid #8b005d; color: white; background: #8b005d; box-shadow: 0 0 4px rgba(0, 0, 0, 0.26); cursor: pointer; &amp;:focus { outline: none; } &amp;:hover, &amp;:active { background: #ac0e77; border-color: #ac0e77; box-shadow: 0 0 8px rgba(0, 0, 0, 0.26); }`;export default Button; button 메서드는 새로운 button 컴포넌트를 반환한다. 백틱 사이에 있는 요소들이 매개변수로 전달되어 해당 스타일이 있는 button 컴포넌트를 반환 가상 선택자의 경우 &amp;:기호를 통해 사용할 수 있다.2) Props와의 연결import React, { useState } from 'react';import styled from 'styled-components';import Button from '../../UI/Button/Button';import './CourseInput.css';const FormControl = styled.div` margin: 0.5rem 0; &amp; label { font-weight: bold; display: block; margin-bottom: 0.5rem; color: ${props =&gt; (props.invalid ? 'red' : 'black')}; } &amp; input { display: block; width: 100%; border: 1px solid ${props =&gt; (props.invalid ? 'red' : '#ccc')}; background: ${props =&gt; (props.invalid ? '#ffd7d7' : 'transparent')}; font: inherit; line-height: 1.5rem; padding: 0 0.25rem; } &amp; input:focus { outline: none; background: #fad0ec; border-color: #8b005d; }`;const CourseInput = props =&gt; { const [enteredValue, setEnteredValue] = useState(''); const [isValid, setIsValid] = useState(true); const goalInputChangeHandler = event =&gt; { if (event.target.value.trim().length &gt; 0) { setIsValid(true); } setEnteredValue(event.target.value); }; const formSubmitHandler = event =&gt; { event.preventDefault(); if (enteredValue.trim().length === 0) { setIsValid(false); return; } props.onAddGoal(enteredValue); }; return ( &lt;form onSubmit={formSubmitHandler}&gt; &lt;FormControl invalid={!isValid}&gt; &lt;label&gt;Course Goal&lt;/label&gt; &lt;input type=\"text\" onChange={goalInputChangeHandler} /&gt; &lt;/FormControl&gt; &lt;Button type=\"submit\"&gt;Add Goal&lt;/Button&gt; &lt;/form&gt; );};export default CourseInput; &amp;: 해당 태그안에 있는 것에 대해 얘기하고 있어 라고 선언하는 것이다. (중첩 선택자) styled Component 함수에 의해 반환되는 컴포넌는 props를 전달받아 백틱 내부에서 사용할 수 있다. 이렇게 styled 컴포넌트에 전달되는 일부 props에 따라 스타일을 동적인 방식으로 바꿀 수 있다.3) 미디어 쿼리import styled from 'styled-components';const Button = styled.button` width: 100%; font: inherit; padding: 0.5rem 1.5rem; border: 1px solid #8b005d; color: white; background: #8b005d; box-shadow: 0 0 4px rgba(0, 0, 0, 0.26); cursor: pointer; @media (min-width: 768px) { width: auto; } &amp;:focus { outline: none; } &amp;:hover, &amp;:active { background: #ac0e77; border-color: #ac0e77; box-shadow: 0 0 8px rgba(0, 0, 0, 0.26); }`;export default Button; Styled Component에 미디어 쿼리를 설정할 수도 있다.3. CSS Moudule 전역 스타일을 쓰지 않고 CSS 파일과 JS를 분리해서 사용하고 싶다면 CSS Module을 사용하면 된다.css모듈은 그 기능을 지원하도록 설정된 프로젝트에서만 사용가능한데 브라우저에서 코드가 실행되기 전에 코드의 변환이 필요하기 때문이다.css클래스나 css파일을 가지고 그 클래스 이름을 고유하게 바꾸어 css파일에서 설정한 css스타일의 범위가 이 파일에 임포트하는 컴포넌트에 한정되게 해준다.1) 기본 개념import React from 'react';import styles from './Button.module.css';const Button = props =&gt; { return ( // className에 styles객체의 button 클래스를 넣는다. &lt;button type={props.type} className={styles.button} onClick={props.onClick}&gt; {props.children} &lt;/button&gt; );};export default Button; css파일 이름 뒤에 .module을 붙여야 한다. 이것은 기본적으로 css모듈이 작동하도록 코드를 변환하라고 컴파일 프로세스에게 보내는 신호이다. styles라는 객체의 형태로 import된다. styles객체에는 클래스 명을 key로 접근할 수 있다. 실제로 돔에는 컴포넌트이름_ 클래스 이름_ 고유한 해시값으로 클래스 이름이 생성된다. ex) class=\"Button_button_2lgkf\" 2) 동적 스타일import React, { useState } from 'react';import Button from '../../UI/Button/Button';import styles from './CourseInput.module.css';const CourseInput = props =&gt; { const [enteredValue, setEnteredValue] = useState(''); const [isValid, setIsValid] = useState(true); const goalInputChangeHandler = event =&gt; { if (event.target.value.trim().length &gt; 0) { setIsValid(true); } setEnteredValue(event.target.value); }; const formSubmitHandler = event =&gt; { event.preventDefault(); if (enteredValue.trim().length === 0) { setIsValid(false); return; } props.onAddGoal(enteredValue); }; return ( &lt;form onSubmit={formSubmitHandler}&gt; {*/ CSS Modules을 활용한 동적 클래스 /*} &lt;div className={`${styles['form-control']} ${!isValid &amp;&amp; styles.invalid}`} &gt; &lt;label&gt;Course Goal&lt;/label&gt; &lt;input type=\"text\" onChange={goalInputChangeHandler} /&gt; &lt;/div&gt; &lt;Button type=\"submit\"&gt;Add Goal&lt;/Button&gt; &lt;/form&gt; );};export default CourseInput; 만약 클래스 이름에 -가 있다면, styles['form-control']로 접근할 수 있다." }, { "title": "02-컴포넌트-리스트-및-조건부-렌더링", "url": "/posts/react02/", "categories": "WEB, React", "tags": "React", "date": "2022-08-30 00:00:00 +0900", "snippet": "강의 링크반복 렌더링 공식문서 / 조건부 렌더링 공식문서1. 반복 렌더링1) map메서드를 활용하여 반복 렌더링 하기이전 코드import ExpenseItem from \"./ExpenseItem\";import Card from \"./Card\";function Expenses({ expenses }) { return ( &lt;div&gt; &lt;Card className=\"expenses\"&gt; &lt;ExpenseItem title={expenses[0].title} amount={expenses[0].amount} date={expenses[0].date} /&gt; &lt;ExpenseItem title={expenses[1].title} amount={expenses[1].amount} date={expenses[1].date} /&gt; &lt;ExpenseItem title={expenses[2].title} amount={expenses[2].amount} date={expenses[2].date} /&gt; &lt;ExpenseItem title={expenses[3].title} amount={expenses[3].amount} date={expenses[3].date} /&gt; &lt;/Card&gt; &lt;/div&gt; );}export default Expenses;위와 같이 하드 코딩을 통해 구현하지 않고, 리스트의 map 매서드를 사용하면 간편하게 반복 랜더링을 할 수 있다.import ExpenseItem from \"./ExpenseItem\";import Card from \"./Card\";function Expenses({ expenses }) { return ( &lt;div&gt; &lt;Card className=\"expenses\"&gt; {expenses.map((expense) =&gt; ( &lt;ExpenseItem title={expenses.title} amount={expense.amount} date={expense.date} /&gt; ))} &lt;/Card&gt; &lt;/div&gt; );}export default Expenses; 주의! forEach와 같이 return이 없는 매서드는 반복 렌더링이 불가능하다. jsx를 반환해야 해당 요소가 렌더링 된다는 점을 잊지 말자.2) keyimport ExpenseItem from \"./ExpenseItem\";import Card from \"./Card\";function Expenses({ expenses }) { return ( &lt;div&gt; &lt;Card className=\"expenses\"&gt; {expenses.map((expense) =&gt; ( &lt;ExpenseItem key={expenses.id} title={expenses.title} amount={expense.amount} date={expense.date} /&gt; ))} &lt;/Card&gt; &lt;/div&gt; );}export default Expenses;목록의 아이템을 매핑 할 때는 각 item을 구분할 수 있도록 하는 key속성이 필요하다. 해당 속성을 추가하지 않을 시 아래와 같은 에러 메시지가 뜬다.즉, html 요소에 key를 추가하여 리액트가 개별 아이템을 인식할 수 있도록 돕는다.2. 조건부 렌더링 조건에 따라 컴포넌트를 렌더링 한다.1) 삼항 연산자import ExpenseItem from \"./ExpenseItem\";import Card from \"./Card\";function Expenses({ expenses }) { return ( &lt;div&gt; &lt;Card className=\"expenses\"&gt; {/* expenses 배열의 길이에 따라 렌더링이 다르다. */} {expenses.length === 0 ? ( &lt;p&gt;No expenses found.&lt;/p&gt; ) : ( expenses.map((expense) =&gt; ( &lt;ExpenseItem key={expense.id} title={expenses.title} amount={expense.amount} date={expense.date} /&gt; )) )} &lt;/Card&gt; &lt;/div&gt; );}export default Expenses; 삼항 연산자를 활용하여 조건부 렌더링이 가능하다. if문은 {}안 에서 사용할 수 없다.2) &amp;&amp;{expenses.length === 0 &amp;&amp; &lt;p&gt;No expenses found.&lt;/p&gt;}{expenses.length &gt; 0 &amp;&amp; expenses.map((expense) =&gt; ( &lt;ExpenseItem key={expense.id} title={expenses.title} amount={expense.amount} date={expense.date} /&gt;))} &amp;&amp;를 활용하여 긴 조건부 표현 식을 두 개의 독립 표현식으로 나눌 수 있다. 앞의 조건 식을 만족하면 &amp;&amp;뒤의 코드를 반환한다.3) 변수 활용import ExpenseItem from \"./ExpenseItem\";import Card from \"./Card\";function Expenses({ expenses }) { let expensesContent = &lt;p&gt;No expenses found.&lt;/p&gt;; if (expenses.length &gt; 0) { expensesContent = expenses.length &gt; 0 &amp;&amp; expenses.map((expense) =&gt; ( &lt;ExpenseItem key={expense.id} title={expenses.title} amount={expense.amount} date={expense.date} /&gt; )); } return ( &lt;div&gt; &lt;Card className=\"expenses\"&gt; {expensesContent} &lt;/Card&gt; &lt;/div&gt; );}export default Expenses; 로직을 사용하여, 조건에 따라 변수의 값을 다르게 지정한다. 컴포넌트는 조건에 따라 다른 값을 가진 변수(JSX)를 반환한다.4) 조건 returnimport ExpenseItem from './ExpenseItem';const ExpensesList = (props) =&gt; { if (props.items.length === 0) { return &lt;h2 className='expenses-list__fallback'&gt;Found no expenses.&lt;/h2&gt;; } return ( &lt;ul className='expenses-list'&gt; {props.items.map((expense) =&gt; ( &lt;ExpenseItem key={expense.id} title={expense.title} amount={expense.amount} date={expense.date} /&gt; ))} &lt;/ul&gt; );};export default ExpensesList; JSX 블럭을 반환하는 곳에 if문을 추가할 수 있다. 아예 조건에 따라 렌더링을 할 수 있다. 해당 컴포넌트가 조건에 따라 반환하는 값을 다르게 한다." }, { "title": "01-상태관리를-통한-동적인-페이지-구현", "url": "/posts/react01/", "categories": "WEB, React", "tags": "React", "date": "2022-08-29 00:00:00 +0900", "snippet": "강의 링크state를 활용한 동적 페이지 상태를 선언한다. 리액트의 이벤트와 바인드 한다. 모델이 변경됨을 감지한 후, 변경된 부분만 DOM에 반영한다.## 1. Event// 컴포넌트: 자바스크립트 함수일 뿐이다.import \"./ExpenseItem.css\";import ExpenseDate from \"./ExpenseDate\";import Card from \"./Card\";const ExpenseItem = ({ title, amount, date }) =&gt; { const clickHandler = () =&gt; { console.log(\"Clicked!\"); }; return ( // class는 자바스크립트 예약어이기 떄문에 불가능하다. &lt;Card className=\"expense-item\"&gt; &lt;ExpenseDate date={date} /&gt; &lt;div className=\"expense-item__description\"&gt; &lt;h2&gt;{title}&lt;/h2&gt; &lt;div className=\"expense-item__price\"&gt;${amount}&lt;/div&gt; &lt;/div&gt; {/* 이벤트 수신: 리액트는 모든 기본 이벤트를 on으로 시작하는 props로 수신할 수 있다. */} &lt;button onClick={clickHandler}&gt;Change Title&lt;/button&gt; &lt;/Card&gt; );};export default ExpenseItem; 이벤트를 수신함으로서, 유저의 행동에 따라 웹사이트가 변하는 동적인 웹사이트를 구현할 수 있다. 이벤트에 따른 리랜더링(화면에서의 컴포넌트 변경)을 위해서는 state라는 개념이 필요하다. 변화하는 데이터가 사용자 인터페이스에 반영하려면 state가 필요하다. 반응성 추가 특정 컴포넌트가 재평가 되어야 한다고 리액트에게 알린다. 일반적인 변수는 값이 변경되어도 재평가를 유발하지 않는다. 2. useState 컴포넌트가 다시 호출 되는 곳에서 변경된 값을 반영하기 위해 state로 값을 정의할 수 있게 하는 함수이다.외부에서 데이터를 전달 받는 pops의 경우 read-only이다. 함수형 컴포넌트는 자체적으로 상태(변경 가능한 데이터)를 가지지 못하기 때문에 useState를 활용하여 state를 구현한다. state는 컴포넌트가 소유한 로컬 데이터로 적용 범위는 현재 컴포넌트에 한정된다.1) 기본 개념import React, { useState } from \"react\";import \"./ExpenseItem.css\";import ExpenseDate from \"./ExpenseDate\";import Card from \"./Card\";const ExpenseItem = (props) =&gt; { // const [변수, 업데이트 함수] = useState(기본값) const [title, setTitle] = useState(props.title); // 클릭시, title의 값을 변경한다. const clickHandler = () =&gt; { setTitle(\"Updated!\"); }; return ( &lt;Card className=\"expense-item\"&gt; &lt;ExpenseDate date={props.date} /&gt; &lt;div className=\"expense-item__description\"&gt; &lt;h2&gt;{title}&lt;/h2&gt; &lt;div className=\"expense-item__price\"&gt;${props.amount}&lt;/div&gt; &lt;/div&gt; &lt;button onClick={clickHandler}&gt;Change Title&lt;/button&gt; &lt;/Card&gt; );};export default ExpenseItem; 초기값은 초기 렌더링 시에만 사용된다. 이후 다시 랜더링 될 때는 이 값은 무시된다. useState()함수는 두 가지를 반환한다. state state를 업데이트 하는 함수: 예측가능성 특정 함수로만 state를 업데이트할 수 있는 이유는 변경을 예측(추적)할 수 있다. =&gt; 데이터 관리를 보다 쉽게 만든다. 등호 연산자로 state를 변경하지 않기 때문에 const를 사용해도 괜찮다.리랜더링 과정리액트는 실제 DOM이 아닌, 가상 DOM을 통해 선언된 상태를 비교 분석하여 UI를 업데이트한다.이전/ 현재 가상 DOM 트리를 비교하는 재조정 알고리즘을 통해 변경된 트리의 요소를 감지하여 해당 요소만 업데이트하여 DOM에 반영한다. 위의 예시의 경우, 클릭 시 해당 state를 변경하는 함수를 실행하고 이는 JSX 코드를 다시 평가한다. 지난번과 비교하여 감지된 변화를 화면에 랜더한다.2) 데이터 관리 state는 데이터를 저장하기 위해서 사용될 수도 있다.import React, { useState } from \"react\";import \"./ExpenseForm.css\";const ExpenseForm = () =&gt; { // 데이터를 저장하기 위해, useState를 사용할 수도 있다. // 컴포넌트 당 별도의 상태를 갖고 각각 업데이트하고 관리할 수 있다. const [enteredTitle, setEnteredTitle] = useState(\"\"); const [enteredAmount, setEnteredAmount] = useState(\"\"); const [enteredDate, setEnteredDate] = useState(\"\"); const titleChangeHandler = (event) =&gt; { setEnteredTitle(event.target.value); }; const amountChangeHandler = (event) =&gt; { setEnteredAmount(event.target.value); }; const dateChangeHandler = (event) =&gt; { setEnteredDate(event.target.value); }; return (\t// 생략 );};export default ExpenseForm; 하나의 컴포넌트가 여러 개의 state를 가질 수 있다. 그러나 객체를 사용하여 하나의 state로 관리할 수도 있다.import React, { useState } from \"react\";import \"./ExpenseForm.css\";const ExpenseForm = () =&gt; { const [userInput, setUserInput] = useState({ enteredTitle: \"\", enteredAmount: \"\", enteredDate: \"\", }); // 이전 state를 사용한다면, 아래와 같은 방식으로 사용해야 한다. const titleChangeHandler = (event) =&gt; { setUserInput((prevState) =&gt; { return { ...prevState, enteredTitle: event.target.value, }; }); }; // 스프레드 연산자와 오버라이드를 통해 useInput의 특정 키만 업데이트 // 그러나 이전 state가 최신 업데이트가 되지 않아 오류가 발생할 수도 있다. // 위의 방식이 더 좋다. const amountChangeHandler = (event) =&gt; { setUserInput({ ...userInput, enteredAmount: event.target.value, }); }; const dateChangeHandler = (event) =&gt; { setUserInput({ ...userInput, enteredDate: event.target.value, }); }; return (\t// 생략 );};export default ExpenseForm; state 업데이트가 이전 state에 의존하고 있다면, 업데이트가 오랫동안 되지 않은 state를 사용하지 않도록 해야 한다.3) 양방향 바인딩 state를 사용하여 양방향 바인딩을 구현할 수 있다. 변경되는 입력 값만 수신하는 것이 아니라 입력에 새로운 값을 다시 전달할 수도 있다.import React, { useState } from \"react\";import \"./ExpenseForm.css\";const ExpenseForm = () =&gt; { const [enteredTitle, setEnteredTitle] = useState(\"\"); const [enteredAmount, setEnteredAmount] = useState(\"\"); const [enteredDate, setEnteredDate] = useState(\"\"); const titleChangeHandler = (event) =&gt; { setEnteredTitle(event.target.value); }; const amountChangeHandler = (event) =&gt; { setEnteredAmount(event.target.value); }; const dateChangeHandler = (event) =&gt; { setEnteredDate(event.target.value); }; const submitHandler = (event) =&gt; { event.preventDefault(); const expenseData = { title: enteredTitle, amount: enteredAmount, date: new Date(enteredDate), }; console.log(expenseData); // 리셋하기 setEnteredTitle(\"\"); setEnteredAmount(\"\"); setEnteredDate(\"\"); }; return ( &lt;form className=\"new-expense__controls\" onSubmit={submitHandler}&gt; &lt;div className=\"new-expense__control\"&gt; &lt;label&gt;Title&lt;/label&gt; &lt;input type=\"text\" // 양방향 바인딩 value={enteredTitle} onChange={titleChangeHandler} /&gt; &lt;/div&gt; &lt;div className=\"new-expense__control\"&gt; &lt;label&gt;Amount&lt;/label&gt; &lt;input type=\"number\" min=\"0.01\" step=\"0.01\" // 양방향 바인딩 value={enteredAmount} onChange={amountChangeHandler} /&gt; &lt;/div&gt; &lt;div className=\"new-expense__control\"&gt; &lt;label&gt;Date&lt;/label&gt; &lt;input type=\"date\" min=\"2019-01-01\" max=\"2022-12-31\" // 양방향 바인딩 value={enteredDate} onChange={dateChangeHandler} /&gt; &lt;/div&gt; &lt;div className=\"new-expense__actions\"&gt; &lt;button type=\"submit\"&gt;Add Expense&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; );};export default ExpenseForm; input의 value 속성을 state와 연결하여 양방향으로 바인딩할 수 있다.3. Emit (데이터-끌어올리기) props와의 반대 개념으로 자식이 부모에게 데이터를 전달한다.1) 부모 컴포넌트import React from \"react\";import \"./NewExpense.css\";import ExpenseForm from \"./ExpenseForm\";const NewExpense = (props) =&gt; { const saveExpenseDataHandler = (enteredExpenseData) =&gt; { const expenseData = { ...enteredExpenseData, id: Math.random().toString(), }; // App.vue에게 emit props.onAddExpense(expenseData); }; return ( &lt;div className=\"new-expense\"&gt; {/* onSaveExpenseData라는 이벤트를 통해 자식에게 데이터를 받는다. */} &lt;ExpenseForm onSaveExpenseData={saveExpenseDataHandler} /&gt; &lt;/div&gt; );};export default NewExpense; onSaveExpenseData함수의 매개변수를 통해 데이터를 받아서 저장한다. App 컴포넌트(최상위 컴포넌트)로 데이터를 끌어올린다. 형제 컴포넌트들도 데이터를 사용하기 위해서는 결국 App.vue까지 데이터를 끌어올려야 한다. App컴포넌트에 데이터가 있으면, props를 통해 다른 컴포넌트들에게 데이터를 전달하기 용이하다. 2) 자식 컴포넌트import React, { useState } from \"react\";import \"./ExpenseForm.css\";const ExpenseForm = (props) =&gt; { // 생략 const submitHandler = (event) =&gt; { event.preventDefault(); const expenseData = { title: enteredTitle, amount: enteredAmount, date: new Date(enteredDate), }; // 데이터를 부모에게 emit props.onSaveExpenseData(expenseData); setEnteredTitle(\"\"); setEnteredAmount(\"\"); setEnteredDate(\"\"); }; return ( &lt;form className=\"new-expense__controls\" onSubmit={submitHandler}&gt; {/* 생략 */} &lt;/form&gt; );};export default ExpenseForm; props를 사용해서 부모 컴포넌트로부터 함수를 받고 자식 컴포넌트에서 그 함수를 통해 데이터를 보낸다." }, { "title": "React-특징", "url": "/posts/react00/", "categories": "WEB, React", "tags": "React", "date": "2022-08-29 00:00:00 +0900", "snippet": "공식 문서1. 선언형 프로그래밍 명령형 (HOW) 선언형 (WHAT) DOM 스크립트 기반 React, Vue 어딘가를 가야할 때 일일이 다 서술 해야 한다. 목적지만 말하면 된다. 즉, 스크립트를 작성할 때 하나하나 다 서술해 주어야 한다.(무엇을 어떻게 해야 하는지 설명한다.) 목적지를 선언 했으니, 목적지를 갈 수 있도록 도와준다. (도와주는 도구가 리액트 ,vue와 같은 도구이다. ) 선언형 프로그래밍은 로직에 집중할 수 있고 패턴화된 방식으로 설계할 수 있어서 유지보수에 용이하다.React 예시 상태를 선언한다. 리액트의 이벤트와 바인드 한다. 모델이 변경됨을 감지한 후, 변경된 부분만 DOM에 반영한다.명령적인 방식으로 DOM을 조작하는 전통적인 방식에서 벗어나, DOM 조작은 React-DOM 라이브러리에게 맡기고 개발자는 화면이 어떻게 렌더링 되기를 알려주기만 하면 된다. state에 따라 React가 Dom을 조작해서 화면에 구현하게 된다.// 바닐라 JSconst rootElem = document.getElementById(\"root\");const divElem = document.createElement(\"div\");const h2Elem = document.createElement(\"h2\");h2Elem.innerText = \"Let's get started\";divElem.appendChild(h2Elem);rootElem.appendChild(divElem);// JSX 없는 순수 Reactconst App = () =&gt; { return React.createElement( \"div\", {}, React.createElement(\"h2\", {}, \"Let's get started\") ); }// JSX 사용const App = () =&gt; { const [expenses, setExpenses] = useState(DUMMY_EXPENSES); return ( &lt;div&gt; &lt;h2&gt; Let's get started &lt;/h2&gt; &lt;/div&gt; )}2. Virtual Dom1) DOM DOM은 자바스크립트 Node 개체의 계층화된 트리이다.브라우저는 HTML 코드를 해석해서 트리 형태로 구조화된 노드들을 가지고 있는 문서를 생성한다.HTML문서가 브라우저에 의해 해석되어 실제 문서를 나타내는 노그 개체들의 트리 구조로 변환된다.즉, DOM의 목적은 jS를 사용해서 이 문서에 대한 스크립트 작성 (삭제, 추가, 바꾸기, 이벤트 처리, 수정)을 위한 프로그래밍 인터페이스를 제공한다는 것이다.2) Virtual Dom UI를 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 Real DOM과 동기화하는 프로그래밍 개념이다. 공식문서Virtual DOM이 React가 선언형 프로그래밍이 가능하도록 한다. React에게 원하는 UI를 알려주면 DOM이 그 상태와 일치하도록 한다. 즉, Virtual DOM이 실제 Real DOM을 직접 조작한다.또한, 성능면에서도 Virtual DOM을 사용하는 것이 좋을 수 있다. Real DOM을 직접 조작하는 것은 실제로 그렇게 성능에 대한 문제를 발생 시키지 않는다. 하지만 렌더링 과정 때문에 성능에 대한 이슈가 생긴다.렌더링 과정 참고 블로그 HTML parser가 HTML을 바탕으로 DOM Tree를 그린다. CSS parer가 CSS를 바탕으로 CSSOM을 그린다. DOM에 CSSOM을 적용하여 Render Tree를 그린다. Render Tree를 바탕으로 Layout, Paintng과정을 통해 실제 화면에 렌더링한다. HTML 코드를 읽다가 script태그를 만다면 파싱을 잠시 중단하고 js 파일을 로드한다.즉, DOM에 변화가 생기면 렌더 트리를 재 생성하고 레이아웃, 페인팅하는 과정이 다시 거쳐야 한다.SPA에서는 DOM 조작이 빈번하게 발생하기 때문에 브라우저가 많은 연산을 하고 전반적인 성능 이슈를 야기하게 된다.그래서 React는 변화가 발생되면 변경된 state로 Virtual DOM을 그린다. Virtual DOM은 실제 DOM이 아닌 메모리에서 연산을 하기 때문에 빠르다. 실제로 렌더링 하지 않기 때문에 연산 비용이 적다. 한 번에 묶어서 처리한다. 연산이 끝나면, 단 한 번 Virtual DOM과 Real DOM을 비교하여 변경된 사항만 반영하여 새로운 화면에 렌더링한다.사실 위의 과정은 Virtual DOM이 없어도 이루어질 수 있다. 변경 사항을 그냥 묶어서 DOM Fragment에 적용한 다음 기존 DOM에 반영 시키면 된다.Virtual DOM은 이를 자동화, 추상화 해놓은 것이다. 가장 큰 장점은 앞서 말 했듯이, 개발자가 직접 DOM을 관리하고 변화들을 동기화 하는 작업을 일일이 하지 않아도 되는 것이다. Virtual DOM이 변경 사항을 Diffing 알고리즘을 통해 비교하고 Real DOM에 자동으로 반영 시켜준다.3. 컴포넌트 시스템 React의 모든 컴포넌트는 Virtual DOM의 노드로 구성된다. 구현 방법 설명 Component Driven Development (CDD) CDD는 컴포넌트를 모듈 단위로 개발하여 UI 구축에 도달하는 개발 및 설계 방법론이다. 기본적인 컴포넌트 단위부터 시작하여 View를 구성하기 위한 점진적 결합 방식의 바텀업 성향을 보인다. Atomic Design Atomic Design은 원자, 분자, 조직체, 템플릿, 페이지로 적용해나가는 설계 방식이다. " }, { "title": "운영체제-기본-구조", "url": "/posts/operationsystem02/", "categories": "CS, 운영-체제", "tags": "cs, 운영-체제", "date": "2022-08-27 00:00:00 +0900", "snippet": "2장-운영체제-구조강의 링크1. 컴퓨터 시스템 구조 CPU 메모리에 있는 instruction을 실행한다. CPU안에는 레지스터들과 modebit이 있다. Modebit: CPU의 제어 권한이 현재 프로그램에 있는지 OS에 있는지 확인가능 인터럽트 라인을 통해 I/O Device, disk와 통신한다. Device controller에게 일을 시킨다. 일이 수행되었을 때, 인터럽트 라인을 통해 일이 끝난 것을 알게 된다. 인터럽트가 발생하면 OS에게 CPU를 넘긴다. Memory CPU의 작업 공간 CPU는 매 클럭 사이클 마다 memory에서 기계어를 읽어서 실행하게 된다. I/O Device, Disk Device를 전담하는 Device controller가 존재한다. 해당 device가 사용될 때, CPU가 Controller에게 일을 시킨다. Device controller들의 작업공간이 존재한다. 이를 Local Buffer라고 부른다. 1) Mode bit 사용자가 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치가 필요하다. Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation을 지원한다. 1: 사용자 모드로 사용자 프로그램을 수행한다. 0: 모니터 모드(커널 모드, 시스템 모드)로 OS 코드를 수행한다. 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행가능한 특권 명령으로 규졍된다. 인터럽트 발생 시 하드웨어가 Mode bit을 0으로 바꾼다. 사용자 프로그램에게 CPU를 넘기기 전에 Mode bit을 1로 세팅한다. Mode bit 설명 1 사용자 모드 제한된 instruction만 수행할 수 있다. 0 모니터 모드모든 instruction을 수행할 수 있다. ex) I/O 장치,다른 프로그램의 메모리 공간에 접근이 가능하다. 2) Timer CPU의 time sharing을 위해 필요하다. 특정 프로그램이 CPU를 독점하는 것을 막는다. (인터럽트를 발생시킴으로) 정해진 시간이 흐른 뒤, 운영체제에게 제어권이 넘기도록 인터럽트를 발생시킨다. 타이머는 매 클럭 틱 때마다 1씩 감소한다. 타이머 값이 0이 되면 타이머 인터럽트가 발생한다. 타이머는 현재 시간을 계산하기 위해서도 사용된다.즉, 타이머 인터럽트의 도움을 받아 여러 프로그램을 실행할 수 있게 된다.3) Device Controller I/O 장치를 전담하는 일종의 작은 cpu이다. (hardware) 제어 정보를 위해 control register, status register를 가진다. CPU가 일을 시킬 때, 해당 레지스터를 통해 일을 명령(제어) ex) 출력해라 Local Buffer를 가진다. (일종의 data regiseter) 실제 데이터가 담겨있다. ex) 출력할 데이터 I/O는 실제 device와 local buffer 사이에서 일어난다. Device controller는 I/O가 끝났을 경우 인터럽트를 통해 CPU에 해당 사실을 알린다.:speech_balloon: Device Driver (장치 구동기)OS 코드 중 각 장치 별 처리 루틴 (software)4) DMA Direct memory Access: 직접 메모리에 접근할 수 있는 컨트롤러 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용된다. 원래는 메모리에 접근할 수 있는 것은 CPU만 가능했지만, DMA도 접근이 가능하다. 만약 CPU와 DMA가 동시에 같은 메모리 주소에 접근한다면, Memory Controller가 중재한다. I/O 장치가 인터럽트를 너무 자주 발생 시키기 때문에 CPU가 방해를 너무 많이 받는다. 그래서 CPU의 중재 없이 DMA가 Device의 Buffer Storage의 내용을 메모리에 block 단위로 직접 전송한다. 바이트 단위가 아니라 Block 단위로 인터럽트를 발생시킨다.2. 입출력 수행 모든 입출력 명령은 특권 명령이다. 시스템 콜: 사용자 프로그램이 운영체제에게 I/O를 요청한다. trap을 사용하여 인터럽트 벡터의 특정 위치로 이동한다. 제어권이 인터럽트 벡터가 가르키는 인터럽트 서비스 루틴으로 이동된다. 올바른 I/O 요청인지 확인 후, I/O를 수행한다. I/O 완료시, 제어권을 시스템 콜 다음 명령으로 옮긴다.1) 인터럽트 현재의 운영체제는 인터럽트에 의해 구동된다. 분류 설명 Interrput 하드웨어가 발생시킨 인터럽트 Trap Exception: 프로그램이 오류를 범한 경우System call: 프로그램이 커널 함수를 호출한 경우 (사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것) 인터럽트가 발생하면, 당한 시점의 레지스터와 program counter를 save한 후, CPU의 제어를 인터럽트 처리 루틴에 넘긴다. 인터럽트 벡터: 해당 인터럽트의 처리 루틴 주소를 가지고 있다. 인터럽트 라인 별로 인터럽트 벡터가 존재한다. 인터럽트 처리 루틴 (인터럽트 핸들러): 해당 인터럽트를 처리하는 커널 함수2) 동기식 입출력과 비동기식 입출력 동기식 입출력 (Synchronous I/O) I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어간다. 구현 방법 1 I/O가 끝날 때까지 CPU를 낭비시킬 수 있다. 매 시점 하나의 I/O만 일어날 수 있다. 구현 방법 2 (구현 방법 1의 단점을 커버) I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗는다. I/O 처리를 기다리는 줄에 그 프로그램을 줄 세운다. 다른 프로그램에게 CPU를 준다. (I/O 요청을 보낸 프로그램은 어차피 현재 일을 못하기 때문에) Read의 경우 I/O 작업의 결과가 필요해야 프로그램을 사용할 수 있기 때문에 일반적으로 기다리는 경우가 많다. 비동기식 입출력 (Asynchronous I/O) I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어간다. 즉, CPU는 커널에게 I/O 작업만 요청해놓고 다시 본인 일을 하러간다. Write의 경우, 비동기적으로 처리하는 경우가 많다. 두 경우 모두 I/O의 완료는 인터럽트로 알려준다.3) 입출력 명령어 저장 공간에 따른 분류 I/O를 수행하는 special instruction에 의해 메모리와 I/O가 별개의 어드레스 영역에 할당되는 것을 의미한다. I/O를 사용하더라도 메모리의 용량은 감소하지 않는다. Memory에 접근하는 명령어의 주소, I/O에 접근하는 명령어의 주소로 나뉜다. Memory Mapped I/O 메모리와 I/O가 하나의 연속된 address 영역에 할당된다. I/O가 차지하는 만큼 메모리 용량은 감소한다. 3. 메모리1) 저장 장치 계층 구조 이름 특징 비고 Registers 빠르다, 용량이 적다, 비싸다 휘발성 , CPU에서 직접 접근이 가능하다 (바이트 단위로 접근 가능) Cache Memory (SRAM) (캐싱 : 재사용 목적) 휘발성, CPU에서 직접 접근이 가능하다 (바이트 단위로 접근 가능) Main Memory (DRAM)   휘발성, CPU에서 직접 접근이 가능하다 (바이트 단위로 접근 가능) MagneticDisk   비휘발성, CPU에서 직접 접근이 불가능하다 (섹터 단위로 접근 가능) OpticalDisk   비휘발성, CPU에서 직접 접근이 불가능하다 (섹터 단위로 접근 가능) Magnetic Tape 느리다, 용량이 많다, 싸다 비휘발성, CPU에서 직접 접근이 불가능하다 (섹터 단위로 접근 가능) 2) 프로그램의 실행 (메모리 load) 프로그램을 실행 파일 형태로 하드디스크에 저장되어 있다. 해당 프로그램을 실행시키게 되면, 해당 프로그램의 주소 공간 (address space)이 가상 메모리에 생성된다. 메모리 공간은 stack, code, data로 구성되어 있다. stack: 함수를 호출하거나 리턴할 때 데이터를 쌓아가거나 꺼내가는 공간. code: cpu에서 실행할 기계어 코드 담고 있다. data: 프로그램이 실행하는 변수와 같은 자료구조를 담고 있다. 당장 실행에 필요한 부분만 메모리로 올라가서 프로세스가 된다. 사용이 안되면 메모리에서 쫓아낸다. 3) 커널 주소 공간 Code Data (운영체제가 사용하는 자료 구조) Stack 시스템 콜, 인터럽트 처리 코드자원 관리를 위한 코드편리한 서비스 제공을 위한 코드 프로세스 관리ProcessA의 PCBProcessB의 PCB하드웨어 관리 CPU, Memory, Disck와 같은 하드웨어가 사용하는 자료 구조 Process A의 커널 스택Process B의 커널 스택… 4) 함수의 메모리 주소 모든 프로그램은 함수구조로 구성되어 있다. 사용자 정의 함수 Process A의 Address space usermode 자신의 프로그램에서 정의한 함수 라이브러리 함수 Process A의 Address space usermode 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수 자신의 프로그램의 실행 파일에 포함되어 있다. 커널 함수 Kernel Address space kernelmode 운영체제 프로그램의 함수 커널 함수의 호출 = 시스템 콜 (다른 공간에 있기 때문에 CPU 제어권을 넘겨야 한다) " }, { "title": "운영체제-기본-개념", "url": "/posts/operationsystem01/", "categories": "CS, 운영-체제", "tags": "cs, 운영-체제", "date": "2022-08-27 00:00:00 +0900", "snippet": "1장-운영체제-소개1. 운영 체제란? 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층 컴퓨터 안의 하드웨어랑 프로그램을 어떻게 잘 관리할 것인가. 협의의 운영체제 (커널) 운영체제의 핵심 부분으로 메모리에 상주하는 부분이다. 광의의 운영체제 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념이다. ex) 윈도우 운영체제 2. 운영 체제의 목적컴퓨터 하드웨어 =&gt; 운영 체제 =&gt; 각종 소프트웨어 및 사용자1) 컴퓨터 시스템의 자원을 효율적으로 관리한다. 여러 프로그램들이 자원을 어떻게 공유하고 분할해서 사용하는가. (하드웨어 자원은 이미 정해져 있다) 프로세서, 기억장치, 입출력 장치 등을 효율적으로 관리하도록 돕는다. 사용자가 형평성 있는 자원을 분배한다. 형평성 주어진 자원으로 최대한 성능을 내도록 한다. 효율성 사용자 및 운영체제 자신을 보호한다. 프로세스, 파일, 메시지 등을 관리한다. 예시 : 실행 중인 프로그램들에게 짧은 시간 씩 CPU를 번갈아 할당. 예시: 실행 중인 프로그램들에 메모리 공간을 적절히 분배.2) 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공한다. 사용자 및 소프트웨어가 직접 하드웨어에 접근하지 않으며 운영체제를 통해 하드웨어에 접근한다. 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행한다. 운영체제는 동시 사용자 / 프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같이 만든다.3. 운영체제의 분류1) 동시 작업 가능 여부 단일 작업 (single tasking) 한 번의 하나의 작업만 처리한다. ex) MS - DOS 프로프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없다. 다중 작업 (multi tasking) 동시에 두 개 이상의 작업을 처리한다. ex) UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있다. 2) 사용자의 수 여러 사용자가 동시 접근을 할 수 있는가. 단일 사용자 (single user) MS - DOS, MS WIndows 다중 사용자 (multi user) UNIX, NT server 3) 처리 방식 일괄 처리 (batch processing) 작업 요청의 일정량을 모아서 한꺼번에 처리한다. (실시간으로 처리하지 않는다.) 작업이 완전 종료될 때까지 기다려야 한다. (interative하지 않음) ex) 초기 Punch Card 처리 시스템 시분할 (time sharing) 현재의 운영체제 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용한다. 일괄 처리 시스템에 비해 짧은 응답 시간을 가진다. (interative한 방식) ex) UNIX 실시간 (Realtime OS) 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS이다. dealine이 존재한다. ex) 원자로/ 공장 제어, 미사일 제어, 반도체 장비, 로보트 제어 실시간 시스템의 개념 확장 Hard realtime system (경성 실시간 시스템) Soft realtime system (연성 실시간 시스템) 용어 설명 Multitasking 컴퓨터에서 여러 작업을 동시에 수행하는 것. MultiProgramming 컴퓨터에서 여러 작업을 동시에 수행하는 것.여러 프로그램이 메모리에 올라가 있음을 강조한다. Time sharing 컴퓨터에서 여러 작업을 동시에 수행하는 것.CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조한다. MultiProcess 컴퓨터에서 여러 작업을 동시에 수행하는 것. MultiProcessor 하나의 컴퓨터에 CPU가 여러 개 붙어 있음을 의미한다. 4. 운영체제의 예시1) 유닉스 (UNIX) 코드의 대부분을 C언어로 작성한다. C언어: 유닉스를 개발하기 위해 고안된 언어 이전에는 어셈블리어를 통해 운영체제를 개발했다. 높은 이식성, 최소한의 커널 구조 복잡한 시스템에 맞게 확장이 용이하다. 소스 코드가 공개되어 있다. 프로그램 개발에 용이하다. 다양한 버전 System V, FreeBSD, SunOS, Solaris Linux 2) MS Windows MS사의 다중 작업용 GUI 기반 운영체제 Plug and Play, 네트워크 환경을 강화했다. DOS용 응용 프로그램과 호환성을 제공한다. 풍부한 지원 소프트웨어5. 운영 체제의 구조1) 하드웨어 관리 하드웨어 운영체제 역할 CPU CPU 스케쥴링CPU를 누구에게 주어야 하는가. Memory 메모리 관리한정된 메모리를 어떻게 나눠서 사용하는가. Disk 파일 관리디스크에 파일을 어떻게 보관하는가, 디스크에도 스케쥴링이 필요함. I/O device 입출력 관리각 다른 입출력 장치와 컴퓨터 간에 어떻게 통신하는가. (인터럽트 기반) I/O 디바이스가 CPU에 비해 속도가 매우 느림. 2) 그 외 프로세스 관리 프로세스의 생성과 삭제 자원 할당 및 반환 프로세스 간 협력 보호 시스템 네트워킹 명령어 해석기" }, { "title": "03-DApp-web3를-이용하여-이더리움과-상호작용하기", "url": "/posts/nft04/", "categories": "ETC, NFT", "tags": "NFT", "date": "2022-08-26 00:00:00 +0900", "snippet": "크립토 좀비 / 크립토 좀비를 진행하면서 요약한 내용이 대다수이다. DApp: Decentralized Application 탈중앙화된 P2P 네트워크 상에 백엔드 로직이 구동되는 응용프로그램이다. 블록체인 상의 스마트 컨트랙트가 기존의 중앙화된 서버에 의해 서비스를 제공하는 시스템을 대체한다. 좀 더 좁은 의미에서 DApp은 사용자 인터페이스를 통해 블록 체인의 스마트 컨트랙트를 호출함으로써 동작하는 응용프로그램이다.DApp = FrontEnd + Smart Contracts on Block chain1. DApp1) 구성요소 스마트 컨트랙트 서비스 로직이 구현된 이더리움 네트워크에 배포된 바이트 코드 사용자 인터페이스 DApp의 사용자 인터페이스 주로 HTML, CSS, JS 등 프론트엔드 기술로 구현된다. Web3 API for Js 이더리움 스마트 컨트랙트와 JS 코드 간의 상호작용을 지원한다. web 3.0은 넓은 의미로 모든 정보가 분산, 분구너화된 차세대 네트워크를 일컫는다. (소규모 회사에 정보가 집중되어 있는 wev 2.0과 대조된다.) 2) Web3. js 이더리움 네트워크와 상호작용 할 수 있게 하는 JS 라이브러리 모음$ npm install web3이더리움 네트워크는 노드로 구성되어 있고 각 노드는 블록체인의 복사본을 가지고 있다. 만약 스마트 컨트랙트의 함수를 실행하려면 이 노드들 중 하나에 요청을 보내야 한다. 보낼 내용은 다음과 같다. 스마트 컨트랙트의 주소 실행하고자 하는 함수 그 함수에 전달하고자 하는 변수이더리움 노드들은 JSON-RPC라고 불리는 언어로만 소통할 수 있고 이는 사람이 읽기 불편하다. 하지만 web3.js를 사용하면 js를 통해 통신을 할 수 있게 된다. JSON-RPC HTTP 프로토콜을 통해 이더리움 스마트 컨트랙트를 호출한다. 브라우저와 모바일에서 호출이 가능하다.2. DApp 구현 Ropsten 네트워크에 동작하는 Storage.sol 분산 앱을 제작우선, Solidity.sol을 ropsten에 배포한다. 후에 화면을 구현하고 web3.js로 이더리움 네트워크를 연결한다.1) web3 프로바이더 (provider) web3 프로바이더를 설정하여 우리 코드에 읽기와 쓰기를 처리하기 위해 어떤 노드와 통신을 해야 하는지 설정한다.공식 문서전통적인 웹 앱에서 API 호출을 위한 원격 웹 서버의 URL을 설정하는 것과 같다.Infura라는 서비스를 사용하면, DApp 서비스 사용자가 사용하는 서비스용 이더리움 노드를 운영할 필요가 없다.✅ Infura 빠른 읽기를 위한 캐시 계층을 포함하는 다수의 이더리움 노드를 운영하는 서비스이다. 접근을 위한 API를 무료로 사용할 수 있다. Infura를 프로바이더로 사용하면, 우리만의 이더리움을 설치하고 계속 유지할 필요 없이 이더리움 블록체인과 메시지를 주고 받을 수 있다.const web3 = new Web3(new Web3.providers.WebsocketProvider(\"wss://mainnet.infura.io/ws\"));하지만, DApp사용자들이 블록체인에 데이터를 읽기만 하는 것이 아니라 뭔가를 쓰기도 할 것이다. 우리는 이 사용자들이 그들의 개인 키로 트랜잭션에 서명 할 수 있도록 해야 한다.이더리움은 트랜잭션에 전자 서명을 하기 위해 공개 / 개인 키 쌍을 사용한다. 이런 방식으로 블록체인에서 데이터를 변경한다면 나의 공개 키를 통해 내가 거기 서명을 한 사람이라고 증멸할 수 있다. 하지만 아무도 내 개인 키를 모르기 때문에 내 트랜잭션을 위조할 수 없다.개인키를 우리가 관리하는 것은 꽤나 어렵기 때문에 메타 마스크와 같은 지갑을 사용할 수 있다. 사용자들이 우리의 DApp과 상호작용하기를 원하면 DApp을 메타마스크와 호환할 수 있도록 해야 한다.참고로 메타마스크는 내부적으로 Infura의 서버를 web3 프로바이더로 사용한다. 하지만 사용자들이 web3 프로바이더를 선택할 수 있는 옵션을 제공하기 때문에 메타마스크의 web3 프로바이더를 사용하면 편하다.✅ 메타마스크의 web3 프로바이더window.addEventListener('load', function() { // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask) if (typeof web3 !== 'undefined') { // Mist/MetaMask의 프로바이더 사용 web3js = new Web3(web3.currentProvider); } else { // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리 // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것 } // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네: startApp()}) web3라는 전역 자바스크립트 객체를 통해 브라우저에 web3 프로바이더를 주입. web3가 존재하는 지 확인하고 만약 존재한다면 web3.currentProvider를 프로바이더로 사용한다.2) 컨트랙트 web3프로바이더로 web3.js를 토기화 했으면, 스마트 컨트랙트와 통신할 수 있다.공식 문서web3.js가 스마트 컨트랙트와 통신을 하기 위해서는 2가지가 필요하다. 컨트랙트 주소 스마트 컨트랙트를 모두 작성한 후, 이를 컴파일한 후 이더리움에 배포하게 된다. 컨트랙트를 배포하게 되면 이더리움 상에 고정된 주소를 얻게 된다. ABI Application Binary Interface의 줄임말로 JSON형태로 컨트랙트의 함수를 표현하는 것이다. 이더리움에 배포하기 위해 컨트랙트를 컴파일 할 때 솔리디티 컴파일러에데 ABI 얻게 된다. // web3.js 컨트랙트 인스턴스화 하기var myContract = new web3js.eth.Contract(myABI, myContractAddress);3) 컨트랙트 함수 호출 컨트랙트의 함수를 호출하기 위해 call, send 메서드를 사용할 수 있다.// callmyContract.methods.myMethod(매개변수).call()// sendmyContract.methods.myMethod(매개변수).send() call은 view와 pure 함수를 위해 사용된다. 로컬 노드에서만 실행되고 블록 체인에 트랜잭션을 만들지 않는다. view, pure함수는 읽기 전용함수로 가스를 사용하지도 트랜잭션에 서명하라고 하지도 않는다. 비동기적으로 일어난다. (promise를 반환한다.) send는 트랜잭션을 만들고 블록체인 상의 데이터를 변경한다. view와 pure가 아닌 모든 함수에 대해 send를 사용한다. 트랜잭션을 생성하며 gas를 소모한다. 함수를 호출한 사람의 from 주소가 필요하다. 사용자가 트랜잭션 전송을 하고 난 후 실제로 블록체인에 적용될 때까지는 상당한 지연이 발생한다. 트랜잭션이 블록에 포함될 때까지 기다려야하는데, 이더리움의 평균 블록 시간이 15초 이기 때문이다. 만약 이더리움에 보류중인 거래가 많거나 사용자가 가스가격을 낮게 보낼 경우 우리 트랜잭션이 블록에 포함되길 기다리는 시간이 오래걸릴 수 있다. // solidity에서 public으로 변수를 선언하면 자동으로 같은 이름의 퍼블릭 getter함수를 만들어 낸다. // 만약 solidity에 Struct[] public arr;라는 배열이 있으면 해달 배열의 특정 인덱스 값을 호출하는 함수를 만들 수 있다. function getArrDetail(index){ retrun myContract.methods.arr(id).call()};getArrDetail(15).then((result)=&gt; console.log(ressult));4) 메타마스크 메타 마스크에서 사용자의 계정을 가져온다.공식 문서const userAccount = web3.eth.accounts[0];// 사용자가 언제든지 메타 마스크에 활성화된 계정을 바꿀 수 있기 때문에 계속 감시해야 한다. var accountInterval = setInterval(function() { // 계정이 바뀌었는지 확인 if (web3.eth.accounts[0] !== userAccount) { userAccount = web3.eth.accounts[0]; // 새 계정에 대한 UI로 업데이트하기 위한 함수 호출 updateInterface(); }}, 100)5) 트랜잭션 전송 web3 프로바이더에게 트랜잭션을 전송하고, 몇가지 이벤트 리스너를 연결한다.// createContract(id)라는 함수가 solidity에 있다고 가정function createRandomZombie(name) { alert(\"기다리세요...\"); // 컨트랙트에 전송 return myContract.methods.createContract(od) .send({ from: userAccount }) .on(\"receipt\", function(receipt) { alert(\"성공\") }) .on(\"error\", function(error) { alert(\"실패 });} receipt는 트랜잭션이 이더리움의 블록에 포함될 때 발생한다. error는 트랜잭션이 블럭에 포함되지 못했을 때 발생한다.6) Payable 함수 호출 wei 단위를 사용하여 함수에 전달해야 한다.1 Ether = 10^18 wei// 1 ETH를 Wei로 바꾼다. web3js.utils.toWei(\"1\");// 1이더를 담아 payable 함수 호출myContract.methods.payableFuc(params).send({form: userAccount, value: web3js.utils.toWei(\"1\")});7) 이벤트 구독 solidity에는 event 정의할 수 있다. web3.js에서는 이 이벤트를 구독할 수 있다.// newEvent라는 event가 solidity에 정의되었다고 가정// DApp 사용자가 해당 이벤트를 발생시키면 모두에게 알림이 발생한다. myContract.event.newEvent(params).on(\"data\", (event) =&gt; { console.log(event.returnValues);}).on(\"error\", console.error);// indexed를 사용하여 현재의 사용자와 연경된 변경만 수신한다. // 솔리디티: event newEvent(address indexed _from, address indexed _to, uint256 _tokenId);// filter를 사용해 _to가 userAccount와 같을 때만 코드를 실행한다. Contract.events.newEvent({ filter: { _to: userAccount } }).on(\"data\", (event) =&gt; { console.log(event.returnValues);}).on(\"error\", console.error);✅ 지난 이벤트 구독getPastEvents를 이용해 지난 이벤트를 확인하고 fromBlock과 toBlock 필터들을 이용해 이벤트 로그에 대한 시간 범위를 솔리디티에 전달할 수 있다.여기서 block은 이더리움 블록 번호를 의미한다.myContract.getPastEvents(\"NewEvent\", { fromBlock: 0, toBlock: \"latest\" }).then((events) =&gt; { // events는 event 객체들의 배열이다. \tconsole.log(event)}); 이 메서드를 통해 시작 시간부터의 이벤트 로그에 대한 확인이 가능하다. 이벤트를 블록체인에 기록하는 것은 솔리디티에서 가장 비싼 비용 중 하나이다. 스마트 컨트랙트에서는 이벤트를 읽을 수 없음에도 이벤트를 이용하는 것은 gas측면에서 훨씬 더 져렴하다.3. 예시공식문서var web3;// MetaMask에서 Ropsten 네트워크의 PRC URL을 확인하여 변수로 생성한다. (Settings &gt; Network 확인)const ROPSTEN_URL = '';// ContractAddressconst CA = '';// ABIconst STORAGE_ABI = []// 컨트랙트 호출에 사용할 계정 정보를 세팅한다. // 계정의 개인 키를 변수로 생성한다. (MetaMask에서 export private key)const privateKey = '';// 개인키로부터 계정을 생성해주는 web3 API를 활용하여 주소를 얻어낸다. var sender;var senderAddress;var storageContract;sender = web3.eth.accounts.privateKeyToAccount('0x' + privateKey);web3.eth.accounts.wallet.add(sender);web3.eth.defaultAccount = sender.address;senderAddress = web3.eth.defaultAccount;// web3 객체 만들기 // 화면이 로드될 때, web3 객체를 생성한다.window.addEventListener('load', () =&gt; { if( typeof web3 !== 'undefined') { window.web3 = new Web3(web3.currentProvider); alert('web3 injected') } else {\t\twindow.web3 = new Web3(new web3.providers.HttpProvider(ROPSTEN_URL)) } startApp();});// 계정 정보 생성 및 초기 값 세팅function startApp() { // 1. 계정 정보 // 2. storage 컨트랙트 인스턴스 // 3. 화면에 초기 값 세팅 }// retrieve() 함수 호출 후 화면에 결과 표시 function retrieve() {}// store() 함수 호출 후 화면에 결과 표시function store() { }" }, { "title": "03-Solidity-문법-기초", "url": "/posts/nft03/", "categories": "ETC, NFT", "tags": "NFT, solidity", "date": "2022-08-25 00:00:00 +0900", "snippet": "1. 솔리디티 컨트랙트 기본 구조1) 솔리디티 소스 파일 레이아웃// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;// contract 키워드를 사용한다. contract Storage {\t// 상태 변수 uint256 number; // 함수 function store(uint256 num) public { number = num; } function retrieve() public view returns (uint256){ return number; }} 라이센스 표현 (필수) 컴파일러 버전 명시 소스코드가 이용하는 컴파일러 버전 contract 키워드 + 컨트랙트 이름 으로 컨트랙트 생성 상태변수: 블록 체인 (contract storage)에 값이 저장되는 변수이다. 상태 변수의 접근 제어자를 지정할 수 있다. (external, public, private) 기본형, 구조체, 배열 등 다양한 자료형이 존재한다. 함수: 컨트랙트의 단위 기능 매개변수, 제어자, 반환값이 지정 가능하다. 함수 내부에서 상태 변수의 값을 변경하고 읽을 수 있다. (함수를 통해 상태 변수를 제어한다.) 2. 기본 문법1) 자료형✅ 원시 자료형// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract Primitives { // Unassigned variables have a default value bool public defaultBool; // false uint public defaultUint; // 0 int public defaultInt; // 0 address public defaultAddr; // 0x0000000000000000000000000000000000000000 string public defaultString; // '' // addr value assignment address public addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4; /* non negative integers different sizes are available uint8 ranges from 0 to 2 ** 8 - 1 uint16 ranges from 0 to 2 ** 16 - 1 ... uint256 ranges from 0 to 2 ** 256 - 1 uint is same as uint256 */ uint8 public u8 = 1; uint public u = 123; uint256 public u256 = 456; uint public maxUint = type(uint).max; uint public maxUint256 = type(uint256).max; /* integer different sizes are available, like uint int256 ranges from -2 ** 255 to 2 ** 255 - 1 int128 ranges from -2 ** 127 to 2 ** 127 - 1 */ int8 public i8 = -1; int public i = -123; int256 public i256 = 456; // minimum and maximum of int int public minInt = type(int).min; int public maxInt = type(int).max; /* In Solidity, the data type byte represent a sequence of bytes. Two bytes types in Solidity: - fixed-sized byte arrays: bytes# - dynamically-sized byte arrays. byte[] */ bytes1 a = 0xb5; // [10110101] bytes1 b = 0x56; // [01010110] } 자료형 예시 논리형 bool: true, flase 정수형 uint: 음수가 아닌 integer int: integer8 ~ 256 bit를 표현할 수 있으며, uint는 uint256과 같다. 주소형 address: 이더리움의 주소를 의미한다.이더리움 블록체인은 은행 계좌와 같은 계좌로 이루어져 있다. 주소는 특정 계정을 가르키는 고유 식별자이다. 바이트형 bytes# or byte[]: 데이터를 바이트로 표현할 수 있다. 문자형 string: 임의의 길이를 가진 UTF-8 데이터를 의미한다. ✅ 배열// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract Array { // Dynamic sized array: 배열의 사이즈를 선언하지 않음. uint[] public arr; // Not initialized uint[] public arr2 = [1, 2, 3]; // Initialized // Fixed sized array, all elements initialize to 0: 배열의 사이즈를 선언. uint[10] public fixedSizeArr; // Compare with accessing state variable function get(uint i) public view returns (uint) { return arr2[i]; } // Append new element to array // Check array size after calling this function. function push(uint i) public { arr.push(i); } // Remove last element from array // Check array size after calling this function. function pop() public { arr.pop(); } // Reset the value at index: 값이 제거 되는 것이 아니라 0으로 초기화 된다. // Check array size after calling this function. function remove(uint index) public { delete arr[index]; } // returns the length of array. function getLength() public view returns (uint) { return arr.length; } // returns the entire array. function getArr() public view returns (uint[] memory) { return arr; } function createArray() external pure returns (uint[] memory){ // create array in memory, only fixed size can be created uint[] memory a = new uint[](5); return a; }} 정적 배열: 자료형[배열 길이] 동적 배열: 자료형[] 고정된 크기가 없으며 계속 크기가 커질 수 있다. function getArray() external pure returns(uint[]) { // 메모리에 길이 3의 새로운 배열을 생성한다. uint[] memory values = new uint[](3); // 여기에 특정한 값들을 넣는다. values.push(1); values.push(2); values.push(3); // 해당 배열을 반환한다. return values;} new 타입[](배열 길이)은 새로운 배열을 생성한다.✅ Mapping// SPDX-License-Identifier: UNLICENSEDpragma solidity &gt;=0.7.0 &lt;0.9.0;contract Mapping { // Mapping from address to uint: Mapping 선언. // mapping(기준 키 =&gt; 값): 키는 중복이 될 수 없다. mapping(address =&gt; uint) public addrToUint; // Access value with key in Mapping. // If there is no key, it will return the default value, 0. function get(address _addr) public view returns (uint) { return addrToUint[_addr]; } // Update the value at the address function set(address _addr, uint _i) public { addrToUint[_addr] = _i; } // Reset the value to the default value.: 0으로 초기화한다. function reset(address _addr) public { delete addrToUint[_addr]; }} Mapping에 저장된 key 목록을 얻을 수 있는 방법은 제공하지 않는다. 구조화된 데이터를 저장하는 또 다른 방법이다.✅ Struct 사용자 선언 자료형으로 여러 자료형을 하나의 관점으로 묶어서 관리하고자 할 때 선언한다.// SPDX-License-Identifier: UNLICENSEDpragma solidity &gt;=0.7.0 &lt;0.9.0;contract Struct { struct MyStruct { string text; bool boolean; } // An array of structs: MyStruct를 array로 선언할 수 있다. MyStruct[] public structArray; // A mapping from address to Todo: MyStruct를 mapping으로 선언할 수 있다. mapping(address =&gt; MyStruct) public addrToStruct; // Create a new struct // method 1: () 사용 function create1(string memory _text) public { structArray.push(MyStruct(_text, false)); } // method 2: {} 사용 function create2(string memory _text) public { structArray.push(MyStruct({text: _text, boolean: false})); } // method 3: Struct타입을 별도의 로컬변수로 선언하여 array로 push function create3(string memory _text) public { MyStruct memory s; s.text = _text; structArray.push(s); } // Update text function updateText(uint _index, string memory _text) public { \t// 해당 index의 struct값을 가져와서 재할당한다. MyStruct storage s = structArray[_index]; s.text = _text; } // Switch Boolean function updateBoolean(uint _index) public { MyStruct storage s = structArray[_index]; bool current = s.boolean; s.boolean = !current; }}// 구조체 압축하기struct NormalStruct { uint a; uint b; uint c;}struct MiniMe { uint32 a; uint32 b; uint c;}// `mini`는 구조체 압축을 했기 때문에 `normal`보다 가스를 조금 사용한다. NormalStruct normal = NormalStruct(10, 20, 30);MiniMe mini = MiniMe(10, 20, 30); 기본적으로 하위 타입을 쓰는 것인 아무런 이득이 없다. 하지만 구조체는 다르다.2) 접근 제어자// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract Parent { // State variables string private privateVar = \"private variable\"; string internal internalVar = \"internal variable\"; string public publicVar = \"public variable\"; // Private function: 직접 접근이 불가능하다. function privateFunc() private pure returns (string memory) { return \"private function called\"; }\t// privateFunc는 직접 접근이 불가능 하기 때문에, 이렇게 함수를 호출해서 사용할 수 있다. function testPrivateFunc() public pure returns (string memory) { return privateFunc(); } // Internal function function internalFunc() internal pure returns (string memory) { return \"internal function called in Parent Contract\"; } function testInternalFunc() public pure virtual returns (string memory) { return internalFunc(); } // Public functions: 내부, 자식, 외부에서 호출이 가능하다. function publicFunc() public pure returns (string memory) { return \"public function called\"; } // External functions: 외부에서만 호출을 할 수 있다. function externalFunc() external pure returns (string memory) { return \"external function called\"; }}// Child가 Parent를 상속 받음contract Child is Parent { // Internal function call be called inside child contracts: 부모의 internal 함수를 호출. function testInternalFunc() public pure override returns (string memory) { return internalFunc(); }}   private internal public external 설명 컨트랙트 내에서만 접근이 가능하다. 현재의 컨트랙트와 자식 컨트랙트에서 접근이 가능하다. 현재 컨트랙트, 자식 컨트랙트, 외부 컨트랙트 및 주소에서 접근이 가능하다. 컨트랙트 외부에서 접근이 가능하다. State Variables O X O O Functions O O O O 3) 함수// SPDX-License-Identifier: UNLICENSEDpragma solidity &gt;=0.7.0 &lt;0.9.0;contract Function { uint public num = 1; uint public a = 1; string public s = \"hello solidity\"; bool public b = true; // No parameter and return value function addOne() public { num++; } // One parameter and a return value function addNumber(uint x) public returns (uint) { num += x; return num; } // view - not to modify the state variable, but read. function addAndReturn(uint x) public view returns (uint) { return num + x; } // pure - not to modify or read the state variable. function add(uint x, uint y) public pure returns (uint) { return x + y; } // Return many values: 2개 이상의 값을 반환할 수 있다. function returnMany() public view returns (uint, string memory, bool) { return (a, s, b); }} 함수 인자명을 언더스코어(_)로 시작해서 전역 변수와 구별하는 것이 관례이다. private 함수명도 언더스코어(_)로 시작하는 것이 관례이다. 함수 상태 제어자 설명 view 블록체인에서 데이터를 읽기만 한다. 순수하게 데이터에 접근해서 변경하지 않고 값만 가져온다. (gas를 소비하지 않는다.)즉, 이더리움 없이도 호출할 수 있다. 경제적 프로그래밍이 가능하다. pure 블록체인에서 데이터를 쓰고, 수정하고, 읽지 않는다. 상태 변수에 접근하지 않아도 실행할 수 있는 함수이다. payable 이더를 받을 수 있는 특별한 함수 유형이다. 해당 함수를 호출하면 이더를 요청할 수 있다. msg.value라는 글로벌 변수가 있다. (보낸 이더 금액 확인) 4) 조건, 반복문// SPDX-License-Identifier: UNLICENSEDpragma solidity &gt;=0.7.0 &lt;0.9.0;contract IfElse { function foo(uint x) public pure returns (uint) { if (x &lt; 10) { return 0; } else if (x &lt; 20) { return 1; } else { return 2; } } function ternary(uint _x) public pure returns (uint) { return _x &lt; 10 ? 1 : 2; }}contract Loop { function loop1() public pure { for (uint i = 0; i &lt; 10; i++) { if (i == 3) { continue; } if (i == 5) { break; } } } function loop2() public pure { uint i; while (i &lt; 10) { i++; } }} 이더리움이 튜링 완전 머신이라고 할 수 있는 이유는 반복문이 있기 때문이다. 블록체인에서 반복문은 사실 리스크가 크다. (모든 컴퓨터에 영향을 주기 때문) gas라는 개념이 등장하게 되면서, 무한 루프를 방지할 수 있기 때문에 반복문이 도입이 가능할 수 있었던 것. gas limit까지 사용하면 자동으로 반복문이 취소된다. 5) 화폐 단위// SPDX-License-Identifier: UNLICENSEDpragma solidity &gt;=0.7.0 &lt;0.9.0;contract EtherUnits { uint public oneWei = 1 wei; uint public oneGwei = 1 gwei; uint public oneEther = 1 ether; // 1 wei is equal to 1 bool public isOneWei = 1 wei == 1; // 1 ether is equal to 10^18 wei bool public isOneEther1 = oneEther == 1e18; // 1 ether is equals to 10^9 gwei. bool public isOneEther2 = oneEther == 10**9 * oneGwei; // 1 gwei is equals to 10^9 wei. bool public isOneGwei = oneGwei == 10**9 * oneWei;} 이더리움 버추얼 머신에서 소숫점을 허용하지 않는다. wei * (10**18) = Ether 단어 설명 Wei 기본적으로 인식할 수 없을 정도의 작은 단위로, 기술적인 경우나 코드 작성에만 사용된다. Ether 이더리움의 액면가치로 실질적인 거래는 Ehter의 관점에서 진행된다. 1,000,000,000,000,000,000 wei이다. 6) Data Location공식문서 모든 복합 타입은 자신이 메모리 나 스토리지 중 어디에 저장되었는지를 나타내는 “데이터 위치”가 추가적으로 존재한다. 컨텍스트에 따라 항상 기본값이 존재하지만, 타입에 storage , memory, calldata 를 추가하여 재정의 할 수 있다. 데이터 위치는 변수가 할당되는 방식을 변경하기 때문에 중요하다. 함수 내부에 선언된 변수의 기본값은 memory 이다. 지역 변수의 기본값은 storage 이며 상태 변수의 위치는 storage 로 강제되어 있다. 구조체, 배열을 사용할 때는 명시적으로 작성해야 한다. 단어 설명 storage 변수가 블록체인에 기록되어 영구적이다. 모든 계약에는 자체 저장소가 있기에 변수는 영구적이다. 따라서 어디서든 스토리지 변수에 접근을 할 수 있으며 값을 수정할 수 있다. 단, 위치는 영구적이다. 영구적이다. memory 메모리에 저장된 변수는 함수 내에서 선언된다. 이는 영구적이지 않고 일시적으로 존재하는 변수이다. memory 변수의 목적은 계산을 돕는 것으로 다른 곳에서는 해당 변수에 접근할 수 없다. 지속성이 없다. call data 임시 데이터 로 선언된 함수 내에서만 사용할 수 있다. 거의 memory 처럼 작동한다. 수정 불가능 지속성이 없다. =&gt; 외부 함수의 함수 매개변수 7) Keccak256과 형변환 이더리움은 keccak256을 내장 해시 함수로 가지고 있다.해시 함수는 기본적으로 입력 스트링을 랜덤 256비트 16진스로 매핑한다. 스트링에 약간의 변화라도 있으면 해시 값은 크게 달라진다.해시 함수는 이더리움에서 여러 용도로 활용되지만 의사 난수 발생기로 이용할 수 있다.// 예시//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5keccak256(\"aaaab\");//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9keccak256(\"aaaac\");// Generate a random number between 1 and 100:uint randNonce = 0;uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;randNonce++;uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100; 블록 체인에서 안전한 의사 난수 발생기는 어려운 문제이다. 보안에 있어서 큰 문제가 없을 경우에만 사용하는 것을 추천한다. 솔리디티는 고유의 스트링 비교 기능을 가지고 있지 않기 때문에 스트링의 keccak256 해시 값을 비교하여 스트링 값이 같은지 판단한다.8) Event 컨트랙트에서 특저어 이벤트가 발생하는지 귀를 기울이고 그 이벤트가 발생하면 행동을 취한다.// 이벤트를 선언한다event IntegersAdded(uint x, uint y, uint result);function add(uint _x, uint _y) public { uint result = _x + _y; // 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다: IntegersAdded(_x, _y, result); return result;}9) 인터페이스 블록체인 상에 있으면서 우리가 소유하지 않은 컨트랙트와 우리 컨트랙트가 상호작용을 하려면 인터페이스를 정의해야 한다.contract NumberInterface { function getNum(address _myAddress) public view returns (uint);}contract MyContract { address NumberInterfaceAddress = 0xab38... // ^ 이더리움상의 FavoriteNumber 컨트랙트 주소이다 NumberInterface numberContract = NumberInterface(NumberInterfaceAddress) // 이제 `numberContract`는 다른 컨트랙트를 가리키고 있다. function someFunction() public { // 이제 `numberContract`가 가리키고 있는 컨트랙트에서 `getNum` 함수를 호출할 수 있다: uint num = numberContract.getNum(msg.sender); // ...그리고 여기서 `num`으로 무언가를 할 수 있다 }}10) 시간 단위 솔리디티는 시간을 다룰 수 있는 단위를 기본적으로 제공한다.uint lastUpdated;// `lastUpdated`를 `now`로 설정function updateTimestamp() public { lastUpdated = now;}// 마지막으로 `updateTimestamp`가 호출된 뒤 5분이 지났으면 `true`를, 5분이 아직 지나지 않았으면 `false`를 반환function fiveMinutesHavePassed() public view returns (bool) { return (now &gt;= (lastUpdated + 5 minutes));} now 변수를 사용하면 현재의 유닉스 타임스탬프 값을 얻을 수 있다. 유닉스 타임은 32비트의 숫자로 저장된다. 솔리디티는 seconds, minutes, hours, days, weeks, years와 같은 시간 단위가 있다. 이에 해당하는 길이만큼의 초단위uint숫자로 변환된다. ex) 1 minutes = 60, 1hours = 3600 11) Ownable 컨트랙트 컨트랙트를 대상으로 특별한 권리를 가지는 소유자가 있음을 의미하는 컨트랙트이다.OpenZeppelin 솔리디티 라이브러리에서 가져온 Ownable 컨트랙트contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); // 생성자 함수 function Ownable() public { owner = msg.sender; } // 접근을 제어하기 위한 modifier 함수 modifier onlyOwner() { require(msg.sender == owner); _; } // onlyOwner를 충족하면 해당 함수를 실행할 수 있다. function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; }} 컨트랙트가 생성되면 컨트랙트의 생성자가 owner에 msg.sender(컨트랙트를 배포한 사람)를 대입한다. 특정한 함수들에 대해서 오직 소유자만 접근할 수 있도록 제한 가능한 onlyOwner 제어자를 추가한다. 해당 컨트랙트를 상속받아서 사용하는 경우가 많다. DApp을 안정적으로 유지하도록 하는 것과, 사용자들이 그들의 데이터를 믿고 저장할 수 있는 소유자가 없는 플랫폼을 만드는 것 사이에서 균형을 잘 잡는 것이 중요하다.3. Solidity 연습: FundRaising 구현하기 특정 사람에게 모금을 해서 기부를 하는 프로세스이다. 내가 모금한 것이 정확히 잘 전달 되었는가에 대한 의심을 없앨 수 있다. 일회성으로 동작하는 모금 컨트랙트이다. 일정 기간 동안만 이더를 지불하여 모금에 참여할 수 있다. 모금, 현재 모금액 확인, 모금액 수령 기능을 제공한다.// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract FundRaising{ // 모금 종료 시각 uint public fundRaisingCloses; // 모금 수령자 address public beneficiary; // 모금자 address[] funders; // 최소 모금액 // 1e16 wei = 10**16 wei = 0.01 ether uint public constant MINIMUM_AMOUNT = 1e16; // 컨트랙트 배포시 모금 기간과 모금액 수령자를 지정하도록 한다. // 3600 = 1시간 constructor (uint _duration, address _beneficiary) { // block.timestamp: 현재 블록의 타임스탬프 값 (현재 시각) fundRaisingCloses = block.timestamp + _duration; beneficiary = _beneficiary; } // 모금 함수 // 1. 0.01 ehter이상으로만 모금에 참여할 수 있다. // 2. 지정된 모금 시간 이내에 참여할 수 있다. // 3. 모듬이 완료되면 모금자를 저장한다. // payable 키워드: ether를 주고 받는 함수를 의미 한다. // payable 키워드를 가진 함수는 msg.value 글로벌 변수를 갖고 있다. =&gt; 트랜잭션에 얼마를 보냈는 지를 알 수 있는 전역 변수 function funnd() public payable { // if 문보다는 require를 사용하는 것을 추천한다. =&gt; 경제적 프로그래밍에 도움이 된다. // require(판별문, \"에러 메시지\")로 판별문이 true가 아닌 경우 에러메시지를 출력 후 함수를 바로 종료 시킨다. require(msg.value &gt;= MINIMUM_AMOUNT, \"MINIMUN AMOUNT: 0.01 ether\"); require(block.timestamp &lt; fundRaisingCloses, \"FUND RAISING CLOSED\"); // msg.sender: 함수를 호출하는 사람의 주소를 의미하는 전역 변수 // 솔리디티 함수 실행을 항상 외부 호출자가 하기 떄문에 msg.sender는 항상 존재한다. address funder = msg.sender; // 모금자 저장하기 funders.push(funder); } // 현재 모금액을 확인하는 함수 function currentCollection() public view returns(uint256) { return address(this).balance; } // 함수 modifier 작성 =&gt; 재 사용성 good~ modifier onlyBeneficiary(){ require(msg.sender == beneficiary); // 다시 함수로 돌아간다. _; } // 모금 전달 // 1. 지정된 수령자만 호출할 수 있다. // 2. 모금 종료 이후에만 호출할 수 있다. // 3. 수령자에게 컨트랙트가 보유한 이더를 송금한다. function withdraw() public payable onlyBeneficiary{ require(block.timestamp &gt; fundRaisingCloses); // 요청 주소에게 컨트랙트 보유 이더 송금: &lt;address payable&gt;.tranfer(uint256 amount) payable(msg.sender).transfer(address(this).balance); }} msg.sender: 함수를 호출하는 사람의 주소를 의미하는 전역 변수 modifier는 함수 제어자이다. 조건에 맞는지 확인 하는 용으로 다른 함수에서 사용된다. 4. Solidity 연습: ToDo 구현하기// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract ToDo{ struct ToDoItem { string title; string description; bool isSucceed; } ToDoItem[] public toDoArray;\t// 제목, 설명을 매개변수로 전달하여 toDoItem 생성 function create(string memory _title, string memory _desc) public { toDoArray.push(ToDoItem({title: _title, description: _desc, isSucceed: false})); } // 인덱스를 매개변수로 전달하여 해당 인덱스의 타이틀을 수정 function updateTitle(uint _index, string memory _title) public{ ToDoItem storage item = toDoArray[_index]; item.title = _title; }\t// 인덱스를 매개변수로 전달하여 해당 인덱스의 toDo 성공 여부를 수정 function toggleSuccess(uint _index) public { ToDoItem storage item = toDoArray[_index]; bool current = item.isSucceed; item.isSucceed = !current; }\t// 인덱스를 매개변수로 전달하여 해당 인덱스의 desription을 반환 function getToDoDesc(uint _index) public view returns (string memory) { ToDoItem storage item = toDoArray[_index]; return item.description; }}" }, { "title": "02-블록체인-기초-스마트-컨트랙트", "url": "/posts/nft02/", "categories": "ETC, NFT", "tags": "NFT", "date": "2022-08-25 00:00:00 +0900", "snippet": "1. 정의 1990년대 Nick Szabo가 소개한 개념으로 디지털 형식으로 명시된 서약(Commitment)들의 집합이다. 결고 스마트하지 않은 단순 컴퓨터 프로그램이다. 다소 잘못된 용어임에도 불구하고 자리 잡았다. 법적 맥락이 없다. 계약서 안에 서로 서명을 하거나, 참여한 사람들 끼리의 약속이다. 계약서가 블록체인에 담기기 때문에, 계약서를 신뢰할 수 있게 된다. 즉, 계약에 담긴 코드를 신뢰할 수 있게 된다. 1) 블록 체인에서의 정의 불변의 컴퓨터 프로그램 컴퓨터 프로그램 불변 (한 번 배포가 되면 변경이 불가능하다.) 한번 배포가 되어 컨트랙트 주소가 생성이 되면, 해당 주소와 코드는 불변으로 매핑이된다. 결정적 실행한 결과가 모두 같다. 같은 프로그램을 모두가 공유를 하고 있기 때문에, 전세계 모든 컴퓨터는 해당 프로그램에 대해 똑같은 input에 똑같은 output을 가진다. EVM 위에서 동작한다. 탈중앙화된 World Computer 동일한 상태를 유지한다. 전세계 수많은 사람들이 똑같은 로직과 저장소를 가지고 있다. 이더리움은 거대한 한 대의 컴퓨터이다. 이더리움 애플리케이션의 기본적인 구성 요소로 모든 변수와 함수는 어느 한 컨트랙트에 속해있다.2) Smart Contract를 작성하는 언어 Solidity LLL Viper Assembly3) Smart Contract 배포와 호출 Smart Contract Code 작성 EVM Bytecode, ABI in JSON으로 컴파일 EVM: 이더리운 블록체인 네트워크의 노드들이 공유하는 하나의 가상 머신 (매운 거대한 하나의 분산 컴퓨터) EVM은 누구나 접근할 수 있는 거대 컴퓨터이며, 수만ㅎ은 사용자가 변경하는 데이터의 충돌과 보안을 담당한다. 솔리디티 코드 =(컴파일) =&gt; 바이트코드 =&gt; 바이트 코드를 EVM이 실행한다. ABI: 컨트랙트의 함수와 매개변수들을 JSON 형식으로 나타낸 리스트다. 트랜잭션을 생성하여 Smart Contract의 Bytecode가 data에 담기게 된다. 트랜잭션을 서명하고 전세계의 이더리움 네트워크로 보낸다. 이더리움 네트워크에 참여한 모든 컴퓨터들이 해당 스마트 컨트랙트에 대한 내용을 받게 된다. 클라이언트 (EVM)이 서명을 하고 바이트 코드를 실행하여 트랜잭션을 전파한다. 해당 트랜잭션이 블럭 안에 담기게 되고 이는 불변의 데이터이기 때문에 해당 스마트 컨트랜트 코드가 불변의 데이터가 된다. 배포가 완료가 되면 컨트랙트 주소가 생성된다. (스마트 컨트랙트도 이더나 토큰들을 보관할 수 있다. ) 주소와 인터페이스를 통해 로직을 실행할 수 있게 된다. (CA와 ABI를 통해 함수를 호출한다.):white_check_mark: 용어 ByteCode ABI (Application Binary Interface) CA (Contract Address)4) 작업 증명 컨트랙트의 함수를 실행하면 트랜잭션으로서 네트워크 노드 하나 혹은 려어 노드에 실행을 알린다. 네트워크 노드들은 여러 개의 트랜잭션을 모으고 작업 증명으로 알려진 계산이 매우 복잡한 수학문제를 풀기위한 시도를 한다. 해당 트랜잭션 그룹을 그들의 작업 증명과 함꼐 블록으로 네트워크에 배포하게 된다. 한 노드가 어떤 작ㅇ업증면을 풀면, 다른 노드들을 그 작업 증명을 풀려는 시도를 멈추고 해당 노드가 보낸 트랜잭션 목록이 유효한 것인지 검증한다. 유효하다면 해당 블록을 받아들이고 다음 블록을 풀기 시작한다.2. Smart Contract 배포 스마트 컨트랙트 IDE인 remix 활용 별도의 개발환경 설정 없이 스마트 컨트랙트를 작성하고 배포, 호출할 수 있다. Slolidity 코드는 컨트랙트 안에 쌓여있다.1) 배포 단계 Storage.sol파일을 컴파일한다. 배포 가능한 컨트랙트를 생성한다. ABI가 생성된다. Storage_metadata.json파일에서 확인이 가능하다. 전세계의 이더리움 컴퓨터에 배포되어 있는 모든 스마트 컨트랙트에서 사용되는 함수를 확인할 수 있다. 함수의 매개변수, 반환값 등 Bytecode가 생성된다. Storage.json파일에서 확인이 가능하다. 어샘블리어와 유사한 opcode가 나열되어 있는 것을 확인할 수 있다. 이를 토대로 이더리움 머신에 배포를 하게 된다. 컴파일이 완료가 되면 직접 블록체인에 배포를 할 수 있다. 배포된 컨트랙트의 주소를 확인할 수 있다.3. Smart Contract 호출1) 호출// 모든 솔리디티 소스 코드는 version pragma로 시작해야 한다. // 이는 해당 코드가 이용해야 하는 솔리디티 버전을 선언하는 것이다. pragma solidity &gt;=0.7.0 &lt;0.9.0;contract Storage {\t// number를 설정하지 않으면 기본값으로 0으로 지정된다. uint256 number;\t// number라는 변수의 값을 설정 (setter) function store(uint256 num) public { number = num; }\t// number라는 변수의 값을 return (getter) function retrieve() public view returns (uint256){ return number; }} store: store라는 함수를 호출 store 함수를 호출함으로 값을 변경시킬 수 있다. (정해진 규칙대로만 변경할 수 있다.) 전세계의 모든 컴퓨터에 정해진 규칙을 가지고 값을 설정함으로서 해커와 같은 악성 유저가 해당 가치를 변경할 수 없도록한다. 값을 설정하기 때문에 gas를 사용한다. (이더리움 네트워크가 연결된 모든 컴퓨터가 일을 하게 하기 때문) 트랜잭션을 생성한다. retrieve: retrieve라는 함수를 호출 단순하게 저장된 데이터를 불러온다. gas를 사용하지 않는다. gas가 존재하는 이유솔리디티에서는 함수를 실행할 때마다 가스라는 화폐를 지불해야 한다.연산을 수행하는 데 소모되는 컴퓨팅 자원의 양이 해당 비용을 결정한다. 사용자들이 함수를 실행하면 실제 돈을 사용하기 때문에 코드 최적화는 필수이다.gas가 있는 이유는 다음과 같다. 이더리움은 크고, 느리지만 굉장히 안전한 컴퓨터이다. 함수를 실행할 때 네트워크 상의 모든 개별 노드가 함수의 출략값을 검증하기 위해 해당 함수를 실행해야 한다.모든 함수의 실행을 검증하는 수천 개의 노드가 바로 이더리움을 분산화하고 데이터를 보존하며 누군가 검열할 수 없도록 하는 요소이다. 특정 사용자가 무한 반복문을 써서 네트워크를 방해하거나 네트워크 자원을 모두 사용하지 못하도록 만들지 못하기 위해 연산처리에 비용이 들게 만들었다.2) 제 3자의 접근 컨트랙트 주소(CA)를 통해 접근 한다. ABI를 통해 함수 호출이 가능하다." }, { "title": "01-블록체인-기초-개념", "url": "/posts/nft01/", "categories": "ETC, NFT", "tags": "NFT", "date": "2022-08-25 00:00:00 +0900", "snippet": " 블록 체인 기본 개념과 Ropstem 네트워크 실습1. 블록체인 분류 유형 특징 관련 기술 퍼블릭 누구나 네트워크에 참여한다. Bitcoin, Ethereum, Litecoin… 프라이빗 하나의 조직 혹은 기관이 관장하는 네트워크로 승인된 주체만 자료를 읽고 지정 노드만 거래를 승인한다. Quorum, MultiChain, Iroha, Monax… 컨소시엄 이해 관계자 간에 컨소시엄을 구성하여, 네트워크를 구성하여 네트워크 참여자에 의해 접근을 허용한다. Hyperledger Fabric, Tendermint, R3 Corda… 2. 이더리움 네트워크가장 대중화된 블록체인으로 많은 사람들이 사용하고 있다.1) 퍼블릭 네트워크? 메인넷: 거래소에서 직접 사고파는 이더리움을 거래하고 그 위에서 스마트 컨트랙트등 디앱을 개발할 수 있는 네트워크 테스트넷: 메인 넷에 가는 것이 아직 준비 되지 않았을 때, 가볍게 테스트해볼 수 있는 네트워크네트워크 ID에 맞게 거래를 하거나 트랜잭션을 보낼 수 있다. Hex Decimal Network 0x1 1 Ehereum Main Network (Mainnet) 0x3 3 Ropsten Test Network (실습을 진행할 테스트 네트워크) 0x4 4 Rinkeby Test Network 0x5 5 Goerli Test Network 0x2a 42 Kovan Test Network :white_check_mark: 프라이빗 네트워크 누구나 공개된 Client SW로 프라이빗 네트워크를 구축할 수 있다. besu는 엔터프라이즈 환경에 맞게 개량된 Hyperledger의 ethereum 프로젝트이다.2) 이더리움 클라이언트 클라이언트란 네트워크에 노드로 참여하여, RPC(Remote Procedure Call) 요청을 수신하고 결과를 반환하는 EndPoint이다. port만 맞으면 거래가 가능하다. 3. Ropsten 실습 환경 준비1) MetaMask 설치 MetaMask는 이더리움 블록체인 지갑이다. 설치 사이트 지갑(wallet) 블록체인 네트워크를 사용할 수 있도록 계정의 개인키 (Private Key)를 관리하는 프로그램이다. 나를 증명하는 디지털 성명 개인키로 Sign하여 트랜잭션을 보낸다. 개인 키 생성 절차 256bit의 무작위 숫자를 발급한다. (매우 큰 숫자로 중복이 발생할 수가 없다.) 64자리의 Hex 값으로 인코딩한다. 타원곡선전자서명 알고리즘 (ECDSA, secp256k1)을 사용하여 공개 키를 생성한다. (개인 키로부터 공개 키가 생성된다.) Keccak-256 hasing라는 hash 함수를 통해 다시 새로운 값으로 변환한다. 변환된 값의 마지막 20Byte에 0x를 앞에 붙여 계정 주소로 사용한다. 2) 계정 생성, 테스트 네트워크 연결 계정 생성 현재는 메인 네트워크만 볼 수 있는 상태이기 때문에 테스트 네트워크 보기 설정을 on 테스트 네트워크 연결4) 테스트 이더 받기 Ropsten에서 사용할 이더를 받는다. Faucet (수도꼭지) 테스트넷 환경을 사용할 수 있도록 가치없는 통화를 무료로 제공하는 자금원이다. rETH, ROP라고도 불리기도 한다. 절차 ropsten faucet를 검색하여 테스트 이더를 제공하는 사이트에 접속한다. 본인의 지갑 주소를 입력하여 테스트이더를 요청한다. 테스트 이더가 무한으로 제공되지는 않는다. 일정 시간이 지나면 위와 같이 테스트 이더를 받을 수 있다.4. Ropsten 테스트넷 실습1) MetaMask에서 트랜잭션 보내기 가스비는 중개료이다. 가스비에 따라 거래 처리 속도가 다르다.2) MetaMask Provider 이용하기 프로바이더 (Provider)란 클라이언트를 통해 이더리움 네트워크에 접근할 수 있도록 제공된 Javscript 객체이다. 공식사이트위의 공식 사이트에 방문하여 크롬 개발자도구를 사용한다. ethereum을 console창에 치면 접속되어 있는 ethereum의 정보, 객체를 확인할 수 있다. 예시 chainId: 0x3 =&gt; ropseten에 접속되어 있는 겻을 확인할 수 있다. _metamask =&gt; metamask를 사용하는 것을 확인할 수 있다. // 현재 이더리움 네트워크에 연결되었는지 확인&gt; ethereum.isConnected() &gt; true// 이더리움 계정 활성화&gt; ethereum.enable()// 현재 활성화된 계정 확인&gt; ethereum.selectedAddress isConnected(): https://docs.metamask.io/guide/ethereum-provider.html#ethereum-isconnected// Ethereum Provider로 RPC API 보내기&gt; ethereum.request({ method: \"eth_blockNumber\", params:[] }).then(result=&gt; console.log(result));&gt; Promise {&lt;pending&gt;}&gt; 0xc43a3f &gt; parseInt(\"0xc43a3f\", 16)&gt; 12859967 // 현재 이더리움 네트워크가 쌓을 블럭의 수 현재 네트워크에 블럭이 몇개 쌓여있니? https://docs.metamask.io/guide/ethereum-provider.html#ethereum-request-args" }, { "title": "이미지-유효성-검사와-Compressor", "url": "/posts/vue05/", "categories": "WEB, Vue", "tags": "vue", "date": "2022-08-10 00:00:00 +0900", "snippet": "SNS서비스를 만드는 프로젝트를 하면서, 이미지를 처리해야 하는 경우가 많았다. 이미지 용량을 줄이는 compressor라이브러리 사용법과 file input에 대한 유효성 검사 함수를 정리했다.1) 이미지 크기 제한// 정해진 파일 크기보다 큰 파일이라면 false를 반환한다. (max: 최대 이미지 mb, fileSize: 업로드한 이미지 용량)function checkImageSize(fileData: { max: number; fileSize: number }): boolean { const { max, fileSize } = fileData; // 제한되는 사이즈 const maxSize = max * 1024 * 1024; if (maxSize &lt;= fileSize) { return false; } return true;}2) 이미지 확장자 제한// 정해진 파일 확장자가 아니라면 false를 반환한다. (fileName: 이미지 이름)function checkImageExtension(fileName: string): boolean { // 이미지 확장자 const imageExtensions = [\"gif\", \"jpg\", \"jpeg\", \"png\", \"bmp\", \"ico\", \"apng\"]; // 업로드한 파일 확장자 ('.'이후의 문자를 소문자로 변환) const extension = fileName .substring(fileName.lastIndexOf(\".\") + 1) .toLocaleLowerCase(); // 업로드한 파일 확장자가 이미지 확장자인지 확인한다. const result = imageExtensions.some((item) =&gt; item === extension); return result;}3) 이미지 Compressorcompressor.js 공식 문서import Compressor from \"compressorjs\";// 이미지 compressor (file: 업로드한 파일 )function compressorImage(file: File): Promise&lt;File&gt; { // 프로미스 객체를 반환한다. return new Promise((resolve, reject) =&gt; { new Compressor(file, { // compressor 옵션 checkOrientation: false, quality: 0.8, maxWidth: 1920, maxHeight: 1920, // compressor에 성공했을 경우, 파일로 저장하여 반환한다. success(result: File) { const compressorImage = new File([result], result.name, { type: result.type, }); resolve(compressorImage); }, // compressor에 실패했을 경우, error(error) { reject(error); }, }); });}4) 실제 적용 로직 (vue3)import {checkImageSize, compressorImage, checkImageExtension,} from \"../../functions/image\";// fileInput의 change 이벤트가 발생할 때 실행한다. const changeCustomCocktailImage = (event: Event) =&gt; { let file = (event.target as HTMLInputElement).files![0]; // 파일을 업로드 하지 않고 취소 버튼을 누르는 경우 if (!file) { return; } // 업로드한 파일이 이미지가 아닌경우 if (!checkImageExtension(file.name)) { store.dispatch( \"modal/changeErrorModalMessage\", \"올바른 이미지 파일을 업로드 하세요.\" ); store.dispatch(\"modal/blinkErrorModalAppStatus\", true); return; } // 이미지 용량이 5mb초과면 compressor를 진행한다. if (!checkImageSize({ max: 5, fileSize: file.size })) { compressorImage(file).then((result) =&gt; { // compressor를 진행해도 이미지 용량이 10mb 초과면 알림을 보낸다. if (!checkImageSize({ max: 10, fileSize: result.size })) { store.dispatch( \"modal/changeErrorModalMessage\", \"이미지가 너무 큽니다.\" ); store.dispatch(\"modal/blinkErrorModalAppStatus\"); return; // compressor를 진행 후, 이미지 용량이 10mb 이하면 업로드 한다. } else { const data = { img: result, }; store.dispatch(\"customCocktail/uploadImage\", data); emit(\"changeImage\", data.img); return; } }); // 이미지 용량이 5mb 이하면 compressor 없이 그냥 업로드 한다. } else { const data = { img: file, }; store.dispatch(\"customCocktail/uploadImage\", data); emit(\"changeImage\", data.img); return; }}; event.target.files[0]을 통해 파일을 가져온다. 만약 파일이 아니거나 이미지 파일이 아니면 바로 return 한다. 이미지 파일이 5mb 초과면 compressor를 진행한다. compressor를 진행해도 이미지가 10mb 초과이면 알림을 보내고 바로 return한다. compressor를 진행 후, 이미지가 10mb 이하이면 파일을 서버에 보낸다. 이미지 파일이 5mb 이하면 compressor 없이 바로 서버에 보낸다." }, { "title": "컴퓨터구조-입출력-구조", "url": "/posts/computerstructure08/", "categories": "CS, 컴퓨터-구조", "tags": "cs, 컴퓨터-구조", "date": "2022-08-02 00:00:00 +0900", "snippet": "입 출력 구조 파트1강의 링크1) 주변장치 (Peripheral Devices)(1) 종류 입력장치 키보드, 마우스, 디지타어지, 마이크 ,카메라, 3축셍서 등 출력 장치 모니터, 프린터, 스피커, 서보 장치 등 입 출력 장치 저장 장치, TV-인코더, LC 터치 스크린 등 (2) 인터 페이스 주변 장치를 CPU에 연결하는 방법 (어떠한 device들이 CPU와 어떻게 연결하는가) 통신을 하는 데이터가 어떻게 표현되는가 ASCII (American Standard Code For Information Interchange) 문자를 사용한다. Alphanumeric , 제어 문자 모든 device는 인터페이스를 가지고 있다.2) 입출력 인터페이스 (Input-Output Interface) CPU는 입출력 버스의 정보 흐름을 관리하는 I/O 제어를 갖고 있으며, 메모리로부터 명령어를 받아 인터페이스를 통하여 주변 장치와 통신한다. 인터페이스는 명령을 해석하고 주변 장치 제어기에 신호를 보낸다.(1) 입출력 인터페이스의 기능 CPU와 I/O 장치의 차이점을 해결한다. I/O 장치는 CPU에 비해 굉장히 느리다. 동작 방식 차이에 따른 데이터 신호값을 변환한다. 키보드, printer, disc가 사용하는 신호 방식과 cpu 사용하는 신호 방식이 다르다. 신호 방식 TTL: 0이면 0볼트, 1이면 5볼트 RS-232-C: 0이면 5볼트,1이면 -3볼트 서로 다른 신호 방식의 차이를 위함 전송 속도 동기화 데이터 코드 형식과 메모리 워드 형식 간 변환 ASCII코드만 사용하는 것이 아니다! 주변 장치들 간의 동작 숭서와 순위 중재 및 조정한다. I/O 장치들이 동시에 CPU를 사용하려고 할때 중재 (2) I/O 버스와 인터페이스 모듈 입출력 버스를 통해 CPU와 인터페이스를 연결한다. 인터페이스가 실행하는 I/O 커맨드 입출력 커맨드 설명 제어 커맨드 주변 장치를 활성화, 동작을 정의 테스트 커맨드 상태를 확인 데이터 출력 커맨드 데이터의 출력을 전송 데이터 입력 커맨드 데이텨의 입력을 전송 (3) I/O 대 메모리 버스 CPU는 I/O 뿐만 아니라 메모리 장치와도 통신한다. 컴퓨터의 버스가 I/O와 메모리와 통신하는 세 가지 방법은 다음과 같다. 메모리 와 I/O는 각자 다른 버스를 사용한다. CPU와 IOP를 별도로 가지는 시스템에 사용된다. 메모리와 I/O가 공통의 버스, 개별 제어 라인을 사용한다. 메모리와 I/O가 공통의 버스와 제어라인을 사용한다.입출력 구조 파트2강의 링크1) 비동기 데이터 전송 (Asynchronous Transfer) 인터페이스를 통해 데이터를 전송하고 받을 때, 통신하는 규격이 중요하다. 신호를 전송하는 규격과 규칙이 있다.(1) 스트로브 제어 전송의 시간을 맞추기 위해 단 하나의 제어 라인을 사용한다. 송신 장치과 수신 장치 사이에는 데이터를 운반하는 데이터 버스와 유용한 데이터가 버스에 있음을 알리는 스트로브가 존재한다. Source에서의 데이터 전송을 원한다면, (Source initiate) Source에서 데이터를 데이터 버스에 올리고 스트로브 신호를 발생킨다. Destination이 데이터를 받아들일 만큼 충분한 시간 동안 데이터를 활성화된 상태로 만든다. Destination은 Source가 데이터를 보내고 있다는 것을 인지하게 되어 데이터(한 비트)를 수신 한다. 스트로브 신호를 통해 이게 나에게 보내는 데이터인지 확인할 수 있다. 스트로브 신호가 꺼지면 Destination이 데이터를 보내는 시간이 끝난 것을 알게 된다. Destination에서의 데이터 수신을 원한다면, (Destination initiate) Destination에서 스트로브 신호를 발생시킨다. Source가 데이터 버스에 데이터(한 비트)를 띄운다. 스트로브 신호를 통해 데이터를 받을 준비가 된 것을 확인 할 수 있다. Destination은 Source가 보낸 데이터를 받고 스트로브 신호를 끈다. 스트로브 신호가 꺼지면 Source는 Destination이 데이터를 받았음을 알게 된다. :white_check_mark:문제점 Source initiate의 경우 Destination이 데이터를 받았음을 알 수 없다. 스트로크 신호가 끊기거나 오류가 생기면, Destination은 Source가 데이터를 보내고 있음을 모르게 되어 데이터를 수신하지 않는다. Source는 일정 시간이 지나면 자동으로 데이터를 그만 보내기 때문에 Destination이 데이터를 안받았는지 모른다. Destinaion initiate의 경우 Source가 Destination이 데이터를 수신할 준비가 된 것을 모를 수 있다. 스트로크 신호가 끊기거나 오류가 생기면, Source는 Destination이 스트로크 신호를 보내고 있음을 모른다. Source가 데이터를 송신하지 않아, Destination은 Source가 보낼 데이터가 없다고 인지하게 된다. 상호 간에 데이터를 받았는지 확인하는 절차가 필요하다.(2) 핸드쉐이킹 (HandShaking) 제어 Source에 보내는 제어 신호를 추가하여 스트로브 제어의 문제점을 해결할 수 있다. 서로 악수하듯이 확인해서 핸드쉐이킹이라고 부른다. Source에서의 데이터 전송을 원한다면, (Source initiate) Source에서 데이터를 버스에 올리고 valid 신호를 보낸다. Destination이 버스에서 데이터를 받은 후 accepted 신호를 보낸다. 서로 신호를 끄면서, 데이터가 잘 전송 됨을 알 수 있다. 만약 accepted 신호를 일정 시간동안 안 보내면, time out 에러가 발생한다. Destination에서의 데이터 수신을 원한다면, (Destination initiate) Destination에서 ready for data 신호를 보낸다. Source에서 데이터 버스에 데이터를 올린 뒤, 데이터와 valid 신호를 보낸다. 서로 신호를 끄면서, 데이터가 잘 전송 됨을 알 수 있다. 만약 valid신호를 일정 시간동안 안 보내면, (3) 비동기 직렬 전송 TTL 전송 특별하지 않은 이상, 컴퓨터의 디바이스간의 전송은 TTL전송을 사용한다. 0V, 5V 신호로 데이터를 전송한다. 시작 비트1, 데이터 비트 8, 정지 비트 2. 총 11비트 단위로 8비트 데이터를 전송한다. 한 비트당 핸드 쉐이킹으로 보낸다…. 데이터 신호(비트)의 간격 = 1/ 전송속도 데이터의 신호간격이 짧아질 수록 전송속도가 빨라진다. 그래서 신호의 간격이 중요하다. 전송 규칙 데이터가 전송되지 않을 때에는 항상 1신호(5v)를 유지한다. 문자 전송의 시작은 시작 비트 0으로 표시한다. 시작 비트 뒤로 8개의 데이터 비트를 표시한다. 마지막 비트 후, 2비트 이상의 1신호를 유지한다. (4) 비동기 통신 인터페이스 I/O 장치의 비동기 통신을 위한 인터페이스로 UART가 있다. UART 일반적인 인터페이스의 형태이다. shife레지스터에 의해 한비트씩 8비트 전송을 하는 장치이다. 3) 전송 모드 (Modes of Transfer) 컴퓨터와 I/O장치 사이의 데이터 전송은 여러 가지 모드로 나뉘어진다.CPU의 도움을 통해 메모리로 전송하거나 I/O가 CPU의 도움 없이 데이터를 직접 메모리로 전송하는 방법이 있다.(1) 입출력 전송 모드의 종류 프로그램된 I/O (Programmed I/O) 입출력 명령에 의하여 동작한다. 프로세서 레지스터와 주변 장치간 데이터 전송을 수행한다. 레지스터와 메모리간 데이터 전송을 수행한다. 주변 장치의 플래그에 기반한 입출력을 수행한다. 즉, CPU가 주관하여 I/O에서 입출력이 발생하는지 계속 확인한다. 인터럽트에 의한 I/O (Interruped I/O) 인터럽트에 의하여 입출력을 수행한다. 입출력이 준비되면 프로세서 인터럽트 요구를 수행한다. 인터럽트 처리 후 본래 프로그램을 계속 수행한다. 즉, CPU는 가만히 있고 I/O가 인터럽트를 통해 나 지금 데이터 전송한다라고 알려준다. 그때 프로그램된 I/O방식으로 데이터를 수행한다. 직접 메모리 접근 (DMA: Direct Memory Access) 데이터를 메모리 버스를 통하여 전송한다. DMA를 수행하는 전용 하드웨어 (DMA Controller)를 사용한다. 사이클 스틸링에 의한 버스를 효율화한다. 즉, CPU가 관여하지 않는다. 일종의 작은 형태의 iop라고 할 수 있다. (2) 프로그램된 I/O I/O장치는 핸드셰이킹 방식으로 데이터를 전송한다.제 11 장. 입출력 구조 part-3강의 링크1) 우선순위 인터럽트 (Priority Interrupt)(1) 인터럽트 우선 순위 동시에 발생된 인터럽트의 우선 순위를 결정한다. 하드웨어 또는 소프트웨어 적으로 결정한다.(2) 데이지 체인 (Daisy Chain) 우선 순위 인터럽트 우선 순위에 따라서 인터럽트 처리 프로그램의 벡터 주소(VAD)를 CPU로 전달한다. 인터럽트 발생하여 인터럽트를 처리할 수 있으면 CPU가 interrupt acknowledge를 보낸다. 만약 device1, device3에서 인터럽트가 발생하면, 먼저 device1에 interrupt acknowledge를 보낸다. device1의 인터럽트 서비스 루틴을 실행한다. VAD(Vector address)1 -&gt; 인터럽트 서비스 루틴 시작 위치) device1의 interrupt acknowledge를 device2를 보낸다. device2는 인터럽트를 발생시키지 않은 것이기 때문에 device3에게 그대로 다시 보낸다. device3는 인터럽트가 발생했기 때문에, VAD3를 CPU에 보내 서비스 루틴을 실행한다.그 결과, 설계자는 중요한 device를 가장 먼저 interrupt를 실행하도록 설계해야 한다.(3) 병렬 우선순위 인터럽트(Parallel Priority Interrupt) 우선 순위 인코더를 사용한다. 우선 순위에 따른 VAD를 생성한다. 설계자는 인터럽트 서비스 루틴이 시작하는 VAD를 잘 설계해야 한다. CPU에 인터럽트를 전달한다. Mask 레지스터를 사용한다. 인터럽트 요청의 상태를 조절할 수 있다. (4) 인터럽트 동작 초기 동작 보다 낮은 단계의 mask 레지스터 비트를 0으로 set한다. (내 아래에 있는 애들의 인터럽트는 무시한다!) 인터럽트 상태 비트 IST &lt;- 0 ( 더 높은 단계의 인터럽트가 올 수 있도록 한다. ) 프로세서에 레지스터 비용(PSW)를 저장한다. 인터럽트 인에이블 비트 IEN &lt;- 1 (더 높은 단계의 인터럽트가 올 수 있도록 한다. ) 인터럽트 서비스 프로그램을 계속 실행한다. 최종 동작 인터럽트 인에이블 비트 IEN &lt;- 0 (이제는 완전히 다른 인터럽트를 막는다. ) PSW의 내용을 CPU에 복귀한다. 인터럽트에 관계된 레지스터 비트를 클리어 한다. 보다 낮은 순위의 mask비트를 1로 set한다. 복귀 주소를 PC에 저장한다 인터럽트 인에이블 비트 IEN &lt;- 1 2) 직접 메모리 접근 (Direct Memory Access) I/O장치가 CPU를 거치지 않고 메모리에 접근한다.(1) DMA 전송 구조 I/O 입출력을 처리하기 위해서 CPU를 방해하지 않는다. CPU가 사용하는 버스를 사용할 수 없기 때문에 메모리와 I/O가 각자 다른 버스를 사용하지 않는다면, DMA를 사용하기 어렵다. 그래서 사이크 스틸링을 사용한다. CPU의 명령어 사이클에서 메모리에 접근 안하는 타이밍(버스를 사용 안하는) 타이밍에 CPU대신에 메모리 버스를 사용한다. (2) DMA 동작 순서 DMA 전송 전송 초기화를 실행 한다. 메모리 버스와 입출력 버스간 연결한다. 메모리 버스로 직접 데이터를 전송한다. 완료 후, 전송 종료 인터럽트를 전송한다. DMA 전송 초기화 데이터 전송 메모리 주소를 전송한다. (Address register) 전송할 데이터 워드 수를 전송한다. (Word count register) 읽기 / 쓰기 신호를 결정한다. (R/W) DMA 전송 시작 신호 전송 3) 입출력 프로세서 (Input-Output Processor) DMA의 확장판(1) 정의 입출력 장치와의 직접적인 통신을 전담한다. 채널(Channel)로 호칭한다. CPU급의 DMA 제어기이다. DMA제어기와 달리 IOP는 고유의 명령어를 실행시킬 수 있다.4) 직렬 통신(Serial Communication)(1) 문자 지향 프로토콜 (Character-Oriented Protocol) SYN SYN Start Of Header STX Text ETX BCC     (text에 대한 에러 정보)       (text에 대한 에러 정보) 문자를 기반하는 text를 보낼 때는 위와 같은 형식으로 보내야 한다. 데이터 전송을 위한 약속이다.(2) 비트지향 프로토콜 (Bit-Oriented Protocol) 비 문자 데이터 전송용 format이다. Contorol field에 따라서 여러 데이터 형태를 결정한다." }, { "title": "컴퓨터구조-중앙-처리-장치", "url": "/posts/computerstructure07/", "categories": "CS, 컴퓨터-구조", "tags": "cs, 컴퓨터-구조", "date": "2022-08-02 00:00:00 +0900", "snippet": "중앙처리 장치 파트1강의링크1) CPU 주요 요소(1) 기억장치 레지스터의 집합 데이터 임시 저장 장소 이다. 데이터와 프로그램을 메인메모리에 저장되지만, 이것들이 수행되기 위해서는 레지스터로 이동해야 한다. 명령어는 IR레지스터로 이동! 데이터는 데이터 레지스터로 이동! (2) 제어장치 CPU 명령어를 처리하는 회로의 집합이다. 논리 게이트와 요소들로 구성되어 있다. 게이트 요소: 디코더, 멀티 플렉서, 인코더, 버퍼 와이어 명령어에 따라서 연산 제어를 수행한다. 필요한 타이밍에 연산 제어를 한다. (3) 연산장치 ALU 산술 연산, 논리 연산 및 시프트 연산을 수행한다.범용 레지스터 구조 ( General Register Organization)(1) 공용 ALU를 가진 레지스터 집합 소스 데이터를 어느 레지스터로 부터 가져와서 연산된 결과 값을 어떤 레지스터로 보낼 것인가. 7개의 범용 레지스터 연산에 사용할 데이터를 가져온다. 연산 결과를 저장한다. 공통 bus 버스를 활용하여 데이터를 이동시킨다. 8x1 MUX 2개 SELA: 어떤 데이터를 가져오는가. SELB: 이항연산일 경우 또다른 오퍼레드를 가져오는가. ALU OPR: 연산 종류 결정 연산결과를 어떤 레지스터로 보내는가 3x8 디코더 1개 load입력이 1일때 레지스터의 값이 들어가기 때문에 (SELD) 디코더를 활용해 어떤 레지스터에 데이터 결과를 load할 지 저장한다. 따라서 SELA, SELB, 오퍼레이션, SELD 비트가 이미 결정되어 있어야 한다.(2) 제어 워드 집합 SELA, SELB: ALU 입력을 결정한다. SELD: ALU 출력 저장소를 결정한다. OPR: 연산의 정류를 지정한다.2) 스택 구조 (Stack Organization)(1) 레지스터 스택 SP(Stack Pointer) 레지스터 지금 스택의 가장 꼭대기. 즉 가장 위의 번지 수를 저장하고 있다. FULL, EMPTY 플립플롭 FULL: 스택이 꽉 차면 1이된다. EMPTY: 스택이 비면 1이 된다. PUSH 동작 SP &lt;- SP +1 : 스택 포인터 증가 M[SP] &lt;- DR: 스택포인터가 가리키는 주소의 메모리에 데이터 레지스터에 있는 값을 넣는다. IF (SP = 0) then (FULL &lt;- 1): 만약 스택포인터가 0이면 (이전에 마지막 스택포인터를 가르키다가 0으로 돌아간 것) FULL 플립플롭을 1로 놓는다. EMPTY &lt;- 0 POP 동작 DR &lt;- M[SP] : 스택포인터가 가리키는 메모리에 있는 값을 데이터 레지스터로 이동시킨다. SP &lt;- SP - 1 IF (SP = 0 ) thend (EMPTY &lt;- 1) FULL &lt;- 0 (2) 메모리 스택 PUSH 동작 SP &lt;- SP -1: down-ward grow 스택구조 이기 때문에 아래로 내려갈 수록 주소가 커진다. M[SP] &lt;- DR POP 동작 DR &lt;- M[SP] SP &lt;- SP + 1 (2) 메모리 세그먼트 프로그램을 CPU가 동작시키기 위해 임의로 나눠놓은 메모리의 구획이다. 모든 프로그램은 Code / Data / Stack(Heap)로 구획을 나눌 수 있다. 하나의 세그먼트의 크기 MS-DOS / WIndows: 64KB UNIX / Linux: N x 1KB 블록 (3) 스택 오버 플로우 스택의 크기를 벗어나는 SP 값 stack point가 더 이상 증가할 수 없는데, push를 한다면 발생한다. (error) 메모리의 세그먼트 할당 크기가 제한이 있기 떄문이다. 특히, Protected mode에서 발생된다. protected mode: 하나의 프로세스가 다른 프로세스의 메모리를 침범할 수 없다. 다른 메모리의 영역에 침범하지 않도록 한다.(4) 스택 연산중앙처리 장치 파트2강의링크1) 명령어 형식 (Instruction Format) 오퍼랜드 주소를 몇개로 표시하는가에 따라 나뉜다. 3주소 명령어: source와 destination을 다 표시한다. 프로그램의 길이를 짤게 하지만, 명령어의 길이가 길어진다. 2주소 명령어: 연산코드 + 오퍼랜드 1 + 오퍼랜드 2 가장 일반적이다. 1주소 명령어: 연산 코드 + 오퍼랜드 (누산기에 의해 데이터를 처리한다) 무주소 명령어: 주소가 필요없다. 연산코드만 존재한다. (ex. stack) 2) 어드레싱 모드 (Addressing Mode) 연산에 사용될 데이터가 기억장치의 어디에 위치하는 지를 지정하는 방법(1) 다양한 어드레싱 모드를 사용하는 이유 제한된 명령어 비트로 오퍼랜드를 지정하기 때문이다. Pointer, couter Indexing기능 프로그램 재배치 (relocation) 편의를 제공한다. 프로그램 융통성을 위해 사용된다. 명령어 주소 필드 최소화(1) 직접 주소 모드 명령어의 주소 부분이 유효주소 (EA)를 표시한다. 분기 명령에서는 실제 분기 주소를 표시한다.(2) 간접 주소 모드 명령어의 주소 부분에 유효주소를 지정하는 주소 표시방법이다. 다양한 간접 주소 모드를 사용할 수 있다. 상대 주소 모드 인덱스 어드레싱 모드 베이스 레지스터 어드레싱 모드 ✅유효주소 계산 예시3) 데이터 전송과 처리 (Data Transfer and Manipulation)(1) ALU가 처리하는 명령어 산술 명령어 논리 연상 및 비트 처리 명령어 시프트 명령어4) 프로그램 제어 (Program Control)(1) 상태 비트 조건 상태비트를 확인하고 조건에 따라 프로그램을 제어한다. C: ALU 출력 캐리 값 S: AC의 부호 비트 Z: AC 값의 zero 여부 V: 연산 결과 오버플로우 여부(2) 조건부 분기 명령어 조건 값이 어떤 값이냐에 따라 분기를 하느냐 마느냐를 나누는 경우의 수 상태 비트에 따라서 분기한다.(3) 서브루틴 Call SQ &lt;- SP-1 M[SP] &lt;- PC: 복귀주소를 스택에 push 한다. PC &lt;- effective address: 내가 가야할 주소를 pc에 넣는다. Return PC &lt;- M[SP]: 복귀 주소로! SP &lt;- SP +1 순환 서브 루틴 (recursive Subroutine) 서브루틴이 자기 자신을 호출한다. 순환 call이 return 주소를 지워버리는 것을 방지하기 위하여 스택에 return 주소를 저장한다. 재귀함수를 돌리면 하나하나씩 스택에 복귀주소를 push되고 pop된다. (4) 프로그램 인터럽트 인터럽트를 처리하고 돌아오는 복귀주소를 스택에 저장하게 된다. 서브루틴과의 차이점 시스템 내, 외부적 신호에 의하여 프로그램 진행이 변경된다. 인터럽트 처리 루틴의 주소는 하드웨어 적으로 결정되어 있다. PC 값만 아니라 CPU의 다른 상태를 나타내는 정보도 대피한다. (메모리(스택)에 저장한다.) PSW (Program Status Word) 인터럽트가 발생할 때 저장되는 CPU 정보 PSW로 저장되는 데이터 프로그램 카운터(PC)의 값 모든 레지스터의 값 상태 조건 비트 (C, S, V, Z) :white_check_mark: 인터럽트 형태 외부 인터럽트 입출력 장치, 타이밍 장치, 전원 등 외부 요소에 의하여 발생한다. 내부 인터럽트 불법적인 명령이나 데이터를사용할 때 발생한다. ex) 오버 플로우, divided bt 0, segment fault 등 소프트웨어 인터럽트 명령어의 수행에 의하여 발생한다. Supervisior call 명령, System call 5) 간소화된 명령어 집합 컴퓨터 (RISC) 명령어가 줄어든 CPU(1) 정의 CISC(complex Instruction Set Computer) 에 비하여 새로운 설계 개념을 제시한다. 새로운 마이크로 아키텍쳐와 명령어 구조를 제시했다. 명령어가 많으면, 명령어 하나에 따를 제어장치를 만들어야 한다. 즉, 명령어가 많으면 제어장치가 커지고 복잡해질 수 있다. 제어장치가 줄어든 빈자리를 레지스터로 채워 넣는다. CISC보다 간단한 구조, 빠른 처리속도, 높은 효율을 자랑한다. CISC RISC 많은 수의 명령어 특별한 명령을 수행하는 일부 명령어는 자주 사용되지 않음 상대적으로 적은 수의 명렁어 다양한 어드레싱 모드 상대적으로 적은 수의 어드레싱 모드메모리 참조는 load/store 명령으로만 제한한다. 가변 길이 명령어 형식 고정된 길이의 명령어 형식 사용 메모리에서 피연산자 처리 모든 동작은 CPU 내 레지스터에서 수행한다.   단일 사이클의 명령어 실행   하드 와이어 제어 방식 사용 (2) 특징 적은 수의 명령어로 인한 장점 제어 장치의 간소화로 여유 공간 확보 많은 수의 레지스터 (128개 이상) 제어장치를 하드 와이어 방식으로 구현 효과적인 명령어 파이프라인 사용 프로시저의 빠른 호출 / 복귀를 위한 중첩된 레지스터 윈도우 사용 빠르고 효과적인 구조의 컴파일러 고정 길이 명령어 사용으로 인한 간단한 디코딩 단일 사이클의 명령어 실행:white_check_mark: 중첩된 레지스터 윈도우 프로시저에 사용할 파라미터를 전달한다. 중첩된 윈도우를 통하여 보호모드에서 빠른 데이터를 전달한다. CPU에서 여러개의 프로시저(함수 혹은 하나의 프로세서)를 실행할 때, 프로시저간 데이터를 전달하려면 OS의 도움을 받아 전달해야 한다. 그런데 공통영역을 사용할 수 있도록 만들고 해당 공간에 데이터를 던지면 간편하게 데이터를 전달할 수 있다. 많은 수의 레지스터로 인한 구조적 장점이 있다." }, { "title": "v-model을-활용하여-멀티-레인지-슬라이더-만들기", "url": "/posts/vue04/", "categories": "WEB, Vue", "tags": "vue", "date": "2022-07-30 00:00:00 +0900", "snippet": " 칵테일 검색 필터를 구현하던 중 도수의 범위를 지정하기 위해서 멀티 레인지 슬라이더가 필요했다. 몇번의 구글링 결과 도움이 되는 블로그를 찾았고 이를 기반으로 vue3에서 어떻게 멀티 레인지 슬라이더를 만들 수 있는지 정리해보았다.참고한 블로그1) 슬라이더 마크업슬라이더는 track과 thumb로 구성되어 있다. 멀티 레인지를 만들기 위해서는 아래와 같은 input을 겹쳐 thumb를 2개로 만들어 구현할 수 있다.(1) 슬라이더를 만든다.&lt;template&gt; &lt;div class=\"cocktail-search-filter-slider\"&gt; &lt;!-- 진짜 슬라이더 --&gt; &lt;input type=\"range\" id=\"slider-left\" max=\"30\" min=\"0\" value=6 /&gt; &lt;input type=\"range\" id=\"slider-right\" max=\"30\" min=\"0\" value=15 /&gt; &lt;!-- 가짜 슬라이더 --&gt; &lt;div class=\"filter-slider\"&gt; &lt;div class=\"filter-slider-line\"&gt;&lt;/div&gt; &lt;div class=\"filter-slider-range\" :style=\"rangeStyle\"&gt;&lt;/div&gt; &lt;div class=\"filter-slider-left\" :style=\"leftThumbStyle\"&gt;&lt;/div&gt; &lt;div class=\"filter-slider-right\" :style=\"rightThumbStyle\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;input type=\"range\"&gt;인 슬라이더 2개를 만든다. (진짜 슬라이더) 왼쪽 thumb이 될 슬라이더 오른쪽 thumb 될 슬라이더 사용자에게 보일 가짜 슬라이더를 만든다. (가짜 슬라이더) 슬라이더를 다 겹치게 한다.아래처럼 진짜 슬라이드 2개와 가짜 슬라이더를 다 겹치게 한다.(2) 가짜 슬라이더만 보이게 한다.&lt;template&gt; &lt;!-- 생략 --&gt; &lt;/template&gt;&lt;script setup lang=\"ts\"&gt;&lt;/script&gt;&lt;style scoped lang=\"scss\"&gt;/* 진짜 슬라이더 */.cocktail-search-filter-slider { @include flex(column); position: relative; width: 95%; input { position: absolute; z-index: 1; width: 100%; height: 8px; background-color: black; opacity: 0; appearance: none; pointer-events: none; /* thumb에만 설정을 한다. (크롬) */ &amp;::-webkit-slider-thumb { z-index: 10; width: 32px; height: 32px; background-color: black; cursor: pointer; appearance: none; pointer-events: all; } /*thumb에만 설정을 한다. (파이어 폭스) */ &amp;::-moz-range-thumb { z-index: 10; width: 32px; height: 32px; background-color: black; cursor: pointer; appearance: none; pointer-events: all; } }&lt;/style&gt;✅ 진짜 슬라이더를 투명하게 하여 사용자가 볼 수 없지만 사용자가 진짜 slider의 thumb을 움직여 value를 수정할 수 있도록 한다. appearance속성을 통해 수정한 CSS를 반영한다. pointer-events를 통해 진짜 슬라이더가 포인트의 이벤트 대상이 되지 않도록 한다. 그러나 thumb는 마우스를 통해 이동시켜야 하기 때문에 해당 부분만 포인트의 대상이 되도록 한다. 크롬: ::-webkit-slider-thumb로 접근이 가능하다. 파이어 폭스: ::-moz-range-thumb로 접근이 가능하다. 결국 아래처럼, 가짜 슬라이더만 보이는 상태이다 (그러나 진짜 Slider의 thumb은 이동시킬 수 있다.)2) 진짜 슬라이더의 value에 따라 가짜 슬라이더를 움직인다.다음처럼 진짜 슬라이더의 thumb에 따라 가짜 슬라이더도 움직이게 해야 한다.(1) v-model을 통해 진짜 슬라이더의 value를 가져온다.&lt;template&gt; &lt;div class=\"cocktail-search-filter-slider\"&gt; &lt;!-- 진짜 슬라이더 --&gt; &lt;input type=\"range\" id=\"slider-left\" max=\"30\" min=\"0\" v-model.number=\"sliderLeftValue\" /&gt; &lt;input type=\"range\" id=\"slider-right\" max=\"30\" min=\"0\" v-model.number=\"sliderRightValue\" /&gt; &lt;!-- 가짜 슬라이더 --&gt; &lt;div class=\"filter-slider\"&gt; &lt;div class=\"filter-slider-line\"&gt;&lt;/div&gt; &lt;div class=\"filter-slider-range\"&gt;&lt;/div&gt; &lt;div class=\"filter-slider-left\"&gt;&lt;/div&gt; &lt;div class=\"filter-slider-right\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import { ref, watch } from \"vue\";// v-model로 연결한 값const sliderLeftValue = ref(6);const sliderRightValue = ref(15); // sliderLeftValue의 값이 변하면 함수를 실행한다.watch(sliderLeftValue, () =&gt; { console.log(sliderLeftValue.value);});&lt;/script&gt;이렇게 vue의 v-model을 활용하여 진짜 슬라이더의 value에 간단하게 접근할 수 있다. 접근한 값을 가지고 가짜 슬라이더의 thumb를 움직이면 된다.(2) 진짜 슬라이더의 value에 따라 가짜 슬라이더가 움직인다. 진짜 슬라이더의 value에 따라 가짜 슬라이더의 left, width값을 수정하여 가짜 슬라이더의 thumb와 thumb간의 범위를 변경할 수 있다.&lt;template&gt; &lt;div class=\"cocktail-search-filter-slider\"&gt; &lt;!-- 진짜 슬라이더 --&gt; &lt;input type=\"range\" id=\"slider-left\" max=\"30\" min=\"0\" v-model.number=\"sliderLeftValue\" /&gt; &lt;input type=\"range\" id=\"slider-right\" max=\"30\" min=\"0\" v-model.number=\"sliderRightValue\" /&gt; &lt;!-- 보이는 슬라이더 --&gt; &lt;div class=\"filter-slider\"&gt; &lt;div class=\"filter-slider-line\"&gt;&lt;/div&gt; &lt;!-- 스타일 바인딩 --&gt; &lt;div class=\"filter-slider-range\" :style=\"rangeStyle\"&gt;&lt;/div&gt; &lt;div class=\"filter-slider-left\" :style=\"leftThumbStyle\"&gt;&lt;/div&gt; &lt;div class=\"filter-slider-right\" :style=\"rightThumbStyle\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import { ref, reactive, watch, computed } from \"vue\";// 진짜 Slider thumb의 초기 위치const sliderLeftValue = ref(6);const sliderRightValue = ref(15);// 가짜 Slider thumb의 초기 위치 계산const leftThumbStyle = reactive({ left: `${(sliderLeftValue.value / 30) * 100}%`,});const rightThumbStyle = reactive({ left: `${(sliderRightValue.value / 30) * 100}%`,});const rangeStyle = reactive({ left: `${(sliderLeftValue.value / 30) * 100}%`, width: `${((sliderRightValue.value - sliderLeftValue.value) / 30) * 100}%`,});// 왼쪽 SliderValue값이 변할 때 실행된다.watch(sliderLeftValue, () =&gt; { // 값 변경: 가짜 슬라이더의 왼쪽 thumb이동, range 이동 및 너비 변경 leftThumbStyle.left = `${(sliderLeftValue.value / 30) * 100}%`; rangeStyle.left = `${(sliderLeftValue.value / 30) * 100}%`; rangeStyle.width = `${ ((sliderRightValue.value - sliderLeftValue.value) / 30) * 100 }%`;});// 오른쪽 SliderValue값이 변할 때 실행된다.watch(sliderRightValue, () =&gt; { // 값 변경: 가짜 슬라이더의 오른쪽 thumb이동, range 너비 변경 rightThumbStyle.left = `${(sliderRightValue.value / 30) * 100}%`; rangeStyle.width = `${ ((sliderRightValue.value - sliderLeftValue.value) / 30) * 100 }%`;});&lt;/script&gt;✅ 진짜 슬라이더의 value에 따라 가짜 슬라이더의 스타일 속성 값이 변한다. 가짜 슬라이더의 thumb의 위치가 변한다. 스타일 속성의 left의 값에 변화를 준다. 위치 변화 가짜 슬라이더 사이의 범위를 나타내는 range의 위치와 너비가 변한다. 스타일 속성의 left의 값에 변화를 준다. 위치 변화 스타일 속성의 width의 값에 변화를 준다. 너비 변화 (3) 범위 제한을 통해 thumb끼리 서로 엇갈리지 않도록 한다.그러나, 위와 같이 구현을 끝낼 경우 아래와 같은 문제가 발생한다.😅그래서 thumb이 서로의 영역을 침범하지 않도록 범위를 제한해야 한다.&lt;template&gt;&lt;!-- 생략 --&gt;&lt;/template&gt;&lt;script&gt;// 생략..// 왼쪽 Slider Value값이 변할 때 실행된다.watch(sliderLeftValue, () =&gt; { // 왼쪽 thumb의 맥시멈 if (sliderLeftValue.value &gt; 27) { sliderLeftValue.value = 27; } // 서로의 영역을 침범하지 않기 위한, 범위 제한 if (sliderRightValue.value &lt;= sliderLeftValue.value + 3) { sliderLeftValue.value = sliderRightValue.value - 3; } // 값 변경 leftThumbStyle.left = `${(sliderLeftValue.value / 30) * 100}%`; rangeStyle.left = `${(sliderLeftValue.value / 30) * 100}%`; rangeStyle.width = `${ ((sliderRightValue.value - sliderLeftValue.value) / 30) * 100 }%`;});// 오른쪽 Slider Value값이 변할 때 실행된다.watch(sliderRightValue, () =&gt; { // 오른쪽 thumb의 미니멈 if (sliderRightValue.value &lt; 3) { sliderRightValue.value = 3; } // 서로의 영역을 침범하지 않기 위한, 범위 제한 if (sliderRightValue.value - 3 &lt;= sliderLeftValue.value) { sliderRightValue.value = sliderLeftValue.value + 3; } // 값 변경 rightThumbStyle.left = `${(sliderRightValue.value / 30) * 100}%`; rangeStyle.width = `${ ((sliderRightValue.value - sliderLeftValue.value) / 30) * 100 }%`;});&lt;/script&gt;이제는 서로 영역을 침범하지 않는 것을 확인할 수 있다.3) 로컬스토리지에 value를 저장하고 불러온다.앞서 말했듯이, 이는 필터를 구현하기 위해 필요한 기능이다. (칵테일을 검색할 때, 도수 범위를 설정하여 칵테일 검색에 도움을 주기 위한 기능)이런 필터는 다시 웹사이트에 방문했을 때도 기록이 남아있어 사용자가 재사용한다면 편리한 기능이라고 생각했기 때문에 사용자가 지난번에 설정했던 값을 로컬 스토리지에 저장해서 불러오도록 했다.&lt;script setup lang=\"ts\"&gt;import { ref, reactive, watch, computed } from \"vue\";import { useStore } from \"vuex\";const store = useStore();// 진짜 슬라이더 valueconst sliderValue = computed( () =&gt; store.getters[\"cocktailSearch/getSearchFilterAlcoholStrength\"]);const sliderLeftValue = ref(sliderValue.value[0]);const sliderRightValue = ref(sliderValue.value[1]);// 진짜 슬라이더 값이 변경될 때, vuex에 값을 저장한다.// 디바운스 사용하여 과도한 함수 실행을 막는다.let debounce: ReturnType&lt;typeof setTimeout&gt;;watch([sliderLeftValue, sliderRightValue], () =&gt; { if (debounce) { clearTimeout(debounce); } debounce = setTimeout( () =&gt; store.dispatch(\"cocktailSearch/changeFilterAlcoholStrength\", [ sliderLeftValue.value, sliderRightValue.value, ]), 200 );});// 생략&lt;/script&gt; 로컬 스토리지에 value가 저장되어 있으면 vuex로 가져온다. 없으면 기본 값을 설정한다. 초기 value 값을 vuex에서 가져오고, value가 변경 될 때 vuex에 값을 저장한다. (debounce 활용)" }, { "title": "ERROR-Vue3-router에서-네비게이션-가드-설정하는-방법", "url": "/posts/vue03/", "categories": "WEB, Vue", "tags": "vue", "date": "2022-07-27 00:00:00 +0900", "snippet": "네비게이션 가드 공식문서네비게이션 가드란 특정 페이지를 보호하기 위해 사용하는 방법으로서 URL의 접근을 제한하는 것을 의미한다.😥 문제 상황 로그인을 하지 않은 유저: 개인 정보 수정, 회원 탈퇴 페이지에 접근을 못한다. 로그인을 한 유저: 로그인, 회원가입 페이지에 접근을 못한다. 회원 관리에 관한 페이지를 개발한 후, 로그인 여부에 따라 페이지에 접근할 수 있는 것을 제한하려 했다. 그러나 로그인 여부 자체를 인식하지 못했다.1) 로그인 유저인지 확인을 못하나..?로그인유저 확인 로직 로그인 했을 때, 유저의 access토큰과 refresh토큰을 로컬 스토리지와 vuex에 저장한다. 브라우저를 재 시작 했을 때, 로컬 스토리지에 토큰 정보가 있으면 이를 vuex에 저장한다. vuex에 토큰이 저장되어 있을 경우 해당 유저는 로그인 유저로 간주한다.vuex를 확인해보면, 로그인 여부는 잘 확인하고 있는 것을 알 수 있었다.2) Router 코드가 문젠가..// src/router.ts import { computed } from \"vue\";import { useStore } from \"vuex\"const store = useStore()// Navigation Guard 설정: 오류를 해결하기 위해 임의로 any타입을 사용했다. router.beforeEach((to: any, from, next) =&gt; { // 로그인 여부 확인 const isLoggedIn = computed(() =&gt; store.getters[\"personalInfo/isLoggedIn\"]); // 로그인이 필요한 페이지 const authPages = [\"TheSignOutView\", \"TheChangeUserView\", \"TheChangePwView\"]; // 로그인이 되어있지 않을 때만 가능한 페이지 const notAuthPages = [\"TheSignupView\", \"TheLoginView\"]; // 1. 현재 이동하고자 하는 페이지가 로그인이 필요한지 확인 const isAuthRequired = authPages.includes(to.name); const isNotAuthRequired = notAuthPages.includes(to.name); // 2. 로그인이 필요한 페이지인데 로그인이 되어있지 않다면 로그인 페이지(/login)로 이동 if (isAuthRequired &amp;&amp; !isLoggedIn.value) { next({ name: \"TheLoginView\" }); // 3. 로그인이 되어있는데 /login, /signup 페이지로 이동한다면 메인 페이지(/)로 이동 } else if (isNotAuthRequired &amp;&amp; isLoggedIn.value) { next({ name: \"TheHomeView\" }); // 4. 원래 이동 페이지 } else { next(); }});router.ts에 네비게이션 가드로 작성한 코드가 로직적인 문제가 있는지 확인해 보았다. 현재 유저가 로그인 유저인지 확인한다. 유저의 로그인 상태에 따라 접근할 수 있는 페이지와 접근할 수 없는 페이지를 나눈다. 현재 이동하고자 하는 페이지가 어떤 페이지 인지 확인한다. 현재 이동하고자 하는 페이지가 어디에 속해있는지 includes함수를 통해 확인 1~3에서 확인한 유저의 로그인 여부와 이동하고자 하는 페이지의 종류에 따라 이동되는 분기가 나뉜다. 권한이 없는 페이지에 이동하려고 할 시, 지정된 페이지로 이동 권한이 있는 페이지에 이동하려고 할 시, 원래 이동하려고 하는 페이지로 이동 로직은 큰 문제가 없는 것 같은데.. 🤔🤸‍♂️ 해결 방법위의 코드에서 문제가 되는 부분은 다음과 같다.// src/router.ts const isLoggedIn = computed(() =&gt; store.getters[\"personalInfo/isLoggedIn\"]);console.log(isLoggedIn)console에 찍어보니 undefined가 출력 되어 로그인 여부를 확인할 수 없는 것이다. 분명 store에는 값이 잘 저장되어 있는데 왜 값을 못 가져오는 걸까.기존에 컴포넌트에서 store를 접근할 때는 useStore라는 메서드를 통해 접근할 수 있기 때문에 외부 ts파일도 이렇게 접근이 가능할 것이라고 생각했었다. 그러나 같은 코드로 접근하면 안된다.// src/main.tsimport { createApp } from \"vue\";import App from \"./App.vue\";import router from \"./router\";import store from \"./store\";const app = createApp(App);app.use(store).use(router);app.mount(\"#app\"); vue는 이렇게 main.ts에서 store가 연동되어 있기 때문에 {useStore}메서드로 접근을 할 수 있다. (추측..) 그래서 vue파일이 아닌 외부 파일에서 접근을 하기 위해서는 직접 store에 접근해서 store를 가져와야 한다.// src/store/index.tsimport { createStore } from \"vuex\";import { account, AccountState } from \"../store/accounts/account\";import { signup, SignupState } from \"../store/accounts/signup\";import { password, PasswordState } from \"../store/accounts/password\";import { personalInfo, PersonalInfoState} from \"../store/accounts/personalInfo\";// 모듈의 state를 공유한다.export interface RootState { account: AccountState; signup: SignupState; personalInfo: PersonalInfoState; password: PasswordState;}// store를 생성한다.export default createStore({ modules: { account, signup, personalInfo, password, },}); store를 createStore를 통해 export하고 있기 때문에 createStore로 vuex의 store에 접근하면 된다.import { computed } from \"vue\";import createStore from \"../src/store/index\";// 스토어 정의const store = createStore;// Navigation Guard 설정: 오류를 해결하기 위해 임의로 any타입을 사용했다. router.beforeEach((to: any, from, next) =&gt; { const isLoggedIn = computed(() =&gt; store.getters[\"personalInfo/isLoggedIn\"]); const authPages = [\"TheSignOutView\", \"TheChangeUserView\", \"TheChangePwView\"]; const notAuthPages = [\"TheSignupView\", \"TheLoginView\"]; const isAuthRequired = authPages.includes(to.name); const isNotAuthRequired = notAuthPages.includes(to.name); if (isAuthRequired &amp;&amp; !isLoggedIn.value) { next({ name: \"TheLoginView\" }); console.log(\"로그인 하지 않은 유저는 돌아가시오\") } else if (isNotAuthRequired &amp;&amp; isLoggedIn.value) { next({ name: \"TheHomeView\" }); } else { next(); }});문제 없이 잘 작동 하는 것을 확인할 수 있다 😀" }, { "title": "05-TpyeScript-제네릭", "url": "/posts/ts04/", "categories": "WEB, TypeScript", "tags": "TypeScript", "date": "2022-07-24 00:00:00 +0900", "snippet": "강의링크섹션 7. 제네릭1) 제네릭이란 제네릭 타입은 타입에 유연성을 제공하여 재사용을 가능하게 해주는 타입이다. 타입 정보가 동적으로 결정된다.즉, 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하여 한번의 선언으로 다양한 타입에 재사용이 가능하다. () 제네릭을 사용하면 함께 작동하는 데이터 구조를 만들거나 다양한 타입의 값을 래핑할 수 있다.)//배열타입 생성const names = [\"Max\", \"Manuel\"];// 에러 발생const nameA: Array = []Array라는 타입을 지정하려고 하니, 이는 제네릭 타입이고 하나의 인수가 필요하다고 말하고 있다. 배열은 그 자체로 타입이지만, 배열에 특정 타입의 데이터를 저장할 수 있다. 배열타입은 어떤 타입의 데이터가 저장되든 상관하지 않지만 적어도 정보가 저장되는 것인지에 대해 확인을 하기 때문이다.// 홑화살 괄호 내에 배열에 전달되어야 하는 데이터의 타입을 지정한다.const nameB: Array&lt;string&gt; = []; // string[]과 같다.이렇게 &lt;&gt;사이에 타입을 지정해주는 것을 제네릭이라고 한다. 배열의 경우에는 배열 내부에 존재하는 타입에 대해서 설정했지만, 타입마다 이는 다르다. 예를 들어 Promise 타입을 살펴보자.// 문자열을 반환한다. const promise: Promise&lt;string&gt; = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(\"This is done!\"); }, 2000);});배열은 특정 타입의 데이터를 저장하기 때문에 해당 내용을 표현을 하게 되고 프로미스는 특정 타입의 데이터를 반환하기 때문에 해당 타입을 &lt;&gt;안에 기입한다.2) 제네릭 함수function merge(objA: object, objB: object) { return Object.assign(objA, objB)};const mergedObjA = merge({name: \"MAX\"}, {age:30})// 접근할 수 없음: object를 반환하지만 name속성이 있는지 모르기때문에 mergedObjA.name// 그래서 as를 써서 정의를 할수 있지만, 번거롭다. const mergedObjB = merge({name: \"MAX\"}, {age:30} as {name: string, age: number})// 접근 가능 mergedObjB.namemergedObjA와 같은 상황이 발생하는 이유는 타입스크립트는 객체를 반환하는 것을 추론하지만, 정확히 어떤 정보를 담고 있는지 모르기 때문에 상세히 알려 주어야 하기 때문이다. 해당 객체에서 사용할 수 있는 정보를 모두 담고 있지 않기 때문에 우리는 번거롭게 정보를 자세히 전달해야 한다. 이럴 때 제네릭을 사용하여 타입을 동적으로 할당하여 유연하게 사용할 수 있다.function merge&lt;T extends object, U extends object&gt;(objA: T, objB: U) { return Object.assign(objA, objB);}const mergedObjB = merge({ name: 'Max', hobbies: ['Sports'] }, { age: 30 });console.log(mergedObj);제네릭 타입을 사용하면 이 두 매개변수가 종종 서로 다른 타입이 될 수 있다고 타입스크립트에 알려줄 수 있으므로 무작위의 객체 타입으로 작업하는 것이 아닌 다양한 타입 데이터를 얻고자 한다는 것을 타입스크립트가 인식하게 된다. 또한, 이 함수는 T와 U의 인터섹션을 반환한다고 추론한다. 즉, 이 함수를 정의할 때 이러한 타입들이 고정적으로 설정되지 않고 함수를 호출할 때 동적일 수 있도록 설정한 것이다.이렇게 된다면, mergeObjB는 name: string과 age: number 객체로 전달한다는 것과 함수가 인터섹션을 반환한다는 것을 알게 된다. T: 객체 타입을 문자열을 지닌 name 속성이 있는 객체로 hobbie 속성은 문자열의 배열로 작성 U: 숫자형 타입인 age 속성을 지닌 객체 타입으로 작성그리고 반환 값인 T&amp;U이기 때문에 해당 객체들의 모든 속성에 접근할 수 있게 된다.(1) 타입 제약 조건 불필요한 에러나 이상한 작동을 방지하여 최적의 방식으로 제네릭 타입을 제한 하는 것// 타입을 제한한다. function merge&lt;T extends object, U extends object&gt;(objA: T, objB: U) { return Object.assign(objA, objB);}const mergedObj = merge({ name: 'Max', hobbies: ['Sports'] }, { age: 30 });console.log(mergedObj);Object.assign때문에 매개변수는 객체만 올 수 있기 때문에 제네릭 타입에 특정한 제약 조건을 설정하므로써 객체만 매개변수로 전달될 수 있도록 할 수 있다. 제약 조건에는 무엇이든 지정이 가능하다. 객체, 문자열, 직접 만든 타입, 유니언 타입등 다양한 제약조건을 추가할 수도 있고 U에만 제약을 설정할 수도 있다. 유연하게 제약을 걸 수 있기 때문에 유용한 기능이다.(2) 속성interface Lengthy { length: number;}function countAndDescribe&lt;T extends Lengthy&gt;(element: T): [T, string] { let descriptionText = 'Got no value.'; if (element.length === 1) { descriptionText = 'Got 1 element.'; } else if (element.length &gt; 1) { descriptionText = 'Got ' + element.length + ' elements.'; } return [element, descriptionText];}console.log(countAndDescribe(['Sports', 'Cooking']));// 에러 발생: number는 length속성이 없기 때문이다.console.log(countAndDescribe(3));타입의 속성에 접근할 때, 해당 속성이 있는지 여부를 파악하기 위해서 타입 제약 조건을 활용할 수 있다. length속성의 경우 문자열이나 배열의 타입에 있는 속성이다. 그러나 제네릭을 사용하면 무작위로 타입을 사용할 수 있기 때문에, length속성을 사용할 수 있는 타입스크립트는 알 수 없다. 그래서 타입스크립트에게 우리는 “length속성이 있는 타입을 사용할 거야~”라고 말해 줄 수 있다.이처럼 보다 유연한 작업이 요구될 때 제네릭 유형을 사용하면 제약 조건 덕분에 정확한 타입에 대해 신경 쓰지 않고 length 속성이 있는지만 신경 쓰면 된다.(3) keyof// 에러 발생: 여기 입력한 객체가 무엇이든 이 키를 가지는 지 모르기 때문function extractAndConvert(obj:object, key:string){ return obj[key];}타입스크립트가 이 객체에 이 키가 있는지 보장할 수 없기 때문에 에러가 발생한다. 이를 보장하려면 제네릭 타입을 사용하면 된다.function extractAndConvert&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) { return 'Value: ' + obj[key];}extractAndConvert({ name: 'Max' }, 'name');key of를 활용하여 U타입은 T타입의 key인 것을 명시적으로 알려 줄 수 있다. 즉, keyof 키워드를 지니는 제네릭 타입을 사용하여 정확한 구조를 타입스크립트에게 알려주어 실수를 하지 않도록 도와준다.3) 제네릭 클래스 클래스를 정의할 때도 메서드나 속성의 타입을 나중에 확정할 수 있다. 즉, 인스턴스를 호출할 때 정한다.// 원시 타입으로 제한했다.class DataStorage&lt;T extends string | number | boolean&gt; { private data: T[] = []; addItem(item: T) { this.data.push(item); } removeItem(item: T) { if (this.data.indexOf(item) === -1) { return; } this.data.splice(this.data.indexOf(item), 1); // -1 } getItems() { return [...this.data]; }}const textStorage = new DataStorage&lt;string&gt;();textStorage.addItem('Max');textStorage.addItem('Manu');textStorage.removeItem('Max');console.log(textStorage.getItems());const numberStorage = new DataStorage&lt;number&gt;();이렇게 되면 한 가지 타입으로만 국한되어 클래스 작업을 하지 않아도 된다. 이처럼 데이터의 타입이 무엇이든 상관없다면 제네릭을 통해 유연하게 코드를 작성할 수 있다.4) 제네릭 유틸리티 타입 TypeScript는 일반적인 타입 변환을 쉽게 하기 위해서 몇 가지 유틸리티 타입을 제공한다.공식문서(1) partial 모든 프로퍼티를 선택적으로 타입을 생성한다. (특정 타입의 부분 집합을 만족하는 타입을 정의할 수 있다. )interface CourseGoal { title: string; description: string; completeUntil: Date;}function createCourseGoal( title: string, description: string, date: Date): CourseGoal { let courseGoal: Partial&lt;CourseGoal&gt; = {}; // courseGoal의 타입의 속성을 선택적으로 갖는 객체이다. courseGoal.title = title; courseGoal.description = description; courseGoal.completeUntil = date; return courseGoal as CourseGoal; // 반환할 때, courseGoal로 형 변환하여 반환한다.}courseGoal이 partial 타입이어야 한다고 설정하면 제네릭 타입 덕분에 결과적으로 courseGoal 타입을 지니게 된다. 이렇게 객체나 인터페이스의 속성을 일시적으로 선택적이 되어야 하는 경우가 발생하면, partial타입으로 구현할 수 있다.(2) Readonly 모든 속성이 읽기 전용(readonly)으로 설정한 타입을 생성한다, 즉 생성된 타입의 프로퍼티는 재할당될 수 없다.const names: Readonly&lt;string[]&gt; = [\"Max\", \"Anna\"];// 에러!!names.push('Manu');names.pop();" }, { "title": "ERROR-Vue3-CompositionAPI에서-동적-컴포넌트-사용하는-방법", "url": "/posts/vue02/", "categories": "WEB, Vue", "tags": "vue", "date": "2022-07-23 00:00:00 +0900", "snippet": "😥 문제 상황회원 관리 기능을 구현하면서 비밀번호 찾기 view에서 사용자의 진행 단계에 따라 컴포넌트가 변경되어 보여주는 페이지를 만들고 있는 중에 오류가 발생했다.간단하게 동적 컴포넌트를 활용하여 구현하려 했으나, 기존의 Vue2 방식으로 동적 컴포넌트를 설정했더니 작동이 되지 않는 오류가 발생했다. 작동이 되지 않는 코드는 다음과 같다.&lt;!-- src/view/ForgotPwView.vue --&gt; &lt;template&gt; &lt;div class=\"forgot-pw-view\"&gt; &lt;header-basic :prev=\"true\" :success=\"false\" @prevClicked=\"$router.go(-1)\"&gt; 비밀번호 찾기 &lt;/header-basic&gt; &lt;section class=\"forgot-pw-section\"&gt; &lt;p&gt;회원님의 비밀번호를 찾기 위해서　&lt;/p&gt; &lt;p&gt;이름, 아이디, 이메일이 필요합니다.&lt;/p&gt; &lt;!-- 동적 컴포넌트 --&gt; &lt;component :is=\"currentComponent\"&gt; &lt;/component&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import HeaderBasic from \"@/components/basics/HeaderBasic.vue\";import TheForgotPwForm from \"@/components/accounts/TheForgotPwForm.vue\";import { clickPrevButton } from \"../modules/clickEvent\";import { computed } from \"vue\";import { useStore } from \"vuex\"; const store = useStore();// 현재 컴포넌트에 대한 정보const currentComponent = computed( () =&gt; store.getters[\"account/getForgotPwCurrentTab\"]);&lt;/script&gt;현재 component에 대한 정보를 currentComponent변수와 연결은 한다. 해당 변수는 vuex에 현재 컴포넌트에 대한 정보를 저장하고 있는 state를 가져온다.// src/store/accounts/account.tsimport { Module } from \"vuex\";import { RootState } from \"../index\";export interface AccountState { forgotPwCurrentTab: string;}export const account: Module&lt;AccountState, RootState&gt; = { namespaced: true, state: { // 현재 활성화된 컴포넌트 정보를 저장하는 state forgotPwCurrentTab: \"TheForgotPwForm\", }, getters: { // forgotPwCuurentTan state 값을 호출하는 getters getForgotPwCurrentTab: (state) =&gt; { return state.forgotPwCurrentTab; }, }, mutations: { // forgotPwCurrenTab의 값을 수정하는 mutations SET_FORGOT_PW_CURRENT_TAB: (state, value) =&gt; { state.forgotPwCurrentTab = value; }, }, actions: { // forgotPwCurrentTab 값을 수정하는 함수를 호출하는 actions changeForgotPwCurrentTab: ({ commit }, value) =&gt; { commit(\"SET_FORGOT_PW_CURRENT_TAB\", value); }, },}; currentComponent에 컴포넌트 이름이 할당되어있는 것을 확인했지만, 화면으로는 구성되지 않는 것을 확인할 수 있다. 즉, 변수에 올바른 컴포넌트 이름이 할당되는 됨에도 불구하고 페이지에는 나타나지 않는다. vue2에서는 아래와 같이 컴포넌트 이름을 등록한다. Hoxy…? 이것 때문일까? 🤔 &lt;script&gt; export default { components: { componentName }}&lt;/script&gt; 😎 해결 방법DefineAsyncComponent 사용공식 문서지역적으로 컴포넌트를 등록할 때 비동기 컴포넌트를 사용할 수 있기 때문에, view에 컴포넌트를 등록하면 동적 컴포넌트를 사용할 수 있다.&lt;template&gt; &lt;div class=\"forgot-pw-view\"&gt; &lt;header-basic :prev=\"true\" :success=\"false\" @prevClicked=\"$router.go(-1)\"&gt; 비밀번호 찾기 &lt;/header-basic&gt; &lt;section class=\"forgot-pw-section\"&gt; &lt;p&gt;회원님의 비밀번호를 찾기 위해서　&lt;/p&gt; &lt;p&gt;이름, 아이디, 이메일이 필요합니다.&lt;/p&gt; &lt;component :is=\"currentComponent\"&gt; &lt;/component&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import HeaderBasic from \"@/components/basics/HeaderBasic.vue\";import TheForgotPwForm from \"@/components/accounts/TheForgotPwForm.vue\";import { clickPrevButton } from \"../modules/clickEvent\";import { computed, defineAsyncComponent } from \"vue\";import { useStore } from \"vuex\";const store = useStore(); // 이제 vuex에는 컴포넌트 이름을 기록 하는 것이 아니라, 컴포넌트 인덱스를 기록한다. const index = computed(() =&gt; store.getters[\"account/getForgotPwCurrentTab\"]); // 0// 컴포넌트를 등록하여 배열에 기록한다. const componentArray = [ defineAsyncComponent( () =&gt; import(\"@/components/accounts/TheForgotPwForm.vue\") ), defineAsyncComponent( () =&gt; import(\"@/components/accounts/ThePasswordChangeForm.vue\") ),];// 활성화된 컴포넌트const currentComponent = computed(() =&gt; { return componentArray[index.value];});&lt;/script&gt;" }, { "title": "vue3에서-타입스크립트로-vuex4-사용하기", "url": "/posts/vue01/", "categories": "WEB, Vue", "tags": "vue", "date": "2022-07-19 00:00:00 +0900", "snippet": "vue3환경에서 타입스크립트로 vuex를 사용하는 방법을 정리해보았다.먼저, vuex4를 설치한다.$ npm install vuex@next --save1. 기본 준비1) main.ts에 스토어를 세팅한다import { createApp } from \"vue\";import \"./style.css\";import App from \"./App.vue\";import router from \"./router\";import store from \"./store\";createApp(App).use(store).use(router).mount(\"#app\");store를 import한 뒤 store를 사용한다고 설정한다.2) store 폴더를 생성한다.src에 store 폴더를 생성한다. vuex를 기능별로 모듈화해서 구현할 것이기 때문에 다음과 같은 폴더 구조를 가지고 있다. store modules moduleA.ts moduleB.ts index.ts 2. store 설정1) moduleA.tsstate도 타입을 설정해주어야 한다. state의 타입을 한 번에 설정하기 위해 interface를 사용한다.import { Module } from \"vuex\";import { RootState } from \"../index\";// 인터페이스를 사용하여 ModuleA의 State 타입을 설정한다.export interface ModuleAState { counter: number;}// state의 타입추론이 잘 되게 하기 위해 사용한다.export const moduleA: Module&lt;ModuleAState, RootState&gt; = { namespaced: true, state: { counter: 0, }, getters: { getCounter: (state) =&gt; { return state.counter; }, }, mutations: { SET_COUNTER: (state, value) =&gt; { state.counter = state.counter + value; }, }, actions: { plusOneCounter: ({ commit }) =&gt; { commit(\"SET_COUNTER\", 1); }, },}; 미리 타입을 지정한 인터페이스를 Module 제네릭에 넣어준다. mouduleA의 state 타입을 정의한 moduleAState 인터페이스 index.ts에 정의된 RootState인터페이스 (다른 모듈에 있는 state도 사용하기 위함이다.) vuex에서 import한 모듈 제네릭은 다음과 같다.2) index.ts분리한 module을 병합한다.import { createStore } from \"vuex\";import { moduleA, ModuleAState } from \"../store/modules/moduleA\"import { moduleB, ModuleBState } from \"../store/modules/moduleB\";// 모듈의 state를 공유한다.export interface RootState { ModuleA: ModuleAState; ModuleB: ModuleBState;}// store를 생성한다. export default createStore({ modules: { moduleA, moduleB }}); RootState: 모듈의 type을 공유한다. createStore: 모듈을 묶어서 store를 생성한다.3. 컴포넌트에서의 사용공식문서 / 참고한 블로그1) store 호출composition API에서 store에 접근하기 위해서는 useStore함수를 호출하면 된다.. 이는 vue2에서 this.$store Option API를 사용하여 구성 요소 내에서 검색하는 것과 같다.&lt;script setup lang=\"ts\"&gt; import { useStore } from 'vuex' const store = useStore()&lt;/script&gt;2) state, getters, mutations, actionscomponent에서 store에 저장된 값을 불러들인다. store component에서 사용 state computed(() =&gt; store.state.modules.name) getters computed(() =&gt; store.getters[moudles/name]) mutations store.commit(\"modules/name\") action store.dispatch(\"moudles/name\") &lt;template&gt; &lt;div&gt; &lt;div&gt; data: &lt;/div&gt; &lt;button @click=\"action\"&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt; import { computed } from \"vue\"; import { useStore } from 'vuex'\t // 저장소 const store = useStore() // state: computed const state = computed(()=&gt; store.state.moduleA.counter) // getters: computed const getters = computed(()=&gt; store.getters[\"moduleA/getCounter\"]) // mutations: commit const mutations = () =&gt; store.commit(\"moduleA/SET_COUNTER\") // action: dispatch const action = () =&gt; store.dispatch(\"moduleA/plusOneCounter\") &lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;" }, { "title": "04-TpyeScript-고급-타입", "url": "/posts/ts03/", "categories": "WEB, TypeScript", "tags": "TypeScript", "date": "2022-07-16 00:00:00 +0900", "snippet": "강의링크 / 공식문서섹션6. 고급 타입1) 고급 타입(1) intersection 다른 타입을 결합할 수 있는 타입interface Admin { name: string; privileges: string[];};type Employee = { name: string; startDate: Date;}// 두 타입의 결합된 하나의 타입type ElevatedEmployee = Admin &amp; Employeeconst e1: ElevatedEmployee = { name: \"Coco\", privileges: [\"create-server\"], startDate: new Date()}type Combinnable = string | number;type Numeric = number | boolean;// 타입스크립트는 Universal을 숫자형 타입으로 간주한다. // Combinnable과 Numeric이 겹치는 타입은 숫자형 타입뿐이기 때문이다. type Universal = Combinnable &amp; Numeric(2) index 객체가 지닐 수 있는 속성에 대해 보다 유연한 객체를 생성할 수 있게 해준다.유연성을 제공하여 사용하고자 하는 속성 이름과 필요한 속성의 개수를 미리 알 필요가 없다.예를 들어, 사용자 입력의 유효성을 검사하는 애플리케이션을 작성하는 경우 여러 입력 필드가 필요하며 입력필드가 계속 추가되거나 변경될 수 있다. 이런 경우 어떤 내용을 포함하는 지에 대해 굉장히 유연해야 한다. 이런 경우에 인덱스 타입을 사용할 수 있다.// 대괄호 쌍을 이용하여 인덱스 타입을 정의한다. interface ErrorContainer { // { email: 'Not a valid email', username: 'Must start with a character!' } [prop: string]: string;}const errorBag: ErrorContainer = { email: 'Not a valid email!', username: 'Must start with a capital character!'};위와 같이, 대괄호 쌍을 사용하여 인덱스 타입을 정의하면 후에 해당 인터페이스를 사용할 때 속성과 값이 정의한 타입이기만 하면 된다.(3) 함수 오버로드 동일한 함수에 대해 여러 함수 시그니처를 정의할 수 있는 기능으로, 간단히 말해 다양한 매개변수를 지닌 함수를 호출하는 여러 가지 가능한 방법을 사용하여 함수 내에서 작업을 수행할 수 있게 해준다.function add(a: Combinable, b: Combinable) { if (typeof a === 'string' || typeof b === 'string') { return a.toString() + b.toString(); } return a + b;}const result = add('Max', ' Schwarz');result.split(' '); // 에러 발생 위와 같은 에러가 발생하는 이유는 명확하다. 함수의 반환 값인 result가 string | number와 같은 유니언 타입이기 때문에 string에서 사용할 수 있는 메서드를 사용하면 에러가 발생한다.그래서 이처럼 타입스크립트가 자체적으로 반환 타입을 정확히 추론하지 못하는 경우, 함수 오버로드를 사용한다. 함수에서 지원할 수 있는 다양한 조합에 대해 어떤 것이 반환되는지 명확하게 알 수 있다.// 함수 오버로드: 주요 함수 바로 위에 같은 이릅을 입력한다. function add(a: number, b: number): number;function add(a: string, b: string): string;function add(a: string, b: number): string;function add(a: number, b: string): string;function add(a: Combinable, b: Combinable) { if (typeof a === 'string' || typeof b === 'string') { return a.toString() + b.toString(); } return a + b;}const result = add('Max', ' Schwarz');result.split(' ');타입스크립트는 함수오버로드와 함수 선언을 하나로 병합하여 해당 라인들을 통해 알게된 정보를 결합한다. 즉, 두 문자열을 지닌 add를 호출했지만 타입스크립트는 add를 호출하는 방법이 세 가지 더 있음을 타입스크립트는 알게 된다.(4) 선택적 체이닝 객체 데이터의 중첩된 속성과 객체에 안전하게 접근할 수 있게 한다. (참조하는 값이 없더라도 문제가 발생하지 않도록 함 )예를 들어, 백엔드에서 데이터를 가져오고 데이터 베이스나 객체 내 특정 속성이 정의되어 있는지 확실하지 않은 소스에서 데이터를 가져오는 경우 데이터를 가져오면서 필요한 데이터를 모두 다 가져오지 못할 수 있다. 특히 백엔드와 통신할 때, 규모가 크고 복잡한 애플리케이션에서 이 시점에 일부 데이터가 설정되지 않는 경우가 종종 있다. 이런 상황에서 사용되는 것이 선택적 체이닝이다.const fetchedUserData = { id: 'u1', name: 'Max', // job: { title: 'CEO', description: 'My own company' }};console.log(fetchedUserData.job.title) // 런타임시 에러 발생위와 같이 객체의 일부 속성이 설정되어 있는지 또는 정의되지 않았는지 확실히 알 수 없는 데이터를 가져올 수 없는 경우 당연히 에러가 발생한다.문제는 타입스크립트가 다음과 같은 내용을 확실히 알 수 없다는 것이다. 타입스크립트에서 제어되지 않는 일부 파일에서 가져오는 데이터가 있는지 백엔드에서 가져오는 데이터가 어떻게 반환될지기존 자바스크립트의 선택적 체이닝const fetchedUserData = { id: 'u1', name: 'Max', job: { title: 'CEO', description: 'My own company' }};console.log(fetchedUserData.job &amp;&amp; fetchedUserData.job.title);이는 잠재적인 객체를 자세히 살펴보기에 앞서 객체가 존재하는지 여부를 확인하는 자바스크립트의 방식으로 이 부분이 정의되지 않으면 이 코드는 실행되지 않으므로 런타임 에러를 피할 수 있다. 존재하지 않더라도 적어도 런타임 에러는 발생하지 않지만, 타입스크립트로 더 나은 방법을 사용할 수 있다.타입스크립트의 선택적 체이닝const fetchedUserData = { id: 'u1', name: 'Max', job: { title: 'CEO', description: 'My own company' }};// 정의되어 있는지 여부가 확실치 않은 요소 다음에 물음표를 추가한다.console.log(fetchedUserData?.job?.title);물음표의 역할은 이 부분이 job에 접근하는 경우 해당 부분이 존재하는지를 알려준다. 따라서 물음표를 추가하여 job이 정의되어 있는 경우 title에 접근할 수 있다.사실상 이는 데이터에 접근하기 전에 데이터의 존재 여부를 확인하는 if 문으로 컴파일되어 작동한다.(5) Null 병합 null 데이터 처리에 도움을 준다.만약 해당 값이 null이거나 undefined이면 fallback 값을 저장한다고 하면, 다음과 같이 논리적연산자로 구현할 수 있다.const userInput = undefined;const storeData1= userInput || 'DEFAULT;console.log(storedData);논리적 OR 연산자로 DEFAULT가 저장되도록 구현하여 첫 번째 값이 undefined거나 거짓 같은 값이면 null이면 DEFALUT를 저장한다. 그러나 이 방법의 문제는 이것이 null이나 undefined가 아닌 빈 문자열이더라도 거짓 같은 값으로 처리되어 기본 폴백 값이 적용된된다. 이런 경우 타입스크립트의 ??를 활용하면 해결이 가능하다.const userInput = undefined;const storedData = userInput ?? 'DEFAULT';이는 즉, userInput값이 빈 문자열이나 0이 아닌 null이나 undefined 둘 중 하나라면 폴백을 사용해야 한다는 의미이다. null이나 undefined가 아닌 이상 해당 값을 사용하는 것으로 이중 물음표 연산자를 활용하면 null이나 undefined를 매끄럽게 처리하는 데 도움이 된다.2) 타입가드 타입가드는 특정 속성이나 메소드를 사용하기 전에 그것이 존재하는지 확인하거나 타입을 사용하기 전에 이 타입으로 어떤 작업을 수행할 수 있는지를 확인하는 개념 또는 방식을 나타내는 용어로 런타입 시 특정 타입으로 작업을 수행하기 전에 해당 타입을 검사하는 코드 패턴이다.(1) typeof이는 유니온 타입이 지닌 유연성을 활용할 수 있게 해주며 런타임 시 코드가 정확하게 작동하게 해주며, 객체가 아닌 타입들의 경우 일반적으로 typeof를 사용하여 타입가드를 구현한다.type Combinable = string | number;function add(a: Combinable, b: Combinable) { // typeof를 활용한 타입가드: 맞는 타입인지 확인한다. if (typeof a === 'string' || typeof b === 'string') { return a.toString() + b.toString(); } return a + b;}위의 코드에서 if절이 없다면, 원하는 결과가 나오지 않을 수 있다. if절이 유니온 타입의 세부 분기를 지정해주어 원하는 결과를 도출하도록 만든다.(2) in객체에서 타입가드를 구현하기 위해 사용된다.type Admin = { name: string; privileges: string[];};type Employee = { name: string; startDate: Date;};type UnknownEmployee = Employee | Admin;function printEmployeeInformation(emp: UnknownEmployee) { // in을 활용한 타입가드: 해당 객체안에 privileges 속성이 있는지 확인한다. if ('privileges' in emp) { console.log('Privileges: ' + emp.privileges); }; if ('startDate' in emp) { console.log('Start Date: ' + emp.startDate); };};printEmployeeInformation({ name: 'Manu', startDate: new Date() });in연산자를 활용하여 객체 안에 속성이 있는지 없는지 확인하여 함수의 분기를 나눌 수 있다.(3) instanceof객체의 타입가드를 구현하는 또 다른 방법 중 하나이다.class Car { drive() { console.log('Driving...'); }}class Truck { drive() { console.log('Driving a truck...'); } loadCargo(amount: number) { console.log('Loading cargo ...' + amount); }}type Vehicle = Car | Truck;const v1 = new Car();const v2 = new Truck();function useVehicle(vehicle: Vehicle) { vehicle.drive(); // instanceof를 활용한 타입 가드: Truck 객체를 참조하고 있는지 확인한다. if (vehicle instanceof Truck) { vehicle.loadCargo(1000); }객체의 경우 instanceof나 in을 사용하여 수행할 수 있고 다른 타입들의 경우 typeof를 사용할 수 있다.3) 형 변환 타입스크립트가 직접 감지하지 못하는 특정 타입의 값을 타입스크립트에 알려주는 역할을 한다.예를 들어, dom에 접근하는 경우 타입스크립트는 해당 값에 대한 타입을 감지할 수 없다. 타입스크립느는 HTML파일을 살펴보고 분석하지 못하기 때문에 해당 값이 실제로 존재하는 지 알 수 없기 때문이다. (HTML 코드를 읽을 수 없기 때문에 어떤 HTML 요소라고만 인식을 한다. ) 이를 해결하기 위해 우린 타입을 직접 설정해줄 수 있다.(1) &lt;&gt;를 요소의 앞에 적는다//&lt;타입&gt;을 요소의 앞에 기입하여 타입스크립트에게 해당 요소의 타입을 알려준다. const userInputElement = &lt;HTMLInputElement&gt;document.getElementById('user-input')!;userInputElement.value = 'Hi there!';&lt;HTMLInputElement&gt;를 타입을 설정할 요소 앞에 기입함으로, 해당 요소가 HTML의 Input타입인 것을 알려준다. 요소 뒤에 붙은 !는 해당 값이 NULL이 아니라고 확정하는 것으로 NULL을 반환하지 않을 것을 안다면 이 느낌표를 사용할 수 있다.(2) as를 요소의 뒤에 적는다.// 요소의 뒤에 as 타입을 기입하여 타입스크립트에게 해당 요소의 타입을 알려준다. const userInputElement = document.getElementById('user-input')! as HTMLInputElement;userInputElement.value = 'Hi there!';as HTMLInputElement를 통해 해당 요소의 타입이 HTML의 Input타입인 것을 알려준다.현재 !를 통해 해당 요소가 NULL이 없다는 것을 가정했지만, 만약 null을 반환할 수 있는 경우에는 다음과 같이 코드를 수정해야 한다.// 확신할 수 없기 떄문에 형변환을 하지 못한다. const userInputElement = document.getElementById('user-input');// 만약 null값이 아니면, HTMLInputELement 타입이된다. if (userInputElement) { (userInputElement as HTMLInputElement).value = 'Hi there!';}" }, { "title": "03-TpyeScript-클래스와-인터페이스", "url": "/posts/ts02/", "categories": "WEB, TypeScript", "tags": "TypeScript", "date": "2022-07-16 00:00:00 +0900", "snippet": "강의링크섹션 5-1. 클래스 객체 지향과 클래스 개념은 코드에서 실제 개체 (entity)로 작업한다는 점이 중요하다.객체 지향 방법으로 객체를 구성하면서 로직을 만들면 로직의 일부를 관리하는 객체로 분할 할 수 있다. 객체는 코드로 작업을 수행하면서 사용할 수 있는 구체적인 요소들, 데이터를 저장하고 메소드를 실행하기 위해 메소드를 저장하는 데 사용하는 데이터 구조이다.클래스는 객체의 청사진이다. 클래스를 사용하여 객체의 형태, 포함해야 하는 데이터를 정의할 수 있다. 따라서, 객체는 클래스 내의 인스턴스이다. 이러한 클래스를 기반으로 하면 동일한 구조, 동일한 클래스를 기반으로 하는 동일한 메소드로 여러 객체르 빠르게 복제할 수 있다.이처럼 클래스는 객체의 형태, 포함해야 할 속성와 메소드를 정의하는 데 큰 도움이 되고 클래스를 사용하여 동일한 구조와 메소드를 포함한 여러 객체를 쉽게 만들 수 있다. 단지, 객체에 저장된 정확한 데이터 세부 정보만 다를 뿐이다.1) 클래스 생성(1) 타입스크립트// 클래스를 기반으로 만들 객체를 입력하고 마지막에 키가 갖게 될 값의 타입을 정의한다. class Department { name: string; // 생성자 함수: 예약어로서 이 클래스와 연결된 객체가 생성되는 모든 객체에도 연결이 되는 함수이다. // 이를 활용하여 구축하는 객체에 대한 초기화 작업을 수행할 수 있다. constructor(n: string) { this.name = n; }}// 인스턴스 즉, 객체 만들기const accounting = new Department(\"Accounting\");console.log(accounting)✅ 결과(2) 자바스크립트로의 컴파일es6\"use strict\";class Department { constructor(n) { this.name = n; }}const accounting = new Department(\"Accounting\");console.log(accounting);es5\"use strict\";var Department = /** @class */ (function () { function Department(n) { this.name = n; } return Department;}());var accounting = new Department(\"Accounting\");console.log(accounting);2) 메서드 생성class Department { name: string; // 생성자 메소드는 클래스를 인스턴스화할 때 호출하는 유틸리티 함수일 뿐이다. constructor(n: string) { this.name = n; } // 메서드 // this: 일반적으로 생성된 클래스의 구체적인 인스턴스를 참조한다. describe(this: Department){ console.log(\"Department: \" + this.name); }}const accounting = new Department(\"Accounting\");accounting.describe(); // Department: Accountingconst accountingCopy = {describe: accounting.describe}// 컴파일 오류가 발생하지는 않지만 this가 accountingCopy를 참조하기 때문에 해당 객체는 name속성 값이 없기 때문에 undefined가 나타난다. accountingCopy.describe(); // Department: undefined생성자 메서드는 클래스를 인스턴스화할 때 호출하는 유틸리티 함수일 뿐이다. 그 외에도 클래스의 인스턴스들이 사용할 수 있는 함수를 정의할 수 있다. 이는 메서드라 불린다. 위의 예시에서 describe메서드를 정의한 것을 알 수 있다.accountingCopy에서 Department클래스에서 정의한 메서드를 실행하려고 보니, 우리가 의도한 것처럼 실행되지 않는 것을 알 수 있다. 이는 accountingCopy인스턴스가 name속성 값이 없기 때문에 발생하는 문제이이다. this가 accountingCopy를 참조하는데 해당 객체는 name속성 값이 없기 때문에 this.name이 undefined값을 갖게 되는 것이다.타입스크립트는 메서드를 정의할 때, 매개변수에 타입안정성을 추가하여 위와 같은 상황을 막을 수 있다.class Department { name: string; constructor(n: string) { this.name = n; } // 더미 매개변수를 추가하여 타입 안정성을 추가한다. describe(this: Department){ console.log(\"Department: \" + this.name); }}const accounting = new Department(\"Accounting\");accounting.describe(); // Department: Accountingconst accountingCopy = {describe: accounting.describe}accountingCopy.describe(); // 컴파일 에러 발생const accountingCopy = { name: 'n', describe: accounting.describe}accountingCopy.describe();위와 같이 수정해주면 더 이상 컴파일 에러가 발생하지 않는다.2) 제어자(1) 접근 제어자 (private와 public)클래스를 통해 생성한 인스턴스의 속성에 접근하는 방법은 크게 두 가지이다. 클래스에서 생성한 메서드를 통해 접근하는 방법 직접 속성에 접근하는 방법이다.기본적으로는 위의 두 가지 방식으로 모두 접근할 수 있지만, private키워드를 사용할 경우 전자의 방법으로만 속성에 접근할 수 있다.class Department { // public은 defult이기 때문에 굳이 기입할 필요는 없다. public name: string; // private의 의미는 employees가 이제 클래스 즉, 생성된 객체 내부에서만 접근할 수 있는 속성이 되었다는 의미이다. private employees: string[] = []; constructor(n: string) { this.name = n; } describe(this: Department) { console.log(\"Department: \" + this.name); } addEmployee(employee: string) { this.employees.push(employee); } printEmployeeInformation() { console.log(this.employees.length); console.log(this.employees); }}const accounting = new Department(\"Accounting\");accounting.name = \"Marketing\";accounting.addEmployee(\"Coco\");accounting.addEmployee(\"Deer\");// 컴파일 에러가 발생한다. public이여야 아래와 같이 코드를 기입할 수 있다. accounting.employees[2] = \"Emong\";✅ 약식 초기화앞서, 클래스를 정의할 때 1. 속성 정의 2. 생성자 함수를 통한 속성의 default값 설정 과 같은 두 단계에 걸쳐 진행했다. 하지만, 이는 속성이 늘어날 수록 번거로워지기 때문에 하나의 단계로 축약하여 속성을 정의하고 기본 값을 설정할 수 있다.class Department { private employees: string[] = []; // 이는 필드를 찾은 다음 값을 저장해야 하는 이중 초기화 코드를 한 번에 처리하도록 축약한 것이다. constructor(private id: string, public name: string) { } describe(this: Department) { console.log(`Department (${this.id}): ${this.name}`); } addEmployee(employee: string) { this.employees.push(employee); }}const accounting = new Department(\"d1\", \"Accounting\");accounting.name = \"Marketing\";accounting.describe(); // Department (d1): Marketing기존에 constructor함수를 통해 기본 값을 설정할 때는, 단순히 타입만 설정하면 되었다. 하지만 이것은 단순히 생성자에서 인수들을 가져올 뿐만 아니라 이 클래스에 대해 정확히 동일한 이름의 속성을 만들고 싶다는 것을 타입스크립트에게 알려야 하기 때문에 해당 속성이 public인지 private인지 명시해야 한다.(2) readonly 제어자private이나 public이어서도 안 되고 초기화 후에 변경되어서도 안 되는 특정 필드가 있는 경우 readonly제어자를 사용할 수 있다.class Department { private employees: string[] = []; constructor(private readonly id: string, public name: string) { } addEmployee(employee: string) { this.id =\"d2\" // 컴파일 에러 발생 this.employees.push(employee); }}이처럼 readonly는 특정 속성이 초기화되고나면 이후에는 변경되어서는 안 된다는 점을 명확히 하기 위해 사용된다. 이는 객체의 특정 속성에 대해 대체로 필수적으로 적용된다.3) 클래스 상속 클래스는 생성 시, extends 키워드를 사용하면 다른 클래스의 속성 및 메서드를 상속받을 수 있다.(1) super 키워드extends키워드를 사용하여 클래스의 속성, 생성자 함수, 메서드 등을 상속할 수 있다.class Department { // 이는 필드를 찾은 다음 값을 저장해야 하는 이중 초기화 코드를 한 번에 처리하도록 축약한 것이다. constructor(private id: string, public name: string) { } describe() { console.log(`Department (${this.id}): ${this.name}`); } addEmployee(employee) { this.employees.push(employee); } printEmployeeInformation() { console.log(this.employees.length); console.log(this.employees); }}// Department를 상속받은 클래스: Department클래스가 가진 모든것을 자동으로 가져온다. class ItDepartment extends Department { admins: string[] = []; constructor(id: string, admins: string) { super(id, \"IT\"); this.admins = admins; }}const it = new ItDepartment(\"d1\", [\"coco\"]);it.addEmployee(\"deer\");it.describe(); it.printEmployeeInformation();console.log(it)ItDepartment클래스의 경우 Department클래스로부터 상속을 받아 Department에서 정의한 속성과 메서드를 사용할 수 있다. 물론 본인이 원하는 속성과 메서드를 추가할 수도 있다. 그런데, 생성자 함수의 경우 재정의하기 위해서는 super키워드를 사용해야 한다.여기서 super는 기본 클래스의 생성자를 호출하게 된다. 우선 부모 생성자의 경우 매개변수로 id와 name을 취하므로 super의 매개변수에 해당 요소들을 전달함으로서 기본 속성 값을 설정할 수 있다. 그 후, ItDepartment에서 추가할 속성을 할당하여 생성자 함수를 오버라이딩한다.즉, 생성자함수를 오버라이딩하는 경우 super를 먼저 호출하고 this 키워드를 사용하여 작업을 수행해야 한다.✅ 결과(2) protectedprotected는 앞서 배운 private와 비슷한 개념의 접근 제어자이다. 공통점 외부에서 접근할 수 없다. 차이점 **기본 클래스를 확장하는 클래스 내에서는 접근할 수 있는 지의 유무 **protected: 접근할 수 있다. private: 접근할 수 없다. class Department { // 만약 접근할 수 있으면서도 외부에서는 접근못하게 하려면 protected로 변경하면 된다. // private과 다른 점은 이 클래스에서뿐 아니라 이 클래스를 확장하는 모든 클래스에서도 사용 가능하다는 것이다. protected employees: string[] = []; constructor(private readonly id: string, public name: string) { }};class AccountingDepartment extends Department { constructor(id: string, private reports: string[]) { super(id, 'Accounting'); } addEmployee(name: string) { if (name === 'Max') { return; } // employees가 private속성이면 컴파일 에러가 발생한다. this.employees.push(name); }}const accounting = new AccountingDepartment('d2', []);accounting.addEmployee('Max');// protected인 속성은 외부에서 접근할 수 없기 때문에 컴파일 에러가 발생한다. accounting.Employee[0] = 'Manu';만약 Department클래스의 employees 속성이 private였다면 이는 정의된 클래스 내에서만 접근이가능하며 해당 클래스로부터 상속받는 클래스에서는 접근이 불가능 하기 때문에 AccountingDepartment은 접근할 수 없다.그러나 현재 protected속성을 사용하고 있기 때문에 외부에서 접근할 수 없게 하는 동시에 기본 클래스를 확장하는 클래스 내에서는 접근할 수 있게 한다.(3) 추상 클래스 추상 클래스는 공통적인 동작을 정의하기 위해 사용되는 기술로 추상 클래스는 인스턴스를 생성할 수 없다.추상 클래스는 일부 상위 클래스를 기반으로 하는 모든 클래스가 일부 공통 메소드 또는 속성을 공유하도록 하려는 경우 아주 유용하다. 추상 속성을 사용할 수도 있지만 동시에 구체적인 값, 구체적인 구현, 기본 클래스를 제공하지 않고자 한다면 상속하는 클래스가 이를 구체화 해야 한다. 일반 클래스의 규격을 지정하는 추상적인 클래스이다. 일부 메소드가 구현되지 않고, 선언만 되어있는 클래스로 자식 클래스에서 반드시 해당 메서드를 재정의 해야 한다. 즉, 메서드를 구체적으로 정의하지는 않고 메소드가 존재하도록 한다. 추상클래스는 추상적이기 때문에 인스턴스(객체)를 생성할 수 없다. 이는 상속되어야할 클래스이다. // 추상 클래스abstract class Department { protected employees: string[] = []; constructor(protected readonly id: string, public name: string) { } // 추상 함수 abstract describe(this: Department): void; addEmployee(employee: string) { this.employees.push(employee); } printEmployeeInformation() { console.log(this.employees.length); console.log(this.employees); }};// 추상 클래스로부터 상속을 받는 클래스class ITDepartment extends Department { admins: string[]; constructor(id: string, admins: string[]) { super(id, 'IT'); this.admins = admins; } // 추상 함수를 구체적으로 정의해야 한다. describe() { console.log('IT Department - ID: ' + this.id); }};4) 게터와 세터 이들은 로직을 캡슐화하고 속성을 읽거나 설정하려 할 때, 실행되어야 하는 추가적인 로직을 추가하는 데 유용하다.(1) Getter Getter는 값을 가지고 올 때, 함수나 메서드를 실행하는 속성이다.class AccountingDepartment extends Department { private lastReport: string; // getter get mostRecentReport(){ if (this.lastReport){ return this.lastReport; } throw new Error(\"No report found.\") } constructor(id: string, private reports: string[]) { super(id, 'Accounting'); this.lastReport = reports[0]; } addReport(text: string) { this.reports.push(text); this.lastReport = text; }}const accounting = new AccountingDepartment('d2', []);accounting.addReport('Something went wrong...');// 속성처럼 접근한다. accounting.mostRecentReport()처럼 메서드같이 사용하면 안된다. console.log(accounting.mostRecentReport); //Something went wrong...lastReport는 private로 지정되어 있어서 이 클래스내에서는 접근이 가능하지만, 외부에서 점을 표기하여 접근하는 것은 불가능 하다. 그러나 게터를 추가하여 접근이 가능하게 할 수 있다. 중요한 건 이는 메소드와 같아서 괄호 쌍과 중괄호 쌍을 입력해야 한다. 또한 코드 블록 내에 return을 입력해야 한다. 또한, 게터 메소드는 꼭 무언가를 반환하도록 작성해야 합니다.getter속성을 정의하면 외부에서 점을 표기하여 값을 가져올 수는 없지만 이를 속성처럼 사용하여 속성에 접근하는 로직을 실행할 수 있다.(2) Setter Setter은 값을 설정할 때 , 함수나 메서드를 실행하는 속성이다.class AccountingDepartment extends Department { private lastReport: string; // getter get mostRecentReport(){ if (this.lastReport){ return this.lastReport; } throw new Error(\"No report found.\") }\t // setter set mostRecentReport(value: string){ if (!value){ throw new Error(\"Please pass in a valid value!\") } this.addReport(value); } constructor(id: string, private reports: string[]) { super(id, 'Accounting'); this.lastReport = reports[0]; } addReport(text: string) { this.reports.push(text); this.lastReport = text; }}const accounting = new AccountingDepartment('d2', []);// 속성처럼 접근한다.accounting.mostRecentReport = \"Year End Report\";accounting.addReport('Something went wrong...');console.log(accounting.mostRecentReport); 5) 정적 속성과 메서드 정적 속성과 메서드를 사용하여 클래스의 인스턴스에서 접근할 수 없는 속성과 메서드를 클래스에 추가할 수 있다. 따라서 새 클래스 이름을 먼저 호출하지 않고 클래스에 직접 접근한다.정적 속성과 메서드는 클래스를 기반으로 생성된 객체에서 파생된 것이 아니라 틀래스에서 직접 호출하는 메서드이다. 정적 속성과 메서드는 주로 논리적으로 그룹화하거나 클래스에 매핑하려는 유틸리티 함수나 클래스에 저장하고자 하는 전역 상수에 사용된다. 자바스크립트에 내장된 예를 살펴보면 우리가 정의하지 않더라도 원하면 브라우저의 자바스크립트 중 일부는 Math 생성자 함수나 클래스를 사용할 수 있다. 이러한 정적 속성과 메서드는 우리만의 클래스에도 추가할 수 있다.class Department {// 인스턴스화하지 않고 사용할 수 있도록 이 속성 앞이나 필드 앞에 static을 추가하여 접근할 수 있습니다. static fiscalYear = 2020; protected employees: string[] = []; constructor(private readonly id: string, public name: string) { } // 이 클래스를 인스턴스화 하지 않고 접근할 수 있는 정적 메서드로 만드려면 이 메서드 앞에 정적 키워드를 추가한 다음 객체를 반환해야 한다. static createEmployee(name: string){ return {name: name}; }};// new 키워드 없이 직접 클래스에서 호출하여 사용할 수 있다. const employee1 = Department.createEmployee(\"Max\");console.log(employee1); // {name: Max}console.log(Department.fiscalYear); // 2020 이렇게 static키워드를 활용하면, 인스턴스를 생성하지 않고도 해당 속성의 속성과 메서드에 접근할 수 있다. 이는 클래스 내부에서도 마찬가지이다. constructor(private readonly id: string, public name: string) { // console.log(this.fiscalYear) =&gt; 에러 발생 console.log(Department.fiscalYear); }클래스 내부에서 this키워드를 사용해서 정적 속성이나 메서드에 접근할 수 없다. 정적 속성은 인스턴스에서 유효하지 않다. 즉, 정적 속성과 정적 메소드의 전체적인 개념은 인스턴스와 분리되어 있기 때문에 this 키워드를 사용하여 접근하는 건 불가능하다. 만약, 클래스 내에서 정적 속성이나 메소드를 사용하고자 한다면 여기에 접근하기 위해 여기서 클래스 이름을 사용해야 한다. 이렇게 하면 클래스 내부에서도 정적 속성과 메소드에 접근할 수 있다.6) 싱글톤과 private생성자(1) 싱글톤 패턴 디자인 패턴 중 하나로, 클래스는 인스턴스를 정확히 하나만 갖도록 한다. 정적 메소드나 속성을 사용할 수 없다. 클래스를 기반으로 여러 객체를 만들 수는 없다. 항상 클래스를 기반으로 정확히 하나의 객체만 가질 수 있다.(2) private 생성자예를 들어, 회사 전체에 회계 부서는 하나만 있기 때문에 AccountingDepartment의 클래스가 하나의 인스턴스만 가지도록 한다면 new AccountingDepartment를 여러 번 수동으로 호출하지 않도록 하기 위해 생성자의 앞에 private 키워드를 붙여 private 생성자로 바꿀 수 있다.class AccountingDepartment extends Department { private lastReport: string; private constructor(id: string, private reports: string[]) { super(id, 'Accounting'); this.lastReport = reports[0]; } describe() { console.log('Accounting Department - ID: ' + this.id); }}// 에러 발생const accounting = new AccountingDepartment('d2', []); 그러나 private키워드를 사용하여 외부에서 new키워드를 활용해 인스턴스를 생성할 수 없다.class AccountingDepartment extends Department { private lastReport: string; private static instance: AccountingDepartment private constructor(id: string, private reports: string[]) { super(id, 'Accounting'); this.lastReport = reports[0]; }; // 정적 메서드의 this는 클래스 자체를 의미하기 때문에 this와 AccountingDpartment는 같다. // 그래서 AccountingDepartment.instace와 this.instance는 같다. static getInstance(){ if (AccountingDepartment.instance) { return this.instance; } this.instance = new AccountingDepartment(\"d2\", []); return this.instance; }; describe() { console.log('Accounting Department - ID: ' + this.id); };};const accounting = AccountingDepartment.getInstance();const accounting2 = AccountingDepartment.getInstance();console.log(accounting, accounting2)이를 해결할 정답은 정적 메서드이다. 클래스 자체에서 정적 메소드를 호출하여 인스턴스화할 필요가 없도록 하면 된다.✅ 결과섹션 5-2. 인터페이스 인터페이스는 일반적으로 객체의 구조를 설명할 때 사용된다.클래스와 달리 청사진으로 사용하는 것이 아니라 사용자 정의 타입으로 사용된다. 즉, 구체적인 값이 아닌 구조만 있다.interface Person { name: string; age: number; // 실제 메서드를 추가하는 것이 아니라 구조와 어떤 형태인지 설명을 추가한다. // 예시에는 phrase를 매개변수로 받고 아무것도 반환하지 않는 함수이다. greet(phrase:string): void;}// 객체의 타입을 확인하는 데 사용한다.let user1: Person;// 인터페이스의 정의를 충족했기에 유효한 객체이다. user1 = { name: \"Coco\", age: 20, greet(phrase: string){ console.log(phrase + '' + this.name); }}user1.greet(\"Hi there - I am \") // Hi there - I am Coco1) 클래스와 인터페이스(1) 클래스 인터페이스는 클래스나 객체가 특정 구조를 갖추도록 하고 객체의 형태에 대한 개념을 명확하게 설명하는 강력한 기능이다.인터페이스는 주로 implements키워드를 활용하여 클래스의 구조를 설명하는 데 사용된다. 클래스의 상속에 비해 인터페이스는 여러 개의 인터페이스를 연결할 수 있기 때문에 더 활용도가 높다. 상속은 한 클래스로부터만 상속할 수 있지만 인터페이스는 쉼표로 구분하여 여러 개를 구현할 수 있으므로 하나가 있더라도 또 다른 인터페이스를 만들 수 있다.또한, 인터페이스는 주로 구체적인 구현이 아닌 서로 다른 클래스 간의 기능을 공유하기 위해 사용된다. 즉, 클래스의 구조와 가져야할 기능을 인터페이스로 모듈화 한다. 이는 추상 클래스로 작업하는 것과 다소 비슷하지만, 인터페이스는 구현 세부사항이 전혀 없는 반면, 추상 클래스는 구체화 해야 하는 부분과 구현 세부사항이 혼재되어있다는 차이점이 있다.interface Greetable { name: string; greet(phrase:string): void;}// implements: 인터페이스와 클래스를 연결한다. class Person implements Greetable { name: string; constructor(n: string){ this.name = n; } greet(phrase: string){ console.log(phrase + '' + this.name); }}// user1에 저장한 Person 객체는 결국 Greetable인터페이스에 기반한 것이기 때문에 이렇게 작성해도 된다. let user1: Greetable;user1 = new Person(\"Coco\")user1.greet(\"Hi there - I am \") // Hi there - I am Coco(2) readonly 제어자 인터페이스 내에 readonly 제어자도 추가할 수 있습니다. 다만 public, private 등은 지정할 수 없다.인터페이스에서 사용할 수 없지만 readonly를 추가하여 읽기 전용으로 설정하여 객체가 초기화되면 변경할 수 없도록 할 수 있다.interface Greetable { readonly name: string; greet(phrase:string): void;}class Person implements Greetable { name: string; constructor(n: string){ this.name = n; } greet(phrase: string){ console.log(phrase + '' + this.name); }}let user1: Greetable;user1 = new Person(\"Coco\")// 에러 발생 user1.name = \"deer\" user1.greet(\"Hi there - I am \") // Hi there - I am Coco인터페이스를 클래스에 구현하고 나면 인터페이스가 영향을 갖게 된다. 클래스에서 readonly를 추가하지 않았음에도 클래스는 Greetable을 구현한다는 것을 인지하고 인터페이스 때문에 입력해야 하는 name 속성이 읽기 전용임을 자동으로 추론하기 때문이다.(3) 상속interface Named { readonly name: string;}// 인터페이스 상속도 가능하다. (클래스와 달리 둘 이상을 확장하는 것이 가능하다.)// 여러 인터페이스로부터 상속을 받을 수 있다. interface Greetable extends Named { greet(phrase:string): void;}class Person implements Greetable { name: string; constructor(n: string){ this.name = n; } greet(phrase: string){ console.log(phrase + '' + this.name); }}let user1: Greetable;user1 = new Person(\"Coco\")// user1.name = \"deer\"user1.greet(\"Hi there - I am \") // Hi there - I am Coco(4) 옵션 속성 인터페이스, 클래스, 생성자 함수의 매개변수에 필요에 따라 선택적으로 적용되는 선택적 속성을 사용할 수 있다.클래스는 설정된 인터페이스에 정의된 속성 또는 메서드를 반드시 사용하지 않고, 필요에 따라 선택적으로 사용하고 싶을 수도 있다. 이 경우 옵션(Optional) 속성 설정을 통해 사용자가 선택적으로 사용하게 설정하면 된다.interface Named { readonly name?: string; /* 그런데 name 기반의 모든 클래스가 문자열이어야 한다고 설정하지 않고 문자열이어야 하는지의 여부는 선택적으로 하고자 한다면, 속성 이름 다음에 물음표를 추가하여 선택적 속성을 지정할 수 있다. 그러면 타입스크립트는 이 속성이 이 인터페이스를 구현하는 클래스 내에 있을 수 있지만 반드시 그렇지는 않다고 인식하게 된다. */ outPutName?: string;}interface Greetable extends Named { greet(phrase: string): void;}class Person implements Greetable { name?: string; age = 20; constructor(n?: string) { if (n) { this.name = n; } } greet(phrase: string) { if (this.name) { console.log(phrase + \"\" + this.name); } else { console.log(\"Hi\"); } }}let user1: Greetable;// 선택적 속성 덕분에 이제 값이 없어도 인스턴스를 생성할 수 있다.user1 = new Person();user1.greet(\"Hi there - I am \"); // Hi!2) 함수와 인터페이스(1) 함수사용자 정의 타입type AddFn = (a: number, b: number) =&gt; number;let add: AddFn;add = (m1: number, n2: number ) =&gt; { return n1 + n2;};인터페이스interface AddFn { // 화살표가 아닌 반환타입을 쌍점으로 표시 (a: number, b: number): number;}let add: AddFn;add = (m1: number, n2: number ) =&gt; { return n1 + n2;};" }, { "title": "컴퓨터구조-기존-컴퓨터의-구조와-설계-part2", "url": "/posts/computerstructure06/", "categories": "CS, 컴퓨터-구조", "tags": "cs, 컴퓨터-구조", "date": "2022-07-13 00:00:00 +0900", "snippet": "기본 컴퓨터의 구조와 설계 part2강의 링크1) 입출력과 인터럽트 (Input-Output and Interrupt)입출력장치들과 CPU가 서로 통신을 하면서 데이터를 주고 받으며 데이터를 입력하거나 출력합니다.입출력장치들은 CPU보다 굉장히 느리다. 그래서 CPU는 현재 입출력 장치들이 사용이 가능한지 체크해야한다.(1) 입출력 구성 키보트에서 g를 클릭 FGI가 1로 세팅이 된다. (받을 데이터가 있다.) CPU는 Input Register(INPR)를 통해 데이터를 인터페이스에서 받게된다. 그 값을 AC로 전송하게 된다. CPU와 IO 장치의 속도 차이 제어를 위하여 Flag 사용 현재 입출력 장치가 사용이 가능한지 확인한다. Buffer overrun 상태 BUffer underrun 상태 종류 FGI 1: 입력 가능한 상태 0: 입력 블럭킹 FGO 1: 출력 가능한 상태 0: 출력장치 사용 중 인터럽트 (Interrupt) IEN flag에 의하여 제어된다. IEN이 1이면 지금 입출력을 할 수 있는 상태이다. 입출력 장치에 의해 발생하며 입출력 전체를 제어한다. (2) 인터럽트 사이클 프로그램 인터럽트 장치가 중비되었을 때 CPU에게 알린다. 인터럽트 발생시 BSA 명령어처럼 동작한다. FGI, FGO 플로그를 사용한다. 플래그가 set되면 R &lt;- 1 R = 1이면 다음 명령어 사이클에 인터럽트 사이클이 실행된다. IEN 인터럽트 enable/ disable 제어한다. I/O Program BIOS 입출력 인터럽트 처리 루틴의 집합이다. IVT (Interrupt Vector Table) 각 인터럽트에 벡터 번호를 부여한다. 벡터 번호와 인터럽트 처리 루틴 시작번지를 Table로 유지한다. 시스템 부팅시, IVT는 0번 segment에 load 현대의 대부분의 CPU가 IVT를 사용한다. (3) 인터럽트 flow 기본 컴퓨터: 한개의 하나의 인터럽트만 받는다. 동시에 여러개의 인터럽트를 안받는다. 그러나 현대의 cpu들은 인터럽트가 수행되는 도중에도 인터럽트를 받을 수 있다. (queue) AR &lt;- 0, TR &lt;- TC M[AR] &lt;- TR, PC &lt;- 0 PC &lt;- PC + 1, IEN &lt;- 0, R&lt;-0, SC&lt;-0기본 컴퓨터의 구조와 설계 part2-2강의 링크1) 컴퓨터에 대한 완전한 기술 (Complete Computer Description)2) 기본 컴퓨터의 설계 (Design of Basic Computer)(1) 하드웨어 구성요소 16bit 4096워드 메모리 9개의 레지스터 AR, PC, DR, AC, IR, TR, OUTR, INPR, SC 7개의 플립플롭 I, S, E, R, IEN, FGI, FGO 2개의 디코더 3x8(Opcode), 4x16(타이밍) 16bit 공통버스 제어 논리 게이트 AC 입력 연결 논리회로 (ALU)(2) 컴퓨터 동작 흐름 MRI, RRI, IO 명령 사이클 구현 인터럽트 사이클 구현(3) 레지스터와 메모리에 대한 제어 설계 순서 AR에 대한 LD, CLR, INC 동작의 경우 수집 각 동작들을 OR로 연결한다. 3) 누산기 논리의 설계 (Design of Accumulator Logic)(1) AC 레지스터관련 회로 AC를 변경하는 경우 수집한다. LD, CLR, INC(2) 레지스터에 대한 제어 LD 신호 제어 MRI 명령: AND, ADD, LDA RRI 명령: COM, SHR, SHL IO 명령: INPR INR 신호 제어 MRI 명령: none RRI 명령: INC IO 명령: none CLR 신호 제어 MRI 명령: none RRI 명령: CLR IO 명령: none (3) 가산 논리 회로 회로 요소 AND gate FUll Adder Inverter Shifter INPR/OUTR " }, { "title": "컴퓨터구조-기본-컴퓨터의-구조와-설계-part1", "url": "/posts/computerstructure05/", "categories": "CS, 컴퓨터-구조", "tags": "cs, 컴퓨터-구조", "date": "2022-07-13 00:00:00 +0900", "snippet": "기본컴퓨터의 구조와 설계 part1-1강의 링크1) 기본 컴퓨터 (Basic Computer) DEC. Corp 사의 중형 컴퓨터 PDP-11을 지칭한다. 이후 VAX-11 등의 주요 minicomputer의 기본이다. (1970 ~ 1980년대) 컴퓨터 구조 설계의 가장 기본적인 부분이다. 현대의 CPU들에도 동일하게 적용되는 설계 구조이다. 튜링머신: 프로그램을 기억장치에 저장하고 프로그램을 명령에따라 하나씩 꺼내와서 실행시킨다.2) 명령어 코드 (Instruction Codes)(1) 컴퓨터의 동작 레지스터 내에 저장된 데이터에 대한 마이크로 연산의 시퀀스에 의하여 정의된다. 범용 컴퓨터 시스템에서는 다양한 마이크로 연산 시퀀스를 정의한다.(2) 명령어 코드 컴퓨터에게 어떤 특별한 동작을 수행할 것을 알리는 비트들의 집합이다. 연산 코드들로 구성되어 있다.저장(내장) 프로그램 구조 명령어의 집합으로 구성된다. 각 명령어는 명령어 포맷(컴퓨터를 설계할 때 , 미리 정해진)에 따라서 정의된다. I: Address가 직접 주소, 간접 주소인지 구별한다. Opcode: 기계 명령 Adress: 명령어가 사용하는 데이터(Operands)의 주소 값을 저장 프로그램 실행부분에 따라서 메모리의 다른 부분에 저장된다. 명령어 실행 결과는 AC에 저장된다.💬간접 주소와 직접 주소 I비트가 0일 경우 직접 주소, 해당 주소에 데이터가 존재한다. I비트가 1일 경우 간접 주소, 해당 주소에 데이터가 위치하는 주소가 존재한다. (3) 컴퓨터 명령어 컴퓨터에 대한 일련의 마이크로 연산을 기술한다. (기계어 프로그램) 이진 코드로 구성된다. 처리할 데이터와 함께 메모리(메인 메모리)에 저장된다.(4) 프로그램 사용자가 원하는 연산과 피연산자가 처리되는 순서를 기술한 컴퓨터 명령어의 집합이다. 명령어 처리 과정을 제어한다.(5) 내장 프로그램 제어 신호에 의하여 명령어의 이진 코드를 해석하여 실행한다. 명령어를 저장하여 실행하는 컴퓨터 구동방식2) 컴퓨터 레지스터 (Computer Registers)(1) 기본 컴퓨터의 레지스터(2) 버스 시스템의 종류 내부 버스 CPU(컴퓨터) 내부 레지스터간 연결한다. 공통 버스 시스템 외부버스 CPU 내부 레지스터와 메모리간 연결한다. 입출력 버스 CPU와 주변장치(I/O)를 연결한다. (3) 공통 버스 시스템 내부 버스를 통칭한다. 내부 버스의 크기(width)로 CPU 워드 크기를 결정한다. 16 bit 컴퓨터 : 내부 버스 / 레지스터 크기가 16 bit 32 bit 컴퓨터: 내부 버스 / 레지스터 크기가 32bit 전송 연결 통로 레지스터- 레지스터 데이터 전송을 연결하는 통로이다. 레지스터 - 메모리 데이터 전송을 연결하는 통로이다. (예외적 표현) 한 순간에는 하나의 전송 신호만이 버스에 존재가 가능하다. 2개 이상의 신호 발생 시에는 버스 충돌이 발생한다. 버스 제어기(정확한 타이밍과 MUX 제어 수행) 버스의 동작 레지스터 출력은 버스의 MUX 입력에 연결되어있다. 각 레지스터에 MUX 입력 번호가 설정된다. 레지스터 입력은 버스에 직접 연결한다. (LD로 제어) 병렬로드가 가능한 양방향 시프트 레지스터이기 때문에 가능하다. 레지스터의 LD가 1이면 데이터를 받는다. 메인 메모리의 경우 write면 데이터를 받는다. 기본컴퓨터의 구조와 설계 part1-2강의 링크1) 컴퓨터 명령어 (Computer Instructions)(1) 종류 MRI 명령어(Memory-reference instruction) : 7가지 메모리를 참조하는 명령어 주소비트를 가지고 메인메모리에 접근하는 명령어를 의미한다. RRI 명령어(Register -reference instruction): 12가지 레지스터를 참조하는 명령어 레지스터 사이의 혹은 레지스터를 다루는 명령으로 구성되어있다. IO 명령어(Input-output instruction):6가지 Io 장치 명령어 입력과 출력과 관련된 명령어 (2) 명령어 형식Opcode에 따라 명령어 종류를 구분할 수 있다.2) 타이밍과 제어 (Timing and Control)기본 컴퓨터의 모든 플립플롭과 레지스터는 주 클럭 발생기에 의하여 제어된다. 메모리에서 읽어온 명령어는 공통 버스 시스템에 있는 명령어 레지스터 (IR)에 놓이게 된다. 이 중에서 연산 코드 부분이 3X8 디코더에 의해 D0에서 D7까지 디코딩된다. 명령어 레지스터의 15번째 비트는 I로 표시되는 플립플롭에 전송되며, 나머지 0에서 11번째 비트들은 제어 논리 게이트로 연결된다.4비트 순차 카운터(SC)의 출력은 디코더에 의해 T0에서 T15까지 16개의 타이밍 신호를 생성한다.3) 명령어 사이클 (Instruction Cycle)(1) 명령어 사이클 단계 메모리에서 명령어 가져오기 (Fetch) 명령어 디코딩 유효주소 (Effective Address) 계산 명령어 실행(2) Fetch메모리의 CodeSegment에 있는 기계어 코드 명령어를 IR(명령어 레지스터)로 가져온다. CodeSegment 몇 번지에 있는 명령어를 가져올지 파악한다. AR &lt;- PC 명령어 번지는 PC(Program Counter: 지금 가져와야할 명령어의 주소를 기억하는 레지스터)에 저장되어 있다. 버스를 통해 PC에 있는 주소를 AR레지스터로 가져온다. AR레지스터에 있는 값이 들어오면 그 순간에 메모리의 해당 번지의 값이 자동으로 읽히게 된다. 메모리로부터 IR레지스터로 버스를 통해 이동한다. IR &lt;- M[AR] IR 레지스터의 LD입력을 1로 하여 버스의 신호를 IR 레지스터로 이동시킨다. 명령어가 IR로 들어왔기 때문에 그다음에 가져와야할 명령어를 다시 가르킨다. (일반적으도 다음번지인다.) PC &lt;- PC+1 (3) 명령어 디코딩 IR에 들어간 명령어를 디코딩한다. 3bit Opcode가 무엇인지 판단한다. 그 결과, 디코더의 어느 출력을 1로할 것 인지 결정한다. 그리고 IR에 있는 다른 주소비트들을 다시 AR로 보낸다. (데이터를 가져오기 위해서) AR &lt;- IR(0-11) (4) 유효주소 계산 3bit Opcode를 통해 어떤 명령어 인지 파악한 후, 명령어를 실행준비한다. MRI 명령어 여부 (D7이 0이다) RRI 명령어 여부 (D7이 1이다) IO 명령 결정 (D7이 1이다) MRI일 경우, 직접 주소인지 간접주소인지 파악하여 실제 명령어의 주소를 가져온다. Operand가 있는 주소를 알아내는 것이다. (5) 명령어 실행 명령어를 실행한다. 명령어 실행이 끝나면, 다음 명령어를 다시 Fetch한다.4) 메모리 참조 명령어 (Memory-Reference Instuctions)" }, { "title": "02-TpyeScript-컴파일러", "url": "/posts/ts01/", "categories": "WEB, TypeScript", "tags": "TypeScript", "date": "2022-07-10 00:00:00 +0900", "snippet": "강의링크섹션3. TypeScript 컴파일러tsc 파일이름으로 매번 컴파일하는 것은 매우 불편한 일이다. 컴파일 과정에 관련하여 구성할 수 있는 몇가지 기능이 있다. 무엇을 어떻게 컴파일 할지 구성할 수 있다. 이에 대해 알아보자.1) 자동으로 컴파일 하기(1) watch모드변경할 때마다 변경 사항을 웹페이지에서 출력으로 반영하고 싶다면, 파일을 저장하고 다시 컴파일을 수행해야 한다. 이런 번거로운 경우에는 watch 모드를 사용하면 된다. watch모드를 사용하면 타입스크립트가 파일을 파악하고 변경 사항이 있으면 자동으로 컴파일 해주어 편리하게 타입스크립트 코드를 작성할 수 있다.# watch 모드로 전환한다. $ tsc app.ts --watch app.ts파일은 watch 모드로 전환되어 변경사항이 생길때마다 디스크에 잇는 파일이 저장되고 자동으로 다시 컴파일 된다. 단점: 이 파일을 구체적으로 지정해야 한다는 것이다. 지금은 파일 하나로 작업하고 있지만 규모가 커서 파일이 많은 경우 사용하기 어렵다. (2) 프로젝트 컴파일파일을 지정하지 않아도 watch모드로 전체 프로젝트 폴더를 확인하고 변경 사항이 적용될 수 있는 모든 타입스크립트 파일을 다시 컴파일 할 수 있다.# 프로젝트화: 이제 해당 폴더에 있는 ts파일을 관리한다. $ tsc --init tsconfing.json파일이 생성된다. 이 파일은 타입스크립트가 관리해야 하는 이 파일이 포함된 프로젝트와 이 폴더의 모든 하위 폴더를 참고하기 위한 파일이다.# 모든 ts파일을 컴파일 한다.$ tsc# 관찰모드와 결합한다.$ tsc --watch 특정파일을 지정하지 않더라도 tsc를 입력하여 실행할 수 있다. 실행하면 타입스크립트는 모든 타일스크립트 파일 즉 이 프로젝트의 모든 ts파일을 컴파일한다.2) tsconfig.json공식문서컴파일러의 동작 방식을 구성하고 컴파일과 관련된 몇가지 옵션을 추가할 수 있다.(1) 추가 옵션exclude: 해당 파일을 제외하고 컴파일한다. 즉, 컴파일 해서는 안되는 파일이 있다면 이와 같이 제외시키면된다.{ \"compilerOptions\": {\t//...생략 }, \"exclude\": [ \"**/*.dev.ts\", /* 모든 폴더에서 dev.ts가 포함된 파일을 무시한다. */ \"node_modules\" ],} **/*.dev.ts와 같이 와일드 카드를 사용하여 구현할 수 있다. node_modules는 package.json에 설치한 모든 종속성과 모든 종석성들의 파일들이 포함되어있다. 즉, 변경하지 않아야할 타사 라이브러리를 가져오는 위치 이기때문에 당연히 컴파일 해서는 안된다. exclude 옵션을 아예 지정하지 않으면 node_modules는 기본 설정상 자동으로 제외된다. 그러나, exclude 옵션을 사용할 경우 node_modules를 추가 해야 한다. include: exclude와 반대 개념으로 컴파일 과정에 포함시킬 파일을 타입스크립트에 알려 여기에 포함되지 않은 어떤 것도 컴파일 되지 않도록 한다.{ \"compilerOptions\": {\t//...생략 }, \"include\": [ \"app.ts\", /* app.ts만 컴파일한다. */ ],}files: 컴파일하고자 하는 개별 파일만 지정할 수 있다. 작은 규모의 프로젝트에 사용하면 된다.{ \"compilerOptions\": {\t//...생략 }, \"files\": [ \"app.ts\", /* app.ts를 컴파일한다. */ ],}(2) Basic 옵션{ \"compilerOptions\": /* Basic Option */ \"target\": \"es2016\", \"module\": \"commonjs\", \"lib\": [], \"allowJs\": true, \"checkJs\": true, \"sourceMap\": true, \"rootDir\": \"./src\", \"outDir\": \"./dist\", \"removeComments\": true, \"noEmitOnError\": true, //..등등 }} 옵션이름 설명 target 이 옵션으로는 어떤 자바스크립트 버전을 대상으로 코드를 컴파일할 것인지 타입스크립트에게 알려줄 수 있다. modules   lib dom으로 작업을 수행하는 항목들, 즉 기본 객체, 기능, 타입스크립트 노드를 지정하게 해준다.lib가 설정이 안 되어 있으면 기본 설정은 자바스크립트의 target에 따라 달라진다.es6로 설정한 경우, 기본적으로 es6에서 전역적으로 사용 가능한 모든 기능이 포함된다.즉, 이는 자바스크립트에서 전역적으로 사용 가능한 모든 es6의 기능들을 타입스크립트에서도 사용 가능하게 해주는 것이다.그래서 굳이 주석을 풀어서 값을 설정해줄 필요는 없다. allowJS 타입스크립트가 자바스크립트 파일을 컴파일 할 수 있도록 해준다. 파일이 .ts로 끝나지 않아도 컴파일을 할 수 있다. checkJS 타입스크립트는 컴파일을 수행하지 않더라도 구문을 검사하고 잠재적 에러를 보고한다.이 옵션은 allowJS와 함께 사용되며 타입스크립트를 사용하지 않고 일부 기능의 장점을 취하고자 할 때 유용하다. sourceMap 디버깅 작업과 개발에 유용하다. 값을 true로 설정하고 tsc 커맨드를 실행하면 .js.map파일들이 생성된다. 이 파일들은 자바스크립트 파일을 연결하는 최신 브라우저와 개발자 도구 간의 다리이다.개발자도구의 Sources탭에서 자바스크립트 파일 뿐만 아니라 타입스크립트 파일도 볼 수 있게 된다. 타입스크립트 파일에 중단점을 주어서 디버깅을 할때 도움을 줄 수 있다. outDir 프로젝트가 터지면 폴더에 나눠서 ts, js파일을 저장하게 된다. 타입스크립트 디컴파일러는 하위 폴더를 들여다보지만 출력값은 입력 파일 옆에 있기 때문에 입력 파일을 outDir로 제어할 수 있다. outDir을 설정하면 생성된 파일이 저장되는 위치를 타입스크립트 컴파일러에게 알릴 수 있다. rootDir 입력파일 (컴파일할 파일)이 위치한 루트 디렉토리를 설정할 수 있다. removeComments 컴파일 후 타입스크립트 파일에 있는 주석은 컴파일 되지 않는다. noEmit 자바스크립트 파일을 생성하지 않는다. downlevelIteration 코드를 이전 버전의 자바스크립트로 컴파일하고 for 루프로 작업한 경우 컴파일이 제대로 작동 되지 않는 경우가 있다. 해당 옵션을 설정하면 보다 정확하게 컴파일 할 수 있다. 루프가 있고 생성된 코드가 해당 루프와 다르게 작동하는 경우에만 이 옵션을 사용해야 한다. noEmitOnError 기본값은 false이다. 에러가 발생해도 타입스크립트는 자바스크립트 파일을 생성한다. 만약, true로 설정하면 문제가 되는 파일이 다시 생성되지 않는다. 에러를 수정해야 컴파일 할 수 있다.따라서 이 옵션은 일반적으로 타입스크립트 파일에 에러가 있는 경우 자바스크립트 파일을 가져오고 싶지 않은 경우에 설정한다. 참고 이미지 sourceMap 속성을 true로 할 경우 다음과 같은 폴더들이 추가되는 것을 확인할 수 있다. 이는 개발자도구 Sources탭에서 타입스크립트 파일을 확인할 수 있게 한다. rootDir과 outDir속성을 통해 입출력 폴더를 구조화 해서 관리할 수 있다.(3) Strict 옵션올바른 코드를 작성하고 발생할 수 있는 생소한 런타임 오류가 나타나지 않도록 도와준다.{ \"compilerOptions\": { /* Type Checking */ \"strict\": true, // \"noImplicitAny\": true, // \"strictNullChecks\": true, // \"strictFunctionTypes\": true, // \"strictBindCallApply\": true, // \"strictPropertyInitialization\": true, // \"noImplicitThis\": true, // \"useUnknownInCatchVariables\": true, // \"alwaysStrict\": true, }} 옵션 설명 strict 모든 stric 유형의 검사 옵션을 사용할 수 있다. 이 옵션을 설정하면 모든 stric 유형의 옵션을 개별적으로 설정하는 것과 같다. 물론 개별 옵션들을 false로 설정하여 각각 설정할 수도 있다. 그렇지 않으면 모든 개별 옵션값이 true로 설정된다. 즉, 모든 옵션을 true로 설정하려면 이 옵션만 사용하는 것이 간편합니다. noImplicitAny Enable error reporting for expressions and declarations with an implied ‘any’ type.매개변수와 값을 명확히 할 수 있도록 해준다. strictNullChecks When type checking, take into account ‘null’ and ‘undefined’.null값을 잠재적으로 가질 수 있는값에 접근하고 작업할 수 없게 한다. false로 설정할 경우 null값일 수 있는 요소에 작업을 할 수 있어서 런타임 에러가 발생할 수 있다. 그래서 일반적으로 true로 설정하고 !나 if문으로 처리한다. *예제1 strictFunctionTypes When assigning functions, check to ensure parameters and the return values are subtype-compatible. strictBindCallApply Check that the arguments for ‘bind’, ‘call’, and ‘apply’ methods match the original function.이 옵션의 기능은 기본적으로 호출하려는 함수가 bind, call, apply 중 무엇에 해당하는지 확인하고 여기에 함수를 제대로 설정했는지를 확인한다. strictPropertyInitialization Check for class properties that are declared but not set in the constructor.클래스로 작업을 하는 경우에 중요한 옵션이다. noImplicitThis Enable error reporting when ‘this’ is given the type ‘any’.this키워드와 관련있으며 타입스크립트는 기본적으로 this 키워드가 무엇을 의미하는지 명확하지 않은 위치에서 사용되면 경고한다. alwaysStrict Ensure ‘use strict’ is always emitted.alwaysStrict는 strict 모드를 사용하는 생성되는자바스크립트 파일이 추가되도록 한다. 예제1// 느낌표const button = document.querySelector(\"button\")!;// 조건문if (button){ button.addEventListener(\"click\", ()=&gt; { console.log(\"Clicked!\"); })}(4) 코드품질 옵션코드 품질을 향상시켜주는 옵션들로 기본적으로 사용되지 않은 변수가 있으면 타입스크립트가 에러를 표시한다.{ \"compilerOptions\": {\t// \"noUnusedLocals\": true, // \"noUnusedParameters\": true // \"noImplicitReturns\": true, }} 옵션 설명 noUnusedLocals Enable error reporting when local variables aren’t read.로컬 변수를 선언했는데, 사용하지 않으면 컴파일 도중 에러가 발생한다. noUnusedParameters Raise an error when a function parameter isn’t read.사용하지 않는 함수의 매개변수가 있으면 컴파일 도중 에러가 발생한다. noImplicitReturns Enable error reporting for codepaths that do not explicitly return in a function.특정 조건에 따라 반환하는 함수가 있다면 모든 조건에 반환을 해야 한다. 모든 조건에서 아무것도 반환하지 않는 것은 허용된다. " }, { "title": "01-TpyeScript-기본-타입", "url": "/posts/ts00/", "categories": "WEB, TypeScript", "tags": "TypeScript", "date": "2022-07-09 00:00:00 +0900", "snippet": "강의링크섹션1. TypeScript 시작하기1) TypeScript란? 타입스크린트는 결국 자바스크립트를 기반으로 하는 프로그래밍 언어이다. 자바스크립트 언어에 새로운 기능과 장점을 추가해 코드를 더 쉽고 강력하게 작성할 수 있다. (1) 핵심 기능 타입을 추가한다. 브라우저 런타임에서 에러가 발생하기 전에 코드의 에러를 개발자로서 미리 식별할 기회를 갖게 된다. 타입스크립트의 몇가지 새로운 기능을 통해 작업을 보다 나은 방법을 수행할 수 있는 것만 아니라, 오류 검사가 가능하다. (2) 특이사항 타입스크립트는 브라우저와 같은 자바스크립트 환경에서 실행할 수 없다.브라우저는 타입스크립트를 파싱할 수 없다. 그렇다면 어떻게 브라우저에 적용되는 것일까.타입스크립트는 언어이자 도구이다. 코드를 실행하여 타입스크립트 코드를 자바스크립트로 컴파일한다. 즉, 새로운 기능과 장점을 갖춘 타입스크립트 코드로 작성하면 자바스크립트로 컴파일 된다.그래서 타입스크립트의 새로운 기능들을 활용한 코드들은 개발도중 코드를 컴파일할때만 실행할 수 있는 코드이다.(3) 프리뷰자바스크립트const button = document.querySelector(\"button\");const input1 = document.getElementById(\"num1\")const input2 = document.getElementById(\"num2\")function add(num1, num2) { if (typeof num1 === \"number\" &amp;&amp; typeof num2 === \"number\"){ return num1 + num2; } else { return +num1 + +num2; }}button.addEventListener(\"click\", function() { console.log(add(+input1.value, +input2.value));});자바스크립트에서는 원치않는 연산을 하기 위해서는 전달된 인자가 숫자인지 typeof연산자를 통해 타입을 확인해야 한다. 만약, 문자열이 인자로 들어올 경우 \"5\" + \"3\" = \"53\"과 같은 연산이 나오기때문에 원치않는 결과가 도출될 것이다. 그러나, 타입스크립트에서는 함수의 전달되는 인자의 타입을 숫자로 확정함으로써, 위와 같은 사태를 막을 수 있다.타입스크립트// !는 타입스크립트에게 이것이 결코 null을 가져오지 않을 것임을 알려준다.// input이라고 알려줘야 하는 이유는 value라는 속성은 html의 모든 태그에 있지 않다. input태그란 것을 알려줘야 추후 value속성을 사용할 수 있는 것이다.const button = document.querySelector(\"button\");const input1 = document.getElementById(\"num1\")! as HTMLInputElement;const input2 = document.getElementById(\"num2\")! as HTMLInputElement;// num1과 num2가 숫자가 될 것 이라고 타입스크립트에 말해준다. function add(num1: number , num2: number) { return num1 + num2;}button.addEventListener(\"click\", function() { console.log(add(+input1.value, +input2.value));});// 컴파일 하는 방법 =&gt; tsc 파일 이름이렇게 타입을 명확하게 전달하여, 타입스크립트에게 개발자의 의도를 확실하게 전달할 수 있다. 이렇게 작성한 코드는 tsc 파일이름 명령어를 통해 자바스크립트 파일로 컴파일 할 수 있다.2) 간단한 개발 서버로 프로젝트 시작하기#프로젝트 활성화 $ npm init# lite-server:package.josn파일 옆에 항상 index.html 파일을 제공하는 간단한 개발 서버이다.$ npm install --save-dev lite-server --save-dev: 이 프로젝트에서 사용할 수 있는 도구를 설치하도록한다. (개발전용 종속성으로 표시한다.) 이는 개발 도중 도움이 될 도구로 메인코드의 일부로 실행되는 코드를 포함하지 않는다. lite-server: Node.js 기반의 경량 웹서버로 html 또는 javascript 변경을 감지하고 socket을 이용하여 css 변경을 주입하는 등의 유용한 기능을 제공한다.// package.json{ \"name\": \"ts\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"lite-server\" }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"lite-server\": \"^2.6.1\" }}위와 같이 package.json파일을 수정한다. start부분에 lite-server를 기입함으로써, 현재 node.js 프로젝트를 npm을 통해 구동할 시 실행될 명령어를 입력한다.# npm 구동하면 자동적으로 lite-server가 구동되면서 자동적으로 index.html이 웹브라우저에 로딩된다. $ npm start섹션2. TypeScript 기본 &amp; 기본 타입 핵심 타입스크립트 문법에 대해 알아보자1) 개요타입스크립트는 자바스크립트보다 많은 타입을 가지고 있다. 먼저, 자바스크립트에 공통으로 있는 타입들을 정리했다. Types Desc Example number 숫자형 (모든 숫자) 1, 5.3, -10 string 문자열 Hi, \"Hi\" boolean 참, 거짓 true, false object 객체 {age: 30} Array 배열 [1, 2, 3] Function 함수 function(){} 아래의 타임들은 자바스크립트에는 없지만, 타입스크립트에 있는 타입들이다. Types Desc Example Tuple 길이와 타입이 고정된 배열 [1, 2] Enum 라벨이 있는 열거 목록 enum {NEW, OLD} Union 여러 타입을 적용 number | stirng Literal 정확한 값을 가지는 타입 \"as-number\" Alias     2) number, string, boolean프리뷰에서 봤던 add함수를 예시를 들어서 다시 보자. 프리뷰에서는 add함수에서 숫자가 아닌 값을 인자로 넣는다면 숫자로 변경하고 +연산을 했다. 그러나 좀 더 간단하게, 자바스크립트로 다음과 같이 처리를 할 수도 있다.자바스크립트function add(n1, n2) { if (typeof n1 !== \"number\" || typeof n2 !== \"number\"){ throw new Error(\"Incorrect input!\") } return n1 + n2; }const number1 = \"5\";const number2 = 2.8;const result = add(number1, number2);console.log(result);위의 프리뷰와 달리 숫자가 아니면 타입을 인자로 넣으면 에러를 발생시켰다. 사실 타입스크립트를 사용하면 이를 애초에 막을 수 있는데, 발생시킬 필요가 없는 에러를 억지로 발생시킨 꼴이 되었다.자바스크립트의 경우 타입은 런타임 중에 확인된다. 그래서 특정 타입에 의존하는 코드가 있을 경우, 런타임에서 현재의 타입을 확인할 수 있게 도와주는 typeof연산자를 사용하게 된다.하지만, 타입스크립트는 정적타입으로 개발 도중에 끝나는 변수와 매개변수의 타입을 정의하게 된다. 즉, 타입스크립트의 타입은 컴파일 중에 확인되어 런타임 도중에 갑자기 타입이 변경되지 않는다.타입스크립트function add(n1: number, n2: number) { return n1 + n2;}const number1 = \"5\"; const number2 = 2.8;const result = add(number1, number2);console.log(result);이처럼 타입스크립트는 이처럼 컴파일 도중에 잘못 사용하고 있는지 확인하고 에러를 통해 알려준다. 아주 굿!3) 객체객체의 타입은 어딘가에 사용되는 객체 타입을 설명하기 위해 작성되는 것으로 key-value쌍을 통해 작성해야 한다. 만약, 상세히 객체의 타입을 적으려면 다음과 같이 작성해야 한다.const person: { name: string; age: number;} = { name: \"Coco\", age: 30}console.log(person.name);하지만, 이방식은 추천하지 않는다. 그냥 기존에 쓰던 방식으로 객체를 작성해도 타입스크립트가 올바른 타입을 추론할 수 있기 때문에 다음과 같은 코드가 좋다.const person = { name: \"Coco\", age: 30}console.log(person.name);4) 배열배열의 경우 어떤 타입을 넣을지 선택할 수 있다. 타입이 고정된 경우: number[], string[] 등 타입이 혼합된 경우: any[] 만약, 이미 배열에 값이 있으면 알아서 타입스크립트가 타입을 추론한다.const person = { name: \"Coco\", age: 30, // hobbies가 문자열 배열인걸로 알아서 추론한다. hobbies: [\"Sports\", \"Cooking\"],}// 문자열 배열 let favoriteActivities: string[];favoriteActivities = [\"Sports\"];// 혼합 배열let favoriteActivities2: any[];favoriteActivities2 = [\"Sports\", 2];console.log(person.name);// person.hobbies가 문자열 배열으로 추론하기 때문에 hobby는 문자열로 인식할 수 있기 때문에 toUpperCase()를 사용할 수 있다. // 우리가 설정한 타입때문에 hobby가 문자인것을 알 수 있다.for (const hobby of person.hobbies) { console.log(hobby.toUpperCase()); // console.log(hobby.map()) // !!!ERROR!!!!}5) 튜플타입스크립트는 배열의 값에 어떤 타입이 있는지 알지만, 구성을 알지 못한다. 이럴 때 튜플을 사용하게 된다. 즉, 타입은 알지만 구성은 모르게 때문에 명시적으로 재정의 해야 한다. 튜플을 타입스크립트에만 존재하는 타입이기 때문에 자바스크립트에서는 일반 배열로 인식된다.const person: { name: string; age: number; // 배열 타입 지정 hobbies: string[]; // 튜플 타입 지정 role: [number, string]; } = { name: \"Coco\", age: 30, hobbies: [\"Sports\", \"Cooking\"], // 타입스크립트는 배열이 문자열과 숫자 유형의 타입으로 구성된 것은 알지만, 첫번째 요소가 숫자고 두번째 요소가 문자열이여야 한다는 것은 모른다. // 명시적으로 재정의 한다. role: [2, 'author']}// 오류 발생 person.role = [0, 'admin', 'user'];// 오류 발생 person.role[1] = 10;// 배열의 길이를 지정하지 않았기 때문에 push를 통해 추가할 수 있다. person.role.push(\"admin\");6) ENUM열거형타입으로 이름이 있는 상수들의 집합을 정의할 수 있다. 열거형을 사용하면 의도를 문서화 하거나 구분되는 사례 집합을 만들 수 있다. 만약 라벨이 필요한 경우 자바스크립트에서는 다음과 코드를 만들 수 있다.자바스크립트const ADMIN = 0;const READ_ONLY = 1;const AUTHOR = 2;const person = { name: \"Coco\", age: 30, hobbies: [\"Sports\", \"Cooking\"], role: ADMIN}if (person.role === ADMIN) { console.log(\"is admin\")}타입스크립트로 다음과 같이 수정할 수 있다.타입스크립트// ADMIN은 1, READ_ONLY은 2, AUTHOR은 3을 값으로 가진다. enum Role { ADMIN, READ_ONLY, AUTHOR};const person = { name: \"Coco\", age: 30, hobbies: [\"Sports\", \"Cooking\"], role: Role.ADMIN}if (person.role === Role.ADMIN) { console.log(\"is admin\")}아래의 이미지처럼 자동으로 숫자가 라벨링처럼 생기는 것을 확인할 수 있다.타입스크립트를 자바스크립트로 컴파일한 결과var Role;(function (Role) { Role[Role[\"ADMIN\"] = 0] = \"ADMIN\"; Role[Role[\"READ_ONLY\"] = 1] = \"READ_ONLY\"; Role[Role[\"AUTHOR\"] = 2] = \"AUTHOR\";})(Role || (Role = {}));;7) Union, Literal, AliasUnion 타입은 입력값을 좀 더 유연하게 처리할 수 있게 해준다. 여러 타입을 함수의 매개변수, 상수 혹은 변수로 사용해야 한다면 유니언 타입을 사용할 수 있다. 만약, Union타입을 통해 함수의 매개변수를 유연하게 한다면 타입에 따라 함수 로직이 달라질 수 있기 때문에 종종 런타임 검사가 필요한 경우도 있다.Literal 타입은 숫자나 문자열과 같은 타입이 아니라 정확한 값을 가지는 타입이다.Alias는 type키워드를 활용하여 타입을 변수에 지정할 수 있다. type 변수이름 = 인코딩하고자 하는 타입과 같이 설정하면된다. Alias는 Union타입을 자주쓰기 귀찮을 때 사용하는 경우가 많다. 즉, 재사용 가능한 이름을 지정하게 되는 것이다. 또한, 유니온 타입을 저장하는 것만 가능한 것이 아니라 복잡할 수 있는 객체 타입에도 별칭을 붙일 수 있다.// Aliastype Combinable = number | string; // Union type ConversionDescriptor = \"as-number\" | \"as-text\" // Literal타입으로 Union타입을 생성 function combine( input1: Combinable, input2: Combinable,resultConversion: ConversionDescriptor) { let result; // 매개변수가 유니언 타입이기 때문에 런타임 검사가 필요한 경우가 있다. if (typeof input1 === \"number\" &amp;&amp; typeof input2 === \"number\" || resultConversion === \"as-number\" ) { result = +input1 + +input2; } else { result = input1.toString() + input2.toString(); } return result}const combineAges = combine(30, 26, \"as-number\");console.log(combineAges);const combineStringAges = combine(\"30\", \"26\", \"as-number\");console.log(combineStringAges);const combineNames = combine(\"MAX\", \"Anna\", \"as-text\");console.log(combineNames);복잡한 객체타입을 Alias를 통해 별칭을 지정할 수도 있다. 타입 별칭을 사용하면 불필요한 반복을 피하고 타입을 중심에서 관리할 수 있습니다. 아래는 Alias를 사용하지 않은 경우이다.type User = { name: string; age: number };function greet(user: { name: string; age: number }) { console.log('Hi, I am ' + user.name);} function isOlder(user: { name: string; age: number }, checkAge: number) { return checkAge &gt; user.age;}코드를 아래와 같이 단순화할 수 있다.type User = { name: string; age: number }; function greet(user: User) { console.log('Hi, I am ' + user.name);} function isOlder(user: User, checkAge: number) { return checkAge &gt; user.age;}8) Function함수에 매개변수와 반환값에 타입을 지정할 수 있다. 매개변수에 따라 원치않는 결과가 나올 수 있기 떄문에 타입을 명시적으로 지정하는 것이 좋다.또한, 함수에는 반환 타입도 중요하다. 반환타입은 타입스크립트가 추론한다. 반환타입을 명시적으로 기입할 수 있지만 추론과 같은 타입을 적어야 하기 때문에 굳이 명시적으로 적을 필요가 없다. 만약, 아무것도 반환하지 않는경우 반환타입은 void가 된다.콜백함수도 마찬가지이다. 함수로 타입을 지정하고 매개변수와 반환값에 타입을 지정할 수 있다. 어떤 유형의 함수를 지정할지 구체화 할 수 있다.function add(n1: number, n2: number): number { return n1 + n2;}// 아무것도 반환하지 않는 경우: 반환타입은 void타입이 된다.function printResult(num: number): void { console.log(\"Result: \" + num);}// 아무것도 반환하지 않는 함수의 반환값을 사용하면 undefined가 출력된다.console.log(printResult(add(5, 12))); // undefined는 반환은 하지만, 실제 값을 반환하지 않을 때 사용할 수 있다.function printResult2(num: number): undefined { console.log(\"Result: \" + num); return;}let someValue: undefined;let combineValues: (a: number, b: number) =&gt; number;// function타입만 지정해서는 잘못된 함수를 지정할 수 없다. 그러나 매개변수와 반환값에 타입을 지정해야 한다. combineValues = printResult;// 콜백함수 정의function addAndHandle(n1: number, n2: number, cb: (num: number) =&gt; void) { const result = n1 + n2; cb(result);}addAndHandle(10, 20, (result) =&gt; { console.log(result);});스프레드 연산자만약 함수에 스프레드 연산자를 통해 매개변수를 전달한다면, 이 또한 타입을 설정해야 한다.const add = (...numbers: number[]) =&gt; { return numbers.reduce((curResult, curValue)=&gt; { return curResult + curValue; }, 0);};const addNumbers = add(5, 10, 2, 3.7);console.log(addNumbers);이것이 인수를 무한정으로 받아들이기 위한 정말 유용한 기능인 나머지 매개변수이다.꼭 배열이 아니라 튜플 형식으로도 가능하다. ...numbers: [number, number, number]9) unknown개발자는 종종 알지 못하는 변수 유형을 설명해야 할 수도 있습니다. 이러한 경우, 이 변수가 무엇이든 될 수 있음을 알려주는 타입을 제공하기 위해 unknown유형을 사용할 수 있다. typeof검사, 비교 검사를 통해 타입을 보다 구체적인 것으로 좁힐 수 있다.any 는 타입을 좁혀서 사용하지 않아도 되지만, unknown 은 타입을 좁혀서 사용해야만 하기 때문에 any 를 사용하는 곳에서 unknown 을 사용하여 보다 안전하게 코딩이 가능하다.// 알수 없는 타입: 어떤 타입을 저장할지 모른다.let userInput: unknown;let userName: string;// any와 같이 어떤 타입이든 올 수 있다. userInput = 5;userInput = \"Coco\";// 에러 발생: unknown 타입은 any 타입을 제외한 다른 타입으로 선언한 변수에 할당할 수 없다. username = userInput//추가적인 검사를 추가하여 어떤 작업을 수행할지 명시할 수 있다.if (typeof userInput === \"string\") { userName = userInput;}10) never일반적으로 함수의 리턴타입으로 사용되며 항상 오류를 출력하거나 리턴 값을 절대로 내보내지 않음을 의미한다. 즉, never는 함수가 종료하지 않아 절대 return 하지 않을 때 사용된다. (void는 return 값이 없을 뿐이지 함수는 종료한다. )never의 사용은 코드 품질의 관점에서 의도를 더 분명하게 할 수 있다. never를 반환 값으로 갖는 함수는 아무것도 반환하지 않고 기본적으로 스크립트나 스크립트의 일부를 충돌시키거나 망가트리기 위한 것임을 코드를 읽는 개발자가 알게 한다.function generateError(message: string, code: number):never { throw { message: message, errorCode: code };}const result = generateError(\"An error occurred\", 500);console.log(result);" }, { "title": "컴퓨터구조-레지스터-전송과-마이크로-연산", "url": "/posts/computerstructure04/", "categories": "CS, 컴퓨터-구조", "tags": "cs, 컴퓨터-구조", "date": "2022-07-06 00:00:00 +0900", "snippet": "레지스터 전송과 마이크로 연산 파트1강의 링크1) 레지스터 전송 언어 (Register Transfer Language)(1) 마이크로 연산 (Micro-operation) 레지스터에 저장된 데이터를 가지고 실행되는 기본동작을 의미한다. 하나의 clock 시간 동안 실행되는 기본 동작이다. (플립플롭회로로 구성되어 있기 때문에 clock의 개념이 나온다.) shift count clear load 등 (2) 레지스터 전송 언어 마이크로 연산, 전송을 간단하고 명료하게 표시하기 위하여 사용하는 기호이다. 디지털 컴퓨터의 내부 조직을 상세하게 나타내는 수단으로 사용된다. 디지털 시스템의 설계 편의성을 제공한다.(3) 레지스터 전송 언어 규칙 대문자로 표시한다. (MAR, MBR, AC, PC, DR 등) 레지스터는 여러개의 플립플롭으로 구성되어있다. 그중 가장 왼쪽에 있는 플립플롭에 저장된 비트 값을 MSB(Most Significant Bit)라고 한다. 그중 가장 오른쪽에 있는 플립플롭에 저장된 비트 값을 LSB(Least Significant Bit)라고 한다. 16비트 PC 레지스터의 경우, 상위 8bit(8~15)를 High 레지스터: PC(H)라고 한다 하위 8bit(0 ~7)를 Low 레지스터: PC(L) 라고 한다. 2) 레지스터 전송 (Register Transfer)(1) 레지스터 정보 전송 치환 (replacement)연산자 사용 R2 &lt;- R1 R1에 있는 데이터를 R2로 전송해라. 제어 조건이 있을 경우, If (P=1) then (R2 &lt;- R1) P가 1이면, R1에 있는 데이터를 R2로 전송해라. 제어 함수로 표현할 경우, P: R2 &lt;- R1 P가 1이면, 다음 문장을 실행하라. 즉, 다음 클럭(t+1타이밍)에 전송완료된다. (2) 레지스터 전송의 기본 기호 Register data exchange T:R2 &lt;- R1, R1 &lt;- R2 3) 버스와 메모리 전송 (Bus and Memory Transfers)(1) 공통버스 (Common Bus) 레지스터들 사이의 전송 통로 충돌을 막기 위해 동시에 하나의 device에서만 사용이 가능하다. 어떤 device가 이 버스를 사용하는가.를 제어하는 것이 멀티 플렉서이다. 한 번에 하나의 신호만 전송하도록 제어한다. 멀티플렉서를 사용하여 레지스터를 선택한다. =&gt; 공통버스를 제어하는 제어장치 (버스 제어기)(2) 3-상태 버퍼 (3-state Buffer) 멀티플렉서 대신 사용하여 버스 구성을 할 수 있다. 3개의 상태로 조작한다. 논리0, 논리 1: 정상적인 버퍼로 동작 고저항상태: 출력 차단 (3) 메모리 전송 Read: DR &lt;- M[AR] AR번지에있는 메모리를 데이터 레지스터를 보낸다. Write: M[AR] &lt;- R1 R1값을 AR번지에 있는 메모리에 보낸다. 레지스터 전송과 마이크로 연산 파트2강의 링크1) 산술 마이크로 연산 (Arithmetic Micro-operations) 레지스터간 이진 정보 전송(1) 이진 가산기 두 비트와 이진 캐리의 산술 합을 계산한다. 여러 개의 전가산기를 연결한다.(2) 이진 감가산기 보수를 만드는 게이트와 신호를 사용한다. M -&gt; 0: 가산 M -&gt; 1: 감산 A(0-3), B(0-3), S(0-3)는 bus에 연결한다.(3) 산술회로 4개의 전가산기 4개의 멀티플렉서 2개의 4비트 입력 1개의 출력 3개의 제어라인2) 논리 마이크로 연산 (Logic Micro-operations) 수치 데이터에 대한 산술 연산3) 시프트 마이크로 연산 (Shift Micro-operations) 비수치 데이터에 대한 비트 조작 연산(1) 논리 시프트 ex) 오른쪽으로 시프트한다: 한 비트씩 오른쪽으로 이동한다. 제일 왼쪽에 있는 남은 한비트가(빈 공간) 0이된다. 즉, 직렬 입력으로 0이 전송된다. R1 &lt;- shl(R1) R2 &lt;- shr(R2)(2) 순환 시프트 논리 시프트의 확장판이다. ex) 오른쪽으로 시프트한다: 한 비트씩 오른쪽으로 이동한다. 이동하면서 튕겨나가는 비트가 제일 왼쪽에 있는 빈공간을 차지한다. 즉, 직렬 출력이 직렬 입력으로 전송된다. cir, cil(3) 산술 시프트 부호 비트를 제외하고 시프트한다. 왼쪽 시프트: x2 오른쪽 시프트: /2" }, { "title": "컴퓨터구조-데이터의-표현", "url": "/posts/computerstructure03/", "categories": "CS, 컴퓨터-구조", "tags": "cs, 컴퓨터-구조", "date": "2022-07-02 00:00:00 +0900", "snippet": "데이터의 표현 파트 1강의링크1) 데이터의 종류 (Data Types)(1) 컴퓨터 레지스터에서 쓰이는 데이터 종류 산술 연산용 숫자 (Numeric): 원래 숫자처리를 하기 위해 만들어진 것이 컴퓨터이다. 데이터 처리용 영문자(Alpha) 특수 목적용 기호 (Special)(2) 진수와 진법 radix: 진법의 기수에 해당 (10, 2, 8, 16…) 10진수 **2진수: 컴퓨터의 이진법 체계 ** 2진화 8진수 (Octal) 2진화 16진수 (Hexadecimal) 2진화 10진수 (BCD: Binary Code Decimal) 8진수 16진수(3) 영숫자(AlphaNumeric) 표시 ASCll Code: 7bits (+ 1parity bits) 미국에서 사용되는 표준 상위 4비트의 존비트와 하위 4비트의 숫자비트로 구성된다. EBCDIC Code: 16bits, IBM internal code UniCode: 16bits/ 32bits ASCll코드의 표현의 한계를 해결 (ASCII 코드는 7비트이기 때문) =&gt; 16비트를 사용하여 세계 모든 언어의 문자와 그밖의 기호에 코드 값을 부여 다른 나라의 문자를 사용할 경우, ASCll코드로는 표현을 하기 어렵기 때문에 Unicode 체계가 자리잡게 되었다. 기본적으로 ASCll코드와 유사하다. USA ASCll Code TABLE2) 보수 (Complements)(1) 정의 보충을 해주는 수 진법의 기수 r에 대응하는 역 값 뺄셈과 논리 계산에 사용된다.(2) (r-1)의 보수 체계 r-1에서 각 자리 숫자를 뺀다. ex) 10진수 12389에 대한 9의 보수 = 99999 - 12389 = 87610 ex) 2진수 0011에 대한 1의 보수 = 1111 - 0011 = 1100 xor(3) (r)의 보수 체계 r-1의 보수에 1을 더한다. ex) 10진수 12389에 대한 10의 보수 = 100000 -12389 = 87611 ex) 2진수 0011에 대한 2의 보수 = 1100 + 1 = 1101💬 컴퓨터는 원래 뺄셈, 곱하기, 나누기를 할 줄 못한다? 원래 cpu는 해당 기능이 없다. 모든 연산을 덧셈으로 한다. (가산기를 이용해 음수 연산을 한다.) 곱셈: 덧셈의 반복 뺄셈: 보수 연산 (보수의 덧셈) 나눗셈: 보수 연산의 반복 데이터의 표현 파트 2강의링크1) 고정 소수점 표현 (Fixed Point Representation)(1) 정의 소수점의 위치를 결정하여 숫자를 표현한다. 레지스터 비트에 소수점 위치를 표시한다. 16bit 정수의 경우, 최우측 (LSB)에 소수점 자리가 위치한다. 부동 소수점의 경우, 레지스터 비트 앞/ 중간에 소수점 자리 위치한다.(2) 정수의 표현 MSB로 부호를 표현한다. 양수는 MSB가 0, 음수는 MSB가 1이다.💬-14를 표시한다면..?음수이기 때문에 MSB는 1이다.14는 1110이기 때문에 -14를 16bit로 표현한다면 1 0001110이 된다.만약 부호화된 1의보수로 표현하면 , 1110001이다.만약 부호화된 2의 보수로 표현하면, 1 1110010이다. =&gt; 대부분의 컴퓨터. CPU에서 활용된다.(3) 오버플로우(overflow)발생 N자리의 두수를 더하여 N+1자리의 합이 발생했을때, 가수와 피가수의 부호와 관계없이 발생한다. 정해진 레지스터의 비트수로 인한 문제이다. 정해진 비트수 내에서만 연산이 가능한 컴퓨터에서 발생한다.발생원인 연산 결과값이 레지스터의 비트수를 초과할 경우 발생한다. 두 수의 부호가 같을 경우에만 발생한다. (부호 비트를 더해버려서) 레지스터에 저장된 연산 결과값은 잘못된 값으로 저장된다.처리 방법 오버플로우 발생을 미리 확인한다. MSB의 두 캐리 비트의 값이 서로 다르다. 8번째 비트와 7번째 비트의 값이 다르면 오버플로우다. 연산을 처리하지 않고 인터럽트 또는 에러 처리한다.2) 부동 소수점 표현 (Floating Point Representation)(1) 부동소수점 표시 방법 (IEEE 754) 가수와 지수로 표현한다. (32bit, 64bit 등 컴퓨터마다 다르다.) 가수(matissa): 분수(fraction), 정수값 표시한다. 지수(component): 십진, 이진 소수점 위치를 표시한다.💬 +1001.11을 32bit로 표현한다면? fraction: 01001110 component: 000100 부호비트, 지수비트(8bit), 가수비트(23bit)로 구성된다.0 1000100(128biased) 00111000000000000000000(가장 좌측 1을 제외한다.)가수의 경우, 어차피 소수점 다음 자리는 무조건 1이니까 더 많은 수를 표현을 하기 위해서 가장 좌측의 1을 제외한다.(2) 정규화(Normalization) 부동소수점 숫자에서 최상위 비트가 0이 아닌 경우, 0이 있으면 Mantissa의 소수점 위치가 이동한다. 이동한 만큼 exponent의 값이 변경된다.3) 기타 이진 코드 (Other Binary Codes)(1) Grey Code 한 숫자에서 다음 숫자로 변할 때 한 비트만 변동한다. 제어 계통에 주로 사용된다. 여러 전기 신호가 동시에 바뀔 때 에러 발생률이 낮다.(2) BCD Code 10진수에 대한 2진수를 표현한다. (i.e.8421 code) 4bit를 사용한다. (0~9까지 사용한다.)(3) Excess-3 binary + 3(0011)으로 표현한다. 암호 교신의 기본 코드로 파생 암호 발생 방법에 사용된다.4) 에러 검출 코드 (Error Detection Codes)(1) Parity bit 외부 잡음에 의한 에러 발생을 검출하기 위해 별도의 데이터 bit인 Parity bit를 사용한다. 짝수(even) 패리티/ 홀수(odd) 패리티가 있다. 짝수 패리티: 실제 송신하고자 하는 데이터의 각 비트의 값 중에서 1의 개수가 짝수가 되도록 패리티 비트를 정한다. 홀수 패리티: 실제 송신하고자 하는 데이터의 각 비트의 값 중에서 1의 개수가 홀수가 되도록 패리티 비트를 정한다. 가장 간단하고도 일반적인 방법이지만, 2개 비트 동시 에러의 경우 검출이 불가능하다.(2) Parity bit 적용 송신측: 패리티 발생기 수신측: 패리티 검사기 수신측의 패리티 검새결과가 데이터 패리티와 일치하면 에러가 없는 것이다. =&gt; 0 출력 수신측의 패리티 검사결과가 데이터 패리티와 불일치하면 에러가 발생한 것이다 =&gt; 1출력" }, { "title": "꼭-알아야-하는-vue3-변경사항-톺아보기", "url": "/posts/vue00/", "categories": "WEB, Vue", "tags": "vue", "date": "2022-07-01 00:00:00 +0900", "snippet": "1. v-model의 변화 Vue 3에서는 혼동을 줄이고 개발자가 v-model 디렉티브를 보다 유연하게 사용할 수 있도록, 양방향 데이터 바인딩을 위한 API가 표준화되었다.공식문서1) 컴포넌트에 사용되는 v-model의 prop 및 event 사용법이 변경 2.x 3.x value modelValue input update:modelValue model 옵션 전달인자 사용 (1) 2.x&lt;!-- 부모 컴포넌트 --&gt; &lt;template&gt; &lt;div&gt; &lt;!-- 변수 inputData를 속성 value에 바인딩하고 input이벤트를 수신하여 변수 inputData를 업데이트 한다. --&gt; &lt;my-input-component v-model=\"inputData\"&gt;&lt;/my-input-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyInputComponent from \"./MyInputComponent.vue\";export default { name: \"MyComponent\", components: { MyInputComponent, }, data() { return { inputData: \"\", }; },};&lt;/script&gt; 2.x에서 컴포넌트에 v-model을 사용하는 것은 value를 prop으로 전달하고 input 이벤트를 emit 하는 것과 같다. 즉, input 이벤트가 발생했을 때, value값이 변경되는 것과 같다.&lt;!-- 자식 컴포넌트 --&gt; &lt;template&gt; &lt;div&gt; &lt;input type=\"text\" :value=\"value\" @input=\"$emit('input', $event.target.value)\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: \"MyInputComponent\", props: [ \"value\" ], }&lt;/script&gt;prop이나 이벤트 명을 변경하려면?&lt;!-- 자식 컴포넌트 --&gt; &lt;template&gt; &lt;div&gt; &lt;input type=\"text\" :textData=\"textData\" @input=\"$emit('custom-change', $event.target.value)\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: \"MyInputComponent\", model: { props: \"textData\" event: \"custom-change\" } props: { textData \t} }&lt;/script&gt; 만약 prop 또는 이벤트 명을 다른 이름으로 변경하려면 model 옵션의 추가가 필요하다.🤔 잠깐! vue 2.x에 있던 .sync수식어란?props에 양방향 바인딩이 필요한 경우 (v-model외에 추가적으로 다른 props에 양방향 바인딩을 사용해야 하는 경우), 다음과 같이 코드를 작성한다. 자식 컴포넌트에서 부모 컴포넌트의 값을 수정하기에, 부모 컴포넌트에서는 어떠한 자식 컴포넌트가 값을 수정한 것인지 파악하기 어렵다. 그래서 자식 컴포넌트에서 update:propName을 이용하여 이벤트를 부모 컴포넌트에 전달한다.자식 컴포넌트에서 this.$emit('update:propName', newValue)를 통해 새로운 값이 할당되었음을 부모에게 알린다. 그때 부모는 아래와 같은 코드로 해당 이벤트를 듣는다.&lt;!-- 변수 inputData를 속성 propName에 바인딩하고 update:PropName 이벤트를 수신하여 변수 inputData를 업데이트한다. --&gt;&lt;my-input-component :propName=\"inputData\" @update:propName=\"inputData = $event\"/&gt;&lt;!-- 축약된 방식은 아래와 같다 --&gt;&lt;my-input-component :propName.sync=\"inputData\"/&gt; v-model과의 차이점 sync를 사용할 때는 자식 컴포넌트에는 valueProp이 필요하지 않다. 대신 부모와 동일한 prop 이름을 사용한다. 또한, prop을 업데이트 하기위해 input 이벤트를 emit하는 것이 아니라 update:propName을 emit한다. 하나의 컴포넌트에 다중으로 사용이 가능하다. (2) 3.x&lt;!-- 부모 컴포넌트 --&gt; &lt;template&gt; &lt;div&gt; &lt;h1&gt;3.x&lt;/h1&gt; &lt;my-input-component v-model=\"inputData3\"&gt;&lt;/my-input-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyInputComponent from \"./MyInputComponent.vue\";export default { name: \"MyComponent\", components: { MyInputComponent, }, data() { return { inputData3: \"\", }; },};&lt;/script&gt; 컴포넌트에 v-model을 사용하는 것은 modelValue prop를 전달하고 update:modelValue 이벤트를 emit 하는 것과 같다.&lt;!-- 자식 컴포넌트 --&gt; &lt;template&gt; &lt;input type=\"text\" :value=\"modelValue\" @input=\"$emit('update:modelValue', $event.target.value)\"&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"MyInputComponent\", props: { modelValue: { type: String } },}&lt;/script&gt;prop이나 이벤트 명을 변경하려면?&lt;my-input-component v-model:content=\"inputData3\" /&gt;&lt;!-- 축약된 방식은 아래와 같다 --&gt;&lt;my-input-component :content=\"inputData3\" @update:content=\"inputData3 = $event\" /&gt; 3.x에서 모델명을 변경하려면 model 옵션 대신에 전달인자를 v-model에 전달할 수 있다. (props를 통한 부모와 자식의 양방향 통신) 이는 .sync수식어를 대체하는 역할을 한다.2) 다중 v-model 바인딩 다중으로 v-model을 바인딩 할 수 있다.한 컴포넌트에 다중으로 사용할 수 있는.sync수식어를 완벽하게 대체하기 위해 v-model에도 적용되게 되었다.이제는 단일 컴포넌트 인스턴스에 대해 다중 v-model 바인딩이 가능해졌다.&lt;!-- 부모 컴포넌트 --&gt; &lt;template&gt; &lt;div&gt; &lt;h1&gt;3.x&lt;/h1&gt; &lt;my-input-component v-model:\"firstName\" v-model:\"lastName\" &gt;&lt;/my-input-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyInputComponent from \"./MyInputComponent.vue\";export default { name: \"MyComponent\", components: { MyInputComponent, }, data() { return { firstName: \"\", lastName:\"\" }; },};&lt;/script&gt;&lt;!-- 자식 컴포넌트 --&gt; &lt;template&gt; &lt;input type=\"text\" :value=\"firstName\" @input=\"$emit('update:firstName', $event.target.value)\"&gt; &lt;input type=\"text\" :value=\"lastName\" @input=\"$emit('update:lastName', $event.target.value)\"&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"MyInputComponent\", props: { firstName: { type: String }, lastName: { type: String } },}&lt;/script&gt;3) 사용자 수식어 생성 기능 추가 커스텀 수식어를 추가할 수 있다. 빌트인 수식어 설명 예시 .lazy input대신 change 이벤트 이후에 동기화 할 수 있다. &lt;input v-model.lazy=\"msg\"&gt; .number 사용자 입력이 자동으로 숫자로 형변환 된다. &lt;input v-model.number=\"age\" type=\"number\" /&gt; .trim 사용자 입력 중 양쪽 공백을 제거한다. &lt;input v-model.trim=\"msg\" /&gt; v-model은 위의 표에 정리된 것처럼 빌트인 수식어를 가지고 있다. 이제는 상황에 따라서 커스텀 수식어를 만들 수 있다.공식문서에 예제가 있으니 참고하면 된다.2. CompositionAPI이전의 vue는 optionAPI기반으로 컴포넌트를 구성했다. optionAPI는 컴포넌트의 옵션들 (data, computed, methods, watch)로 논리에 따라 구분하여 컴포넌트를 구성하게 된다. 하지만, 컴포넌트가 커지면 커질 수록 해당 옵션들 또한 커지게된다. 기능별로 묶여있는 것이 아닌 옵션 별(논리적 구분)로 묶여있기 때문에 코드가 길어질 수록 코드 가독성이 떨어질 수 밖에 없다. 즉, 하나의 기능을 논리적인 분류에 따라 분산하여 작성하기 때문에 코드가 분산되어 작성될 수 밖에 없다.그래서 이를 보완하기 위해 compositionAPI가 등장하게 되었다. 기능별 + 논리별로 코드를 배치하게 한다. 흩어져있는 데이터를 한 곳에 모아서 관리를 함으로 재사용성을 높일 수 있다.1) setup새로운 setup 컴포넌트 옵션은 컴포넌트가 생성되기 전에, props가 한번 resolved될 때 실행되며 composition API의 진입점 역할을 한다.이곳에 논리적인 흐름에 따라서 구현하고 싶은 기능을 넣어준다. setup은 컴포넌트 인스턴스가 생성되지 않았기 때문에 props, context를 제외하고 컴포넌트 내부 데이터에 접근할 수 없다. 즉, this 접근이 불가능하다. setup 함수의 첫번째 전달인자는 props이고 두번째 전달 인자는 context이다. props는 반응성이 있다. (ES6 구조 분해 할당을 하면 반응성을 잃는다. ) context는 3가지 컴포넌트 프로퍼티를 가지는 일반 JS 객체로 반응성이 없다. context.attrs context.slots context.emit attrs와 slots은 컴포넌트 자체가 업데이트될 때, 항상 업데이트되는 상태 저장 객체이다. 즉, attrs와 slots에 구조분해할당을 피하고, 항상 속성을 attrs.x와 slots.x의 형태로 참조해야한다. 그래서 attrs나 slots의 변경으로 인한 사이드이펙트를 의도하려면, onUpdated 라이프사이클 훅 안에서 수행해야한다.&lt;script&gt; export default { setup(props, {attrs, slots, emit}){ ... } }&lt;/script&gt;(1) ref 원시자료형 데이터를 반응형으로 만드는 함수&lt;template&gt; &lt;div&gt; 9&lt;/div&gt; &lt;button @click=\"countUp\"&gt; 카운트 업!&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import { ref } from \"vue\" export default { setup(){ const count = ref(0); const countUp = ()=&gt; { count.value++ } return { count, countUp }; }; };&lt;/script&gt;&lt;!--======= optionAPI =======--&gt;&lt;script&gt; export default { data(){ return { count: 0 }; }, methods: { count(){ this.count++ } }; };&lt;/script&gt; ref: 전달인자를 받고 반응형 변수의 값에 접근하거나 변경할 수 있는 value속성을 가진 객체를 반환한다. (값에 반응형 참조를 만든다 ) ref객체는 단 하나의 속성을 가지는데, 내부 값을 가리키는 .value이다. ref 가 retrun을 통해 반환되고 템플릿에서 접근되면, 자동적으로 내부 값을 풀어냅니다. 즉, 템플릿에서 .value 를 추가할 필요가 없다. 관련 함수 설명 unref 주어진 인자가 ref라면 내부 값을 반환하고, 아니라면 주어진 인자를 반환한다. toRef 소스가 되는 reacitve 객체의 속성을 가져와 ref를 만들 수 있다. 이 ref는 여기저기 인자로 전달할수 있으면서, 소스 객체에 대해 리액티브 연결을 유지할수 있습니다. toRefs reactive 객체를 일반 객체로 변환하여 반환하지만, 반환되는 객체의 각 속성들이 ref로 원래의 reactive 객체 속성으로 연결된다.반응성을 잃지 않고 반환된 값을 구조 분해 할당 할 수 있다. isRef 주어진 값이 ref 객체인지 확인한다. &lt;!-- 2.toRef --&gt; &lt;script&gt; import {toRef, reactive} from \"vue\"; const state = reactive({ foo: 1, bar: 2 }) const fooRef = toRef(state, 'foo') fooRef.value++ console.log(state.foo) // 2 // 연결이 유지되어있다. state.foo++ console.log(fooRef.value) // 3 &lt;/script&gt;&lt;!-- 3.toRefs --&gt; &lt;script&gt; import {toRefs, reactive} from \"vue\"; function useFeatureX() { const state = reactive({ foo: 1, bar: 2 }) return toRefs(state) }; export default { setup(props) { const { baz } = toRefs(props); const { foo, bar } = useFeatureX(); return { foo, bar }; }; };&lt;script&gt; props의 구조분해할당이 필요한 경우, setup펑션의 toRefs를 사용하여 반응성을 유지할 수 있습니다. props는 반응성이 있다. 그러다 단순하게, ES6의 구조분해할당을 사용한다면 props의 반응성이 제거된다. toRefs는 소스 객체에 포함 된 속성에 대한 ref만 생성합니다. 특정 속성에 대한 참조를 만들려면 대신 toRef를 사용하면 된다.🤔 반응형…?반응형 API(2) reactive 객체 형태의 데이터를 반응형 상태로 생성하기 위해 사용하는 메서드&lt;template&gt; &lt;div&gt; 9&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { ref, reactive } from \"vue\" export default { setup(){ const age = ref(20);\t const state = reative({ name: \"박싸피\", age }); return { state }; }; };&lt;/script&gt; reactive: 객체의 반응형 복사본을 반환한다. 반응형이 깊게 적용 된다. 모든 중첩된 속성의 변화를 감지한다. reactive객체의 속성에 ref를 할당하면, 자동적으로 내부 값으로 벗겨내서 사용된다. 관련 함수 설명 readonly 객체(반응형 또는 일반 객체) 또는 ref를 가져와서 원본에 대한 읽기전용으로 변경한다. (수정을 가하지 못하는 복사본) isReactive 객체가 반응형(reactive)로 생성된 것인지 아닌지 확인한다. shallowReadonly 고유한 속성을 읽기 전용으로 만들지만 중첩된 객체의 경우 수정이 가능하다. &lt;!-- 1. readonly --&gt;&lt;script&gt; import { reactive, readonly } from 'vue' const original = reactive({ count: 0 }) const copy = readonly(original) // 원본이 변이되면 복사본인 copy의 값도 변한다. original.count++ // 복사본을 변이하려고 하면 경고와 함께 실패한다. copy.count++ // warning: \"Set operation on key 'count' failed: target is readonly.\" &lt;/script&gt;&lt;!-- 3. shallowReadonly --&gt; &lt;script&gt; import { shallowReadonly } from 'vue' const state = shallowReadonly({ foo: 1, nested: { bar: 2 } }) // 객체의 자체적인 속성 변경이 안된다. state.foo++ // 하지만 중첩된 객체에서는 수정이 가능하다. isReadonly(state.nested) // false state.nested.bar++ // 반응&lt;/script&gt;(3) watch Vue에서 import한 watch함수를 사용하여 동일한 작업을 수행할 수 있다.3가지의 전달인자를 허용한다. 감시를 원하는 반응성 참조나 getter function 콜백 ((value, oldValue, onInvalidate) =&gt; void형태의 콜백) 선택적인 구성 옵션 (immediate나 deep과 같은 wathchOptions)&lt;template&gt; &lt;div&gt; 9&lt;/div&gt; &lt;button @click=\"countUp\"&gt; 카운트 업!&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import { ref, watch } from \"vue\" export default { setup(){ const count = ref(0); const countUp = ()=&gt; { counter.value ++ } watch(count, (newValue, oldValue) =&gt; { console.log(`${oldValue}=&gt; ${newValue}`) }) return { count, countUp }; }; };&lt;/script&gt;&lt;!--======= optionAPI =======--&gt;&lt;script&gt; export default { data(){ return { count: 0 }; }, methods: { count(){ this.count++ }; }, watch: { count(newValue, oldValue){ console.log(`${oldValue}=&gt; ${newValue}`); }; }; };&lt;/script&gt;(4) computed&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { ref, computed } from \"vue\" export default { setup(){ const count = ref(0); const twiceTheCount = computed(()=&gt; counter.value ++); // 값에 접근하기 위해서는 value속성에 접근해야 한다. console.log(twiceTheCount.value) return { count, twiceTheCount }; }; };&lt;/script&gt; computed 함수는computed의 첫번째 인자를 전달된 게터와 같은 콜백의 결과에 대한 읽기 전용 반응성 참조를 리턴한다. 새로 생성된 computed 변수의 value에 접근하려면, ref와 마찬가지로 .value 속성을 사용해야 한다. 2) 라이프 사이클 훅 Options API와 비교하여 Composition API 형태를 완벽하게 만들기 위해서, setup 안에 라이프사이클 훅을 등록하는 방법도 필요하다.&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { ref, onMounted } from \"vue\" export default { setup(){ const count = ref(0); const countUp = ()=&gt; { counter.value ++ } onMounted(countUp) // mounted에서 countUp함수 호출 return { count, countUp }; }; };&lt;/script&gt; Composition API의 라이프사이클 훅은 Options API의 라이프사이클 훅의 이름과 동일하지만, 접두사 on이 붙는다. 예) mounted -&gt; onMounted 컴포넌트에 의해 훅이 호출될 때 실행될 콜백함수를 인자로 받는다.📌 Composition API의 라이프 사이클 훅 Options API setup 내부의 훅 beforeCreate 필요하지 않음* created 필요하지 않음* beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted errorCaptured onErrorCaptured renderTracked onRenderTracked renderTriggered onRenderTriggered setup은 beforeCreate, created 라이프사이클 훅 사이에 실행되는 시점이므로, 명시적으로 정의할 필요가 없다.3. TeleportVue는 UI 및 관련 동작을 컴포넌트로 캡슐화하여 UI를 구축하도록 권장한다. 그러나, 논리적으로 컴포넌트에 속하는 템플릿의 일부라도 기술적인 관점에서 보면 Vue 앱 범위를 벗어나 DOM의 다른 곳으로 템플릿의 일부를 옮기는 게 더 바람직할 때도 있다. ex) 모달 창처음 vue로 프로젝트를 시작하면 index.html의 &lt;div id=\"app\"&gt;&lt;/div&gt;태그에 모든 화면을 넣는다.&lt;html&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 이곳에 vue로 만드는 모든 화면이 들어간다. --&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;만약 모달창을 구현하면 현재 보이는 화면을 뚫고 최상위에 올라와야 하는데, 이는 프로젝트가 커질 수록 번거롭다. 그러나 teleport를 활용하면, 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링 할 수 있게 된다.&lt;template&gt; &lt;button @click=\"toggleModal\"&gt; 모달 열기! &lt;/button&gt; &lt;!-- 이 HTML을 \"body\" 태그로 teleport 해라!! --&gt; &lt;teleport to=\"body\"&gt; &lt;div v-if=\"modal\" class=\"modal\"&gt; &lt;button @click=\"toggleModal\"&gt; 모달 닫기! &lt;/button&gt; &lt;/div&gt; &lt;/teleport&gt; &lt;/template&gt;&lt;script&gt; import {ref} from \"vue\"; export default { setup(){ const modal = ref(false); const toggleModal = ()=&gt; { modal.value = !modal.value; }; return { modal, toggleModal } } }&lt;/script&gt;[ modal off ][ modal on ]📖 참고문서공식문서vue teleport 관련 블로그 글 " }, { "title": "컴퓨터구조-디지털-부품", "url": "/posts/computerstructure02/", "categories": "CS, 컴퓨터-구조", "tags": "cs, 컴퓨터-구조", "date": "2022-06-28 00:00:00 +0900", "snippet": "디지털 부품 파트1강의링크1) 집적회로 (Integrated Circuits)(1) 정의 디지털 게이트를 구성하는 전자 부품을 포함하는 실리콘 반도체 칩이다. 칩 내부에 여러가지 소자들이 존재한다. (대부분 우리가 컴퓨터에서 사용하는 칩은 논리게이트가 있는 칩이다.) 즉, 칩 내부에 게이트들이 연결되고 외부로도 핀을 통해 연결된다. 칩의 등록번호로 구분한다. (dataBook을 통하여 정보 확인이 가능하다. )(2) 집적 규모에 따른 분류 IC 내부에 얼마나 많은 디지털 게이트나 전자부품이 몰려있는가에 따라 구분된다. SSL: 소규모, 10개 이하의 게이트들로 구성된다. MSI: 중규모, 10~200개의 게이트들로 구성된다. ex) 디코더, 가산기, 플립플롭, 레지스터 등 LSI: 대규모, 200~1,000개의 게이트들로 프로세서나 메모리 칩과 같은 디지털 시스템을 형성한다. ex) 규모가 작은 칩 VLSI: 초대규모, 수천개 이상의 게이트 집적, 대형 메모리나 마이크로 컴퓨터 칩을 구성한다. ex) CPU(3) 디지털 논리군에 따른 분류 어떤 논리군에 있느냐에 따라 분류가 가능하다. TTL: Tnansister-Transistor Logic 일반 로직 회로 부품 일반적인 게이트 단위로 만들어진 회로 and 혹은 not 게이트인 트랜지스터로 구성 ECL: Emitter-Coupled Logic 고속 논리 시스템용 부품 (1~2ns 이하), 슈퍼 컴퓨터 용 하나의 게이트의 입력부터 출력까지 걸리는 시간(게이트 딜레이) 이 매우 짧다. TTL은 게이트 딜레이가 1ms~2ms인데 ECL은 TTL보다 굉장히 빠르기때문에 고속 논리를 요구하는 컴퓨터에서 사용된다. 하지만 그만큼 비싸다. MOS: Metal Oxide Semiconductor 고밀도 집적회로용 부품 CMOS: Complement Metal Oxide Semiconductor 고밀도 회로, 단순한 제조공정 MOS에 비해 저전력 ex) 베터리 전력 소모에 예민한 핸드폰에 사용된다. 2) 디코더 (Decoders) 컴퓨터에서 가장 많이 사용되는 조합회로이다.(1) 정의 N비트의 이진 정보를 서로 다른 2의 n승개의 원소 정보로 출력한다. 2개의 입력 =&gt; 4가지 (2의 2승) 출력 2X4 decoder 3개의 입력 =&gt; 8가지 (2의 3승) 출력 3X8 decoder 즉, 여러 개의 장치가 있는데 그중에 한개의 장치만 키거나 끄는 기능을 한다. 입력순서와 출력순서는 높은 비트의 입력이나 출력이 먼저다.(2) NAND 게이트로 이루어진 디코더 and게이트로 만들어지는 게이트보다는 nand게이트로 이루어진게 더 경제적이고 사용이 좋다. 즉, 출력 신호가 다 1이고 내가 고른 것만 0이 되는것이 더 경제적이다. (대부분의 출력회로가 1로 유지된다.) 원인: CMOS 회로의 영향때문이다. 신호가 1이 되면 전력을 사용하지 않게 되고 0이 되면 전력을 사용하게 된다.(3) 인코더 디코더와 반대의 개념인 조합회로 디코더와 반대 동작을 수행한다. 2의 N승의 입력에 대하여 N 이진 코드를 출력한다. 한번에 하나의 입력만이 1의 값을 가질 수 있다.3) 멀티플렉서 (Multiplexers)(1) 정의 N개의 선택 입력에 따라서 2의 N승개의 출력을 하나의 출력에 선택적으로 연결한다. 다중 입력 중 하나를 선택하여 출력으로 연결된다. 네트워크 스위치 (전화, LAN, WAN)의 기본 구조 요소이다. 전화: 여러개의 전화기 중 하나를 선택하는 전화기의 교환기 LAN: 여러 ip 의 입력 중 내 ip만 보내주는.. 여러개의 입력중 하나를 고르기 위해 Selector가 존재한다. ex) 만약 입력이 8개면 selector는 3개 (2의 3승 = 8이니까)4) 레지스터 (Registers)(1) 정의 컴퓨터의 기억장치 중에서 가장 빠르고 용량이 적다. (비쌈ㅎ) N비트의 데이터를 저장하는 기능을 가진 반도체 소자로 구성된 단위 논리 집단 N비트 레지스터: N비트의 이진 정보를 저장한다. N개의 플립플롭과 조합회로로 구성된다. 플립플롭은 1bit를 저장 가능하다. 💬 무엇을 저장하는가.. CPU가 요청을 처리하는 데 필요한 데이터 CPU는 계산이 목적이기 때문에, 레지스터는 연산 과정에서 임시로 처리할 데이터를 저장하거나 메모리의 주소를 저장한다.(2) 레지스터의 필요성 CPU의 계산속도 보다 RAM에 데이터를 접근하는 시간이 더 오래 걸린다. CPU가 임시 사용할 수 있는 저장 공간을 만들어서 CPU 효율을 높인다.(3) 기본 레지스터 클럭펄스 타이밍에 입력값이 레지스터에 저장된다. 레지스터에 저장된 값은 항상 출력에서 참조가 가능하다. Clear, Clock 입력을 제공한다.(4) 병렬로드 가능한 4비트 레지스터 4비트의 데이터를 동시에 입력이 가능하다. Load, Clock 입력을 제공한다.디지털 부품 파트 2강의링크1) 시프트 레지스터 (Shift Registers)(1) 정의 레지스터에 저장된 이진 정보를 단방향/ 양방향으로 이동이 가능한 레지스터이다. 클럭, 퍼스가 들어왔을 때 레지스터에 있는 정보를 단방향으로 비트를 이동시킨다. 각 FF들의 입력이 출력과 cascade로 연결된다. 공통의 colck이 다음 상태로의 이동을 제어한다.(2) 병렬로드를 가지는 양방향 시프트 레지스터 (General Register) 병렬로드, 왼쪽 / 오른쪽 시프트, 병렬출력이 가능하다. 동기화된 clock에 의하여 동작한다. 범용 레지스터를 지칭한다.2) 이진 카운터 (Binary Counters)(1) 정의 레지스터의 값이 정해진 순서대로 상태(출력) 변이가 수행되는 레지스터이다. 상태(출력)는 Clock이나 외부 입력에 따라 변이 된다. 용도 사전의 발생 횟수 카운트 동작 순서 제어 타이밍 신호 발생에 적용한다. 컴퓨터는 프로그램 저장 방식이기 때문에 프로그램을 미리 저장해놓고 일정한 순차에 의해 실행한다. =&gt; 카운터 (2) 병렬입력을 가진 이진 카운터 카운터의 초기값을 설정할 수 있다. 병렬 입력을 통하여 초기값을 로드한다. Load, Clear, Increment기능이 있다.3) 메모리 장치 (Memory Unit)(1) 정의 정보의 입출력 기능을 가지는 저장 요소들의 집합 Word 단위로 정보를 저장한다. Word: 입출력에서 하나의 단위로 취급되는 비트의 그룹이다. (한번에 읽고 쓰는) 16bit 컴퓨터: 레지스터/ 메모리 버스의 크기가 16 bit (2byte) =&gt; 데이터를 주고받는 기본단위가 16비트 64bit 컴퓨터: 레지스터/ 메모리 버스의 크기가 64 bit (8byte) =&gt; 데이터를 주고받는 기본단위가 64비트 Byte: 워드의 기본단위(2) RAM (Random Access Memory): 휘발성 메모리 Word의 물리적인 위치에 관계 없이 데이터에 접근할 수 있다. 모든 데이터 위치에 대하여 동일한 접근 시간을 가진다. N비트의 입력 / 출력 (Word 크기와 동일하다) K개의 주소 라인으로 2의 k승개 word 중 하나를 선택한다. (메모리 번지) =&gt; address 읽기 / 쓰기를 지정한다 (R/W)(3) ROM (Read Only Memory): 비 휘발성 메모리 한 번 저장된 데이터를 읽기만 가능하다. 1 word가 N비트이고 M월드를 저장하는 N x M ROM이다. ROM에 저장된 M word를 접근할 수 있는 K개의 주소를 입력한다. (2의 k승 = M )💬 ROM의 종류 Mask ROM: 석판화 (Lithography)방식으로 구워져 나오는 ROM이다. PROM: 한번만 프로그램 가능하다. EPROM : UV에 의한 데이터 삭제 (ROM 초기화) 및 재 프로그래밍 가능하다. EEPROM: 전기 신호에 의한 데이터 삭제/ 초기화 및 재 프로그래밍이 가능하다.💬 ROM의 기능을 하는 RAM: 비휘발성 RAM, 특정한 신호가 있을 때만 write할 수 있다. Flash-RAM BIOS USB memory SD card NV-RAM Non-Volatile RAM Battery Backup RAM : 내장 메모리에 의해 데이터를 홀드하고 있다. " }, { "title": "컴퓨터구조-디지털-논리-회로", "url": "/posts/computerstructure01/", "categories": "CS, 컴퓨터-구조", "tags": "cs, 컴퓨터-구조", "date": "2022-06-20 00:00:00 +0900", "snippet": "디지털 논리 회로 기초 파트 1강의링크1) 디지털 컴퓨터(Digitial Computer)(1) 정의 이진 시스템을(0, 1) 사용하여 계산을 수행하는 디지털 시스템이다. 비트(0과 1의 조합)의 그룹을 사용하여 숫자, 문자 및 기타 정보를 표시하거나 처리한다. (2) 하드웨어 측면에서 본 디지털 컴퓨터 한마디로 컴퓨터는 CPU다. CPU: 중앙 처리장치. 컴퓨터 그 자체로 정의. 산술 논리처리와 데이터의 저장, 제어 기능을 수행한다. 주변장치: 메모리(RAM, ROM), 저장장치, 입출력 장치 (CPU를 보조하는 unit이다.)(3) 컴퓨터 소프트웨어 운영체제: OS 시스템 프로그램: 유틸리티, 데이터베이스, Editor등 OS에 포함되거나 연결되어 시스템 운영을 보조한다. ex) 윈도우, 노트패드 응용 프로그램 ex) msOffice, web2) 논리 게이트(Logic Gates) 디지털 회로를 만들기 위해 정확한 연산과정을 표현하는 논리회로가 필요하다. 연산 과정을 회로로 표현할 때, 논리게이트를 이용한다.컴퓨터에서 이진정보는 0과 1의 전압신호이다. 0: 전압 0v 1: 전압 5v0과 1의 입력신호로 논리식을 만들 수 있고 논리게이트로 대응되는 일련의 기호와 이름으로 표시되는 함수식으로 사용할 수 있다. 또한, 일반적으로 각 게이트는 bool연산 하나를 구현한다. ex) AND게이트, OR게이트, NOT게이트, Buffer게이트, NAND게이트, NOR게이트, XOR게이트, XNOR게이트 등3) 부울 대수(Boolean Algebra)이진 변수와 논리 동작을 취급하는 대수로 기본 대수 동작은 AND, OR, NOT과 같은 기본 게이트를 의미한다.예시F = x + y'z+는 or , *는 and , '는 not의 의미를 갖고 있다. 위의 예시를 해석하면 F = X or (not Y and Z)이다.(1) 부울 대수의 사용 이유 변수 사이의 진리표 관계를 대수적으로 표시한다. 논리도의 입출력 관계를 대수 형식(수학적)으로 표시한다. 같은 기능을 가진 더 간단한 회로를 발견할 수 있다. 어차피 같은 결과를 나타내는 수식이면 식이 간단한게 낫기 때문에, 회로도 마찬가지이다. 부울대수를 사용해서 간략화 시키거나 동치 회로(결과가 같은)를 찾는데 도움을 준다. 💬 부울대수 간략화대수적인 방법으로 리터럴을 줄일 수 있다. 만약, 게이트가 줄어들면 게이트 하나당 드는 비용이 있기에 중요한 개념이다.F = ABC + ABC' + A'C = AB(C+C')+A'C(2) 부울 대수의 기본 관계 항등원, 역원, 교환법칙, 결합법칙, 드모르강의 법칙4) 맵의 간소화 (Karnaugh Map)만약 변수, 항이 많아지면 visulal diagram을 통하여 간소화한다. map diagram Karanaugh map, Veitch diagram Minterm, Maxterm을 이용한 간소화 디지털 논리 회로 기초 파트 2강의링크1) 조합회로 (Combinational Circuit)(1) 정의입력과 출력을 가진 논리 게이트의 집합이다. 출력의 값을 입력의 0, 1의 조합에 의하여 결정되는 함수의 결과로 표시된다. n개의 입력 조합이 있을 경우 들어갈 수 있는 수는 이진수이기 때문에, 가능한 입력 조합은 2의 n승 가지이다.따라서, 입력이나 출력의 개수가 많을수록 다양한 조합을 사용할 수 있다.(2) 조합 회로의 설계 절차 해결할 문제의 제시한다. (입력에 따른 출력을 설계 한다.) 밴딩 머신이라고 가정하면 특정버튼을 누르면 특정 음료수가 나온다. (문제) 입력과 출력의 변수에 문자 기호를 부여한다. 버튼에 라벨링 입력- 출력 관계를 정의하는 진리표를 도출한다. 버튼-음료수 관계를 정의하는 진리표 도출 각 출력에 대한 간소한 부울 함수를 도출한다. 각 음료수에 대한 부울 함수 도출 부울함수에 대한 논리도를 작성한다 논리도를 바탕으로 회로를 구현한다.2) 플립플롭 (Flip-Flop)(1) 정의논리 회로 중에서는 현재 출력의 값을 가지고 다음 입력이 들어오기 전까지 유지를 할 수 있는 특징을 가진 회로이다. 1비트의 디지털 정보를 저장하는 이진 셀 (디지털 메모리) 동기식 순차회로의 기본적인 요소로 사용, 조합회로와 함께 순차회로를 구성한다.**즉, 입력의 상태 변화가 발생하기 전까지는 이전의 출력상태를 그대로 유지한다. **마치 상태를 기억하는 특성을 가지는 것처럼 보이기 때문에 메모리 소자로 사용된다.(1비트의 정보를 보관, 유지할 수 있는 회로로 사용)또한, 올바른 동작을 위해서는 최소의 신호 유지시간이 필요하다. Setup time: 출력 변화를 위하여 입력이 유지되어야 하는 최소 시간 Hold time: 출력 유지를 위하여 입력이 바뀌지 않아야 하는 최소 시간 (2) 모서리 변이형 플립플롬플립플롭은 클럭 펄스에 의해 동기화 되어서 움직이는 회로이다. 클럭기준으로 어디서 트리거 되는지에 따라 종류가 나뉜다. 상향 모서리에서 트리거 되는 플립플롭 (Upward triggered FF): 입력값이 상향일 경우에만 동작한다. ( 0 =&gt; 1) 하양 모서리에서 트리거되는 플립플롭 (Downward triggered FF): 입력값이 하향일 경우에만 동작한다. (1 =&gt; 0)(3) 플리플롭의 종류 SR-플리플롭 D-플리플롭 JK-플리플롭 T-플리플롭3) 순차회로 (Sequential Circuit)(1) 정의플리플롭과 게이트(또는 조합회로)를 서로 연결한 회로로 플립플롭가 마찬가지로 클럭 펄스에 위하여 동기화된 입력 순차에 의하여 제어된다. 조합회로: 입력에 대해서 정해진 출력을 내보냄 플립플롭: 그 전에 입력에 의한 출력을 기억하고 있는 회로 단순하게 두개를 조합한 것이 아니라 플립플롭의 출력이 조합회로의 입력으로 들어간다. 이를 통해 플립플롭의 기억되고 있는 출력값이 조합회로의 인풋으로 들어가기때문에 인풋이 바뀌게 된다. 즉 순차회로의 출력은 외부 입력과 플립플롭의 현 상태 (플립플롭의)출력에 의해 결정되는 함수로 표시된다.(2) 플립플롭의 입력식 FF의 입력을 만들어 내는 조합회로 부분이다.우리가 순차회로를 분석할 때는 플립플롭에 어떠한 입력이 들어가는가. 즉, 플립플롭의 입력식을 만드는 것이 중요하다.만약, 입력식을 만든다면 그걸 부울 수식으로 표현하게 되고 부울 수식에 따라서 우리는 상태 표를 만들고 이에 따라 상태도를 만든다. 입력식 입력식을 부울 수식으로 표현 부울 수식에 따라 상태표를 제작 (State Table) 상태표에 따라 상태도를 제작 (State Diagram)(3) 순차회로 설계 예 상태표, 상태도 작성 순차회로 여기표 작성 플립플롬의 선택과 입력식 도출 회로도 구현" }, { "title": "컴퓨터구조-컴퓨터-구조-개요", "url": "/posts/computerstructure00/", "categories": "CS, 컴퓨터-구조", "tags": "cs, 컴퓨터-구조", "date": "2022-06-20 00:00:00 +0900", "snippet": "컴퓨터의 구조는 어떻게 되어있을까?1. 컴퓨터의 역사‘컴퓨터’의 구조는 어떻게 되어있을까? CPU와 메모리! 안될과학 - 랩미팅 15화1) computer수학을 계산하는 사람2) ENIAC: 프로그래밍이 가능한 최초의 컴퓨터의 등장 (1946)ENIAC은 컴퓨터 사용을 위한 프로그램 (소프트 웨어)가 없기 때문에, 변수를 전선을 직접 손으로 꽂는 방식으로 진행되었다. (물리적 소프트웨어)그 결과, 하나의 연산을 하기 위해서 많은 노동이 필요하다는 크나큰 단점이 있었다.3) 폰노이만: 컴퓨터 구성체계를 잡아준 사람폰노이만 구조ENIAC의 단점을 보완하기 위해 새로운 컴퓨터 구성체계를 제안했다.폰노이만의 컴퓨터 구성체계는 중앙 제어장치(CPU), 메모리, 프로그램 세가지 요소로 구성되어 있다. 더하기, 뺴기와 같은 기능을 담은 소프트웨어가 메모리 안에 내장되어 있고 계산이 필요할 때마다 메모리 안의 프로그램과 데이터를 CPU에 전달하며 계산을 처리한다. 즉, 저장가능한 소프웨어가 있으면, 전기신호를 받아서 CPU는 계산만 하면 된다.폰노이만 구조를 도입하게 되면, 하드웨어는 그대로 두고 소프트웨어만 교체하면 되기 때문에 편의성이 크게 증가하였기 때문에, 현재 거의 모든 컴퓨터가 폰 노이만 구조를 따르고 있다.2. 컴퓨터 구조1) CPU 전기적 스위치로 어떻게 계산을 하는가. (여러 논리들을 전기적으로 표현하는 방법.) 논리 구조를 전기적 스위칭으로 표현을 하고 계산을 한다. CPU 계산에 사용되는 논리회로가 있다. 즉, CPU안에은 논리회로로 가득 차 있다. 여러 논리회로들을 합치면 덧셈이 가능하다. 전기 스위치를 이용해 논리를 만들 수 있다. 즉 , CPU는통해 전기 스위치를 통해 계산을 할 수 있습니다.💬 CPU를 지금과 같은 형태로 만든 사람: Jack Kilby 1958 진공관보다 훨씬 작은 트랜지스터 (반도체 공정으로 만든 작은 스위치) 만약 반도체 공정으로 작은 스위치를 제작할 수 있다면, 그 안에 논리 회로에 들어가는 각종 부품들을 반도체 공정으로 한 번에 만들어 작은 cpu를 제작할 수 있지 않을까. 라는 아이디어에서 시작했다. 즉, 회로를 한곳에 몰아 넣었다. =&gt; 집적회로의 원리 그 결과, 머리카락보다 얇은 전선들이 연결되어 있는 cpu가 탕생하게 되었다.2) RAMCPU만으로 컴퓨터를 사용할 수 없다. CPU의 주요 기능은 Control Unit(계산, 연산)과 Login Unit(정보처리를 위해 명령어를 로직에 넣어줌)으로, 정보를 기억할 수 있는 기능이 없다는 것을 알 수 있다. 일반적으로, 계산을 위해서는 여러 정보가 필요하다. 그래서 이러한 정보를 기억하는 역할을 메모리라고 한다.컴퓨터의 데이터는 0과 1로 이루어져있다. 즉 메모리는 0과 1을 기억하는 장치이다. 그래서 초창기에는 회로적으로 만들어서 하나의 숫자를 기억 하는 장치를 개발했다. 이는 Random Acess Memory라고 불리며, RAM의 시작이다.💬 DRAM1KB의 이미지가 있다. 1KB는 8000개의 숫자를 의미한다. 즉, 8000개의 숫자를 기억하는 메모리가 필요하게 된다.이렇게 점점 많은 용량의 데이터가 사용하게 되고 점점 회로의 크기는 커질 수 밖에 없다.이를 줄이기 위해 DRAM이 등장했다. DRAM은 훨씬 작은 부품으로 숫자 하나를 기억할 수 있게 제작되었고, 더 많은 기억을 할 수 있게 되었다.그런데, 속도가 느리다는 치명적인 단점이 있기 때문에 RAM과 DRAM을 혼용하여 사용한다.작게 기억하지만 빠른 RAM은 캐시메모리라는 이름으로 CPU에 내장되어있다. 많은 것을 기억하는 DRAM에서 지금 당장 계산할 것을 뽑아서 CPU안에 있는 캐시메모리에 넣는다.3) HDD / SDDRAM 메모리는 전원이 꺼지만 모두 소멸된다. 그래서 영구적인 기억장치 역할을 하는 HDD가 등장하게 되었다.💬 클럭CPU에 정보를 전달하는 과정은 아래와 같다. HDD (속도가 1000배 느림) =&gt; DRAM (속도가 10배 느림) =&gt; CPU 내부 RAM (속도가장 빠름)즉, CPU는 기억을 꺼내고 계산하고 다시 기억을 넣는다.이와 같은 한싸이클을 클럭이라고 부르며 초당 몇번 하는가에 따라 CPU의 성능이 나뉜다.3. 컴퓨터 구조와 운영체제의 관계컴퓨터구조 운영체제 클라우드 안쉬고 처음부터 끝까지 30분동안 설명하기. 컴퓨터-구조 처음 공부하실 때 참고하세요.컴퓨터 구조는 앞서 보았던 cpu, memory 등 물리적인 요소들 자체를 공부하는 것이다.그리고 이러한 물리적인 동작과 관련된 부분들과 맞물려서 돌아가는 것들이 운영체제이다. 컴퓨터 구조: 하드웨어가 어떻게 동작되는가. 운영 체제: 하드웨어가 동작되는 흐름을 제어하고 무엇부처 처리해야 하는 지 잡아주는 등 전체적으로 운영하도록 해준다.결국, 컴퓨터는 운영체제 위에서 실행된다.예시HDD에 저장된 프로그램 파일(프로세스)가 있다. 해당 프로세스가 실행되기 위해 메모리(DRAM)으로 올라온다. 그리고 마지막으로 CPU의 캐시메모리로 이동하게 되고 CPU(프로세서)는 캐시메모리에 접근하여 프로그램을 실행한다.여기서 운영체제는 위의 흐름에 관여를 한다. 어떤 데이터를 올리는가 지금 DRAM에 자리가 없는데, 어떤 녀석들을 먼저 내보내야 하는가 등등이렇게 여러개의 프로세스들을 동시에 실행하고, 운영을 하는 데 도움을 주는 것이 운영체제이다. 그래서 운영체제는 하드웨어들을 어떻게 잘 운영하게 하는 지가 중요하다." }, { "title": "22/06/20/월 CS 강의", "url": "/posts/220620til/", "categories": "TIL/2022, 06", "tags": "til, cs", "date": "2022-06-20 00:00:00 +0900", "snippet": "220620 Today I learned! CS 강의1. Fact1) CS 강의 컴퓨터-구조-개요 컴퓨터의 구조는 어떻게 되어있을까? 컴퓨터 역사 폰노이만의 컴퓨터 구조 (CPU, 메모리) 컴퓨터 구조와 운영체제 디지털-논리-회로 디지털 컴퓨터 논리게이트 , 부울대수, 카르노맵 조합회로, 순차회로 (조합회로 + 플립플롭) 2. Feeling🙄………………….컴퓨터 구조까지는 재미있게 들었는데, 논리 회로가 나오면서 몰루 상태가 되었다.뇌로는 대충 이해가 되는데, 이게 어떻게 사용되는 지 감이 안잡히는 내용들이였다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/17/금 Jenkins + docker를 활용한 CI/CD 구축 실습, FE 스터디", "url": "/posts/220622til/", "categories": "TIL/2022, 06", "tags": "til, jenkins, docker", "date": "2022-06-17 00:00:00 +0900", "snippet": "220616 Today I learned! CSS 강의 CS 스터디1. Fact1) Jenkins + docker를 활용한 CI/CD 구축 실습 Jenkins와 docker를 활용하여 gitlab에 있는 레파지토리 배포하기2) FE 스터디 한 주간 학습한 내용 공유2. Feelingnull;3. Finding Jenkins + docker 실습 과정(1) Docker 설치한다.https://docs.docker.com/get-docker/(2) Docker로 Jenkins를 설치한다.docker run -d -p 9090:8080 -p 50000:50000 -v /var/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock --name jenkins -u root jenkins/jenkins:lts-jdk11 설치 후, http://localhost:9090/ 접속한다. docker logs jenkins명령어로 비밀번호를 확인하여 접속한다.(3) Jenkins 컨테이너 내부에 도커를 설치한다.# 컨테이너 내부에 접근한다.docker exec -it jenkins bash# docker를 설치한다. curl https://get.docker.com/ &gt; dockerinstall &amp;&amp; chmod 777 dockerinstall &amp;&amp; ./dockerinstall# 설치를 확인한다. docker --version(4) 도커라이징 New Item 클릭하여 프로젝트를 생성한다. 타입: 프리스타일로 선택한다. repositoty URL에 배포할 git repository주소를 기입한다. credentials에 username(깃 아이디), password(깃 비밀번호), id(임의 값)을 입력하여 생성한다. Build when a change is pushed to GitLab. GitLab webhook URL을 체크하여 새로운 푸시가 들어오면 자동으로 빌드가 되게 한다. Excute shell을 선택하여 다음의 스크립트를 입력후 저장한다. docker build -t hello_ssafy:latest .docker run -d -p 80:80 hello_ssafy (5) 빌드, 배포Build Now를 클릭하여 배포한다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/21/금 CS스터디 발표 자료 준비", "url": "/posts/220621til/", "categories": "TIL/2022, 06", "tags": "til, cs", "date": "2022-06-17 00:00:00 +0900", "snippet": "220621 Today I learned! CS 스터디 발표자료 준비1. Fact1) CS 스터디 발표자료 준비 발표 주제: 폰노이만의 컴퓨터 구조 발표 목표: 컴퓨터 구조를 전반적으로 이해함으로서 컴퓨터의 작업 플로우를 이해한다. 발표자료2. Feeling전자회로, 논리회로 분야는 너무 생소하기 때문에 설명이 어렵다 생각해서 먼저 주제를 선점했다..3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/17/금 Jenkins + docker를 활용한 CI/CD 구축 실습, FE 스터디", "url": "/posts/220617til/", "categories": "TIL/2022, 06", "tags": "til, jenkins, docker", "date": "2022-06-17 00:00:00 +0900", "snippet": "220616 Today I learned! Jenkins + docker를 활용한 CI/CD 구축 실습 FE 스터디1. Fact1) Jenkins + docker를 활용한 CI/CD 구축 실습 Jenkins와 docker를 활용하여 gitlab에 있는 레파지토리 배포하기2) FE 스터디 한 주간 학습한 내용 공유2. Feelingnull;3. Finding Jenkins + docker 실습 과정(1) Docker 설치한다.https://docs.docker.com/get-docker/(2) Docker로 Jenkins를 설치한다.docker run -d -p 9090:8080 -p 50000:50000 -v /var/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock --name jenkins -u root jenkins/jenkins:lts-jdk11 설치 후, http://localhost:9090/ 접속한다. docker logs jenkins명령어로 비밀번호를 확인하여 접속한다.(3) Jenkins 컨테이너 내부에 도커를 설치한다.# 컨테이너 내부에 접근한다.docker exec -it jenkins bash# docker를 설치한다. curl https://get.docker.com/ &gt; dockerinstall &amp;&amp; chmod 777 dockerinstall &amp;&amp; ./dockerinstall# 설치를 확인한다. docker --version(4) 도커라이징 New Item 클릭하여 프로젝트를 생성한다. 타입: 프리스타일로 선택한다. repositoty URL에 배포할 git repository주소를 기입한다. credentials에 username(깃 아이디), password(깃 비밀번호), id(임의 값)을 입력하여 생성한다. Build when a change is pushed to GitLab. GitLab webhook URL을 체크하여 새로운 푸시가 들어오면 자동으로 빌드가 되게 한다. Excute shell을 선택하여 다음의 스크립트를 입력후 저장한다. docker build -t hello_ssafy:latest .docker run -d -p 80:80 hello_ssafy (5) 빌드, 배포Build Now를 클릭하여 배포한다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/16/목 Express와 socket.io를 활용하여 채팅 서비스 구현, Jenkins + docker를 활용한 CI/CD 구축", "url": "/posts/220616til/", "categories": "TIL/2022, 06", "tags": "til, express, node.js, socket.io, jenkins, docker", "date": "2022-06-16 00:00:00 +0900", "snippet": "220616 Today I learned! Express와 socket.io를 활용하여 채팅 서비스 구현 CI/CD 환경의 이해1. Fact1) Express와 socket.io를 활용하여 채팅 서비스 구현 Express.js: http와 connect 컴포넌트 기반으로 서버를 쉽게 만들기 위해 사용된다. socket.io: 클라이언트 - 서버간 양방향 통신이 가능하게 하여 실시간 웹 애플리케이션을 위한 라이브러리 이다. Websocket을 기반으로 실시간 웹 애플리케이션을 위한 자바스크립트 라이브러리이다. 클라이언트와 서버 간의 실시간 양방향 통신을 가능하게 해준다. 이벤트기반으로 서버 소켓과 클라이언트 소켓을 연결하여서 실시간으로 양방향 통신이 가능하게 한다. 결과물과 README2) Jenkins + docker를 활용한 CI/CD 구축 Jenkins로 CICD 환경을 구축하여 프로젝트 배포를 지속적으로 쉽게 할 수 있다.예전에 기업 it팀은 개발팀과 운영팀으로 분리되어 있었다. 둘의 협업 프로세스가 굉장히 비효율적이였다.그러나, 이제 CI/CD개념이 나오면서 개발자들도 편하게 배포를 할 수 있게 되었다. 개발 개발 브런치로 push한다. master브런치로 MR 한다. master 브런치의 push를 감지하여 Jenkins 서버에 트리거를 알려준다. Jenkins에서 빌드 한뒤, 명령어에 의해 도커라이징(컨테이너화) 배포2. Feeling채팅 서비스를 구현하는 것이 재밌어서, 특강이 끝나고 계속 혼자 진행했다.서버 구현을 하고 클라이언트 화면을 구성하는 데 생각보다 많은 시간이 들었지만,, 🥺3. Finding socket.io server 구현 활용법공식문서Socket.IO is a library that enables low-latency, bidirectional and event-based communication between a client and a server.(1) socket.io 객체 생성 및 구동// server.jsconst express = require(\"express\");const { createServer } = require(\"http\");const { Server } = require(\"socket.io\");const app = express();// 서버 생성const httpServer = createServer(app);const io = new Server(httpServer, );// 서버를 socket.io에 바인딩한다.const httpServer = createServer();(2) 클라이언트와 소통// server.jsio.sockets.on('connection', function(socket){ // 유저 메시지 전달 socket.on('send', function(data){ // 받은 데이터에 누가 보냈는 지 이름을 추가한다. data.name = socket.name // 보낸 사람을 제외한 나머지 유저에게 메시지를 전송한다. socket.broadcast.emit(\"update\", data) }); // 접속 종료 socket.on('disconnect', function(data){ // 이름이 없으면, 로그인을 하지 않은 것이기 때문에 종료 메시지를 보내지 않는다. if (socket.name === undefined) {return} console.log(socket.name + \"님이 나가셨습니다.\") // 나가는 사람을 제외한 나머지 유저에게 메시지를 전송한다. socket.broadcast.emit(\"update\", {type: \"disconnect\", name: \"SERVER\", message: `${socket.name}님이 나가셨습니다.`}) });}); emit(전송)과 on(수신)을 통해 소통한다. io.socket: 전체 소켓 / socket: 접속된 소켓 (콜백함수에 의해 전달되었음) / socket.broadcast: 나를 제외한 소켓4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/16/수 CS 스터디", "url": "/posts/220615til/", "categories": "TIL/2022, 06", "tags": "til, cs", "date": "2022-06-16 00:00:00 +0900", "snippet": "220615 Today I learned! cs스터디1. Fact1) CS 스터디스터지 깃허브 패킷 네트워크 개요 / TCP VS UDP 회선교환 회선교환: 송신자와 수신자를 연결하는 회선을 독점한다. 한번 열결이 이루어지면 둘 사이에 안정적으로 송신을 할 수 있다. 그러나, 선을 독점하기 때문에 자원이 많이 필요하다. 인터넷 통신은 많은 사람들이 많은 정보를 주고 받고 정보를 주고 받지 않는 상황도 있기 때문에 회선 교환 방식이 굉장히 효율성이 떨어지는 방식이다. 그 결과, 패킷 네트워크를 사용하게 되었다. 패킷네트워크 데이터를 보내기 위한 경로배정을 효율적으로 하기 위해 데이터를 여러 조각으로 나누어(패킷) 보낸다. 큰 데이터는 대역폭을 너무 많이 차지하기 때문에 해당 대역폭을 이용할 수 있는 사용자의 수가 줄어들어 데이터의 흐름이 원활하게 하지 못해 트래픽이 증가하기때문에 패킷으로 나눈다. 패킷을 주고받는 노드들은 독점되지 않는다. TCP와 UDP: 전송된 패킷의 유실이 있는지 등을 추적하고 관리하는 프로토콜이다. TCP: 양방향 통신으로 인해 오류 제어가 쉽다. 송수신 버퍼로 흐름제어와 오류제어를 한다. 속도가 느리다는 단점이있다. UDP: 단방향 통신으로 오류제어가 어렵다. 그러나, 속도가 빠르다. 운영체제와 컴퓨터 운영체제 정의 컴퓨터 하드웨어를 동작하기 위해 필요한 소프트웨어 즉, 하드웨어와 사람을 연결해준다. 유저모드와 커널모드 유저모드: 실제로 사람이 작업을 하는 공간으로 프로그램의 자원에 접근하지 못한다. 커널모드: 프로그램 수행에 필요한 여러가지 서비스를 제공 (보안, 자원관리, 추상화) 실제로 사람이 작업을 할때 메모리나 CPU에 계산 작업을 넘기는 데, 이걸 시스템 콜을 통해 커널모드로 넘겨 컴퓨터 자원을 사용하여 계산작업을 한다. NoSQL: 비관계형 DB SQL과 달리 스키마, 관계가 없다. 즉, 유연하다. 언제든지 저장된 데이터를 조정하고 필드를 추가할 수 있다. SQL과 달리 데이터 무결성을 보장하지 않는다. 수평적확장이 가능하다. 서버가 추가되고 데이터베이스가 전체적으로 분산될 수있다. 여러 호스트를 가질 수 있다. 막대한 양의 데이터를 다룰 때 사용된다. 사용 예시 정확한 데이터 구조를 알 수 없거나 변경 / 확장 되는 경우 read는 자주하지만 update를 많이 하지 않는 경우 데이터 베이스를 수평으로 확장해야 하는 경우 2. Feeling7월 11일부터 대면으로 수업이 진행된다.는 소식을 들은 날이다. 😢😢😢😢😢😢😢😢😢그래서 오늘은 에라 모르겠다하고 쉬어갔다.첫번째 CS 스터디 발표 일이다. 스터디원들의 발표는 꽤나 재미있었고 생각했던 것보다 더~ 유익했던 시간이였다.그런데, 스터디 방향은 다음주부터 바뀔 것 같다.현재는 원하는 발표 키워드를 정해 자율적으로 발표를 진행하고 있는데, 다음주 부터는 다음과 같은 방식으로 진행될 것 같다.CS 스터디 가이드를 기반으로 강의를 듣고 추가적으로 공부한 사항을 발표를 통해 지식공유를 하는 형식이다.현재 정말 CS에 대한 지식이 미비하기 때문에, 체계적인 학습이 필요할 것으로 판단되어 같이 팀원들과 의논한 결과, 스터디 진행 방식을 수정했다.다음주 발표는 나니까.. 오늘부터 CS 강의 열심히 들어야겠다. 😉3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/14/화 DB 설계, 애플 웹사이트 인터랙션 클론 강의, Vue 데이터 전송 실습, 공통 프로젝트 첫번째 팀 회의", "url": "/posts/220614til/", "categories": "TIL/2022, 06", "tags": "til, erd, css, javascript, vue, project", "date": "2022-06-14 00:00:00 +0900", "snippet": "220614 Today I learned! DB 설계, 실습 Mysql/ MariaDB 데이터 프로세스 애플 웹사이트 인터랙션 클론 강의 듣기 Vue 데이터 전송 연습 공통 프로젝트 첫번째 팀 회의1. Fact1) DB 설계 효율적으로 DataBase를 관리하기 위해 DB 설계는 중요하다.효율성 파급효과: 시스템 구축에는 수많은 과정이 동반된다. 초반에 설계한 것을 수정하려고 하면 파급효과(SideEffect)가 크다. DB 스키마를 성능QA에서 문제가 생겨 수정하게된다면, 파국이다. 간결함: 데이터 모델은 시스템의 요구사항과 한계를 가장 명확하게 표현하는 도구이다. 데이터 모델을 통해 많은 관련자들이 동일하게 이해하고 작업을 진행한다. (설계도면) 실습 서비스의 완성도에 지대한 영향을 미치는 DataBase 설계 ERD(Entity Relationship Diagram) Index: 추가적인 쓰기 작업과 저장공간을 활용하여 데이터 베이스 테이블의 검색 속도를 향상 시키기 위한 자료 구조 관련 블로그 설계문서를 토대로 SQL을 작성하여, 효율적인 구현에 필요한 설계방법에 대한 고민 SQL 작성 시, 인덱스를 설계하여 full scan을 피하도록 한다. 2) Mysql/ MariaDB 데이터 프로세스 DB에 직접 데이터를 넣어보고 가공을 하자. 데이터 이행: 실제 데이터를 운영 DB에 반영하는 작업 대량 데이터의 경우, 오픈 후에는 증분(신규/ 수정/ 삭제) 데이터만 반영한다. (스케줄 또는 API 연계등) 데이터 적재 시점 서버 Down 타임에 적재 (운영서버가 다른 DB 서버로 교체 불가인 경우) 사전 적재 (신규 서버 도입인 경우 미리 적재가 가능하다.) 서비스 오픈 후 적재 (내부 오픈 등으로 외부 오픈일이 따로 있는 경우, 운영자가 따로 정해진 시간에 적재한다.) 데이터 적재 방법 DB 백업본 restore(특정 시점 이전까지의 데이터 dump) 사용하여, 데이터 이관 후 오픈 시점까지의 증분 데이터는 소급 반영 텍스트 데이터 이관 DB TO DB 마이그레이션 (DB 또는 솔루션 사용) 정제된 텍스트 데이터를 DB에 직접 인서트 데이터 제공자 측에서 제공하는 Restful API를 호출하여 데이터 인서트 (주로 증분 데이터에만 사용) etc.. 3) 애플 웹사이트 인터랙션 클론 강의 듣기 섹션4: 동적 위치와 크기 계산을 이용한 스크롤 인터랙션 구현 스크롤 애니메이션이 시작되고 끝나는 타이밍을 계산한다. 먼저 해당 섹션 기준 캔버스의 y좌표를 찾는다. (offsetTop) 현재 캔버스는 tranfrom: scale로 크기가 조정되어 있는 상태이기 때문에 이를 고려하여 계산한다. 정리본4) Vue 데이터 전송 같은 기능을 세가지의 방법으로 구현해 보기. container컴포넌트(부모) &gt; 버튼 컴포넌트(자식1), 결과 컴포넌트(자식2)버튼 컴포넌트(자식1)를 누르면 결과 컴포넌트(자식2)에 어떤 버튼을 클릭했는지 표시를 한다. EvnetBus(props, emit)을 활용해 componenet간 데이터를 전송 EventBus(global)을 활용해 component간 데이터를 전송: Vue 객체 활용 Vuex를 활용한 데이터 전송: 중앙 집중소 방식5) 공통 프로젝트 팀회의 2학기 공톡 프로젝트 첫번째 팀 회의 🎉 팀 미션 공유 팀 규칙 구체화팀 노션 페이지2. Feeling프로젝트팀원들과의 첫번째 팀회의! 믿고 같이 할 수 있는 감자님(프엔스터디 팀장)이 있어서 좋다. 😆프엔 3명(비전공자), 백엔드 3명(전공자반)로 이루어진 팀으로 같은 목적을 갖고 개발을 할 것 같다.바로, 사용자에게 필요한서비스 만들기.내 개인적인 욕심으로는 배포 이후에 구글 애널리틱스와 같은 유저 행동 트래킹툴을 설치하고, SNS 광고를 돌려 유저들의 action까지 보고 싶은 욕심이 있다. 😉그래서 많은 고민이 든다. 사용자에게 필요한 서비스를 생각하는 과정이 힘들 것 같다. 어떻게 그들의 경험을 개선하고 개발을 해야 할지 , 많은 이야기를 나누어봐야할 것 같다.또한, Vue 데이터 전송 과제를 하면서 잊고있던 vuex의 소중함을 느꼈다. Vue-devtools 때문에, 상태 추적이 용이하다. 데이터 흐름을 파악하기 쉽다.(+) EventBus 객체를 생성하여 데이터를 전송하는 것은 처음 구현해보았다. 그래도 vuex 최고..3. Finding Vue 객체를 활용한 컴포넌트간 데이터 전송 (이벤트 버스 활용법)참고한 블로그 이벤트 버스 초기화// src/utils/event-bus.jsimport Vue from \"vue\";export const EventBus = new Vue();이벤트 버스는 데이터를 저장하는 제 3의 공간으로 생각하면 된다.부모 / 자식간의 이벤트 통신을 하는 방법과 달리 컴포넌트에서 EventBus를import하여 데이터를 저장하기 때문에 더 간편하게 통신을 할 수 있다. 이벤트 버스 발행&lt;!--src/components/TheButtonGlobal--&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=\"clickOButton\"&gt;O&lt;/button&gt; &lt;button @click=\"clickXButton\"&gt;X&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import EventBus from \"@/utils/EventBus.js\"export default { name: \"TheButtonGlobal\", methods: { clickOButton(){ EventBus.$emit(\"click-o-button\"); }, clickXButton(){ EventBus.$emit(\"click-x-button\"); } }}&lt;/script&gt;EventBus를 import한 뒤, $emit을 통해 이벤트를 발행한다. 이벤트 구독&lt;!--src/components/TheResultGlobal--&gt;&lt;template&gt;&lt;div&gt; &lt;h1&gt;EventBus&lt;/h1&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import EventBus from \"@/utils/event-bus.js\"export default { name: \"TheResultGlobal\", data : function(){ return { buttonData: \"Wait\" } }, created(){ EventBus.$on(\"click-o-button\", ()=&gt; { this.buttonData = \"O\" }), EventBus.$on(\"click-x-button\", ()=&gt; { this.buttonData = \"X\" }) }}&lt;/script&gt;EventBus를 import한 뒤, $on을 통해 이벤트를 구독한다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/12/일 애플 웹사이트 인터랙션 클론", "url": "/posts/220612til/", "categories": "TIL/2022, 06", "tags": "til, css, javascript", "date": "2022-06-11 00:00:00 +0900", "snippet": "220612 Today I learned! 애플 웹사이트 인터랙션 클론 강의 듣기1. Fact(1) 애플 웹사이트 인터랙션 클론 섹션3: 고해상도 비디오 인터렉션 비디오로 처리하기 scroll할 경우, videoElem.curretTime을 통해 현재 재생시간을 조절하여 애니메이션 효과를 낸다. 이미지로 처리하기 이미지 객체를 생성하여 이미지들을 배열에 저장한다. scroll할 경우, imgElem.src를 통해 현재 스크롤에 맞는 이미지를 보여준다. (배열에 있는 인덱스 활용) Canvas로 처리하기 이미지 객체를 생성하여 이미지들을 배열에 저장한다. 캔버스를 브라우저 창에 맞춘다. (Height를 꽉채워서 보여준다.) load되었을 때, 캔버스에 첫번째 이미지를 그린다. scroll할 경우, canvasElem.getContext('2d').drawImage를 통해 캔버스에 이미지를 그린다. (배열에 있는 인덱스를 활용) 섹션4: 동적 위치와 크기 계산을 이용한 스크롤 인터랙션 구현 실제 브라우저 비율과 캔버스의 비율이 달라서 캔버스 사이즈를 억지로 fit시킨다. 좌우 흰색 영역의 위치, 크기를 잡는다. 캔버스 사이즈가 조정되어 있기 때문에, 새로운 캔버스 사이즈를 구한다. 정리본2. Feeling오차 없는 스크롤 액션을 만들려면, 많은 것을 고려하고 계산을 해야 한다는 것을 새삼 느꼈다. 😅스크롤 계산 어렵다.. 어려워.. 정리를 하기 위해 오랜만에 아이패드를 꺼냈다.3. Finding **자바스크립트: image객체 **공식문서new Image();new Image(width);new Image(width, height);var myImage = new Image(100, 200);myImage.src = 'picture.jpg';document.body.appendChild(myImage); // &lt;img width=\"100\" height=\"200\" src=\"picture.jpg\"&gt;이미지태그를 JS로 생성하기 위해 Image()객체를 사용할 수 있다. Canvas API 기초공식문서 / 공식 튜토리얼&lt;canvas&gt;는 HTML 요소 중 하나로, 스크립트를 사용하여 그림을 그리는 데에 사용된다.&lt;canvas id=\"tutorial\" width=\"150\" height=\"150\"&gt;&lt;/canvas&gt; width 및 height 속성을 지정하지 않으면 캔버스의 처음 너비는 300 픽셀이고 높이는 150 픽셀이다. 고정 크기의 드로잉 영역을 생성하고 하나 이상의 렌더링 컨텍스트(rendering contexts)를 노출하여, 풀력할 컨텐츠를 생성하고 다루게 된다.const canvas = document.getElementById('tutorial');const ctx = canvas.getContext('2d');ctx.fillStyle = 'green';ctx.fillRect(10, 10, 150, 100); getContext(type): 렌더링될 그리기 대상을 가져온다. element.fillStyle: 형 내부에 사용할 색상, 그라디언트 또는 패턴을 지정합니다. 기본 스타일은 (검정색)이다. fillRect(x, y, width, height): 시작점이 (x, y)이고 크기가 및 로 지정되는 width채워진 사각형을 그린다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/11/토 애플 웹사이트 인터랙션 클론", "url": "/posts/220611til/", "categories": "TIL/2022, 06", "tags": "til, css, javascript", "date": "2022-06-11 00:00:00 +0900", "snippet": "220611 Today I learned! 애플 웹사이트 인터랙션 클론 강의 듣기1. Fact(1) 애플 웹사이트 인터랙션 클론 섹션2: 스크롤을 이용한 인터랙션 구현 스크롤 섹션 데이터를 객체를 활용하여 저장한다. setLayOut(): scroll-section의 높이를 세팅한다. (load, resize 이벤트와 bind) scrollLoop(): 현재 활성화된 scroll-section이 어디인지 확인한다. (scroll이벤트와 bind, setLayOut()수정) playAnimation(): 현재 활성화된 scroll-section에 맞는 애니메이션을 구현한다. (scrollLoop()함수에서 호출한다.) calcValues(): 애니메이션을 구현하기 위한 값을 계산한다. (playAnimation()함수에서 호출한다.) 정리본2. Feeling방학을 만끽하고 있다.. 😅 어제, 오늘 저녁까지 계속 일정이 있어서 기존에 계획했던 것처럼 이번주에 강의를 다 듣기는 힘들 것 같다. 다음주 화요일까진 꼭..!현재까지 강의는 들을만 하다. 스크롤을 계산하는 다양한 방법을 알 수 있어서 좋았다.그 외에도, 객체에 데이터를 저장하여 어떻게 활용할 수 있는 지에 대해서도 알 수 있었다. :thumbsup:JS에 대한 문법에 대해서는 어느정도 알지만 코딩을 할 때, 어떻게 활용해야 하는 지 잘 모르는 감이 있었는데 이를 배울 수 있는 점이 좋다.3. Finding정리본4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/09/목 예제 복습, 애플 웹사이트 인터랙션 클론", "url": "/posts/220609til/", "categories": "TIL/2022, 06", "tags": "til, css, javascript", "date": "2022-06-08 00:00:00 +0900", "snippet": "220609 Today I learned! 인터랙티브 웹 개발 제대로 시작하기 예제 복습 애플 웹사이트 인터랙션 클론 강의 듣기1. Fact(1) 인터랙티브 웹 개발 제대로 시작하기 예제 복습 종합예제를 혼자 만들어 보면서, 학습했던 내용을 복습 (전진! 3D 스크롤) 스크롤을 하면 캐릭터가 이동하는 듯한 모습을 보인다. 배경의 z-index 값을 수정하여 배경이 움직이는 듯한 효과를 준다. 팔과 다리의rotate 값을 수정하여, 캐릭터가 걷는 듯한 모션을 보여준다. 마우스를 움직이면, 사용자가 보는 시야가 움직인다. 사용자의 마우스의 위치에 따라 배경이 rotate한다. 마우스를 클릭하면, 해당 x좌표에 캐릭터가 생성된다. 객체 생성자 함수를 통해 캐릭터 컴포넌트를 생성한다. 사용자가 클릭한 마우스의 x좌표를 컴포넌트의 스타일 속성의left값으로 주어 배치한다. 방향키를 누르면 캐릭터가 이동한다. 방향키를 누르면 캐릭터가 방향키에 맞는 방향으로 회전하고 움직이는 듯한 모션을 보여준다. 캐릭터의 left 값을 수정하여 캐릭터를 이동시킨다. 정리본 (2) 애플 웹사이트 인터랙션 클론 섹션0 ~ 섹션1 기초적인 html, css 구조 생성 정리본2. Feelingnull;3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/08/수 인터렉티브 웹 개발 제대로 시작하기 완강", "url": "/posts/220608til/", "categories": "TIL/2022, 06", "tags": "til, css, javascript, 짤막회고", "date": "2022-06-08 00:00:00 +0900", "snippet": "220608 Today I learned! 인터랙티브 웹 개발 제대로 시작하기1. Fact(1) 인터랙티브 웹 개발 제대로 시작하기 섹션 11 : 완강!! 마지막으로 하나의 예제를 같이 만들며, 그동안 학습한 내용을 복습 정리본2. Feeling22/06/06 ~ 22/06/08일 동안 인터렉티브 웹 개발 제대로 시작하기라는 강의를 들었다.3일에 거쳐 빠르게 강의를 들었고, 생각 보다 많은 지식을 배울 수 있었다.특히, 바닐라 자스로 실제 웹사이트를 구성하는 방법에 대해 많이 배울 수 있었던 것 같다.이전에 배웠던 것들은 JS 기초적인 문법에 가까웠다면 실제 웹사이트를 구현할 때 어떻게 코딩해야 하는 가를 알 수 있었다.대표적으로 이벤트 위임을 통해 이벤트를 좀 더 손 쉽게 다룬다. JS 객체의 생성자 함수를 통해 컴포넌트를 생성한다. (특히 prototype에 init함수를 실제로 만든 것이 신기했다.) 인터렉티브 웹사이트를 만들기 위한 다양한 이벤트와 default 속성들..물론, transform, transition, animation과 같은 새로운 CSS 속성을 배울 수 있었지만 위에서 언급한 내용들이 나에게 더 많은 배움을 준 것같다.하지만, 현재 내가 배운 지식들이 진짜 나의 지식이 되었는 지는 모르겠다. 이번에 배운 내용들만으로 새로운 프로젝트를 하는 것도 의미가 있겠지만, 해야 할 것이 많기 때문에 마지막으로 했던 예제를 혼자서 해보는 것으로 복습을 끝낼 것 같다.어차피 다른 프로젝트에서 활용할 수 있는 기능들이기때문에 다른 프로젝트를 하면서 다시 복기하면 될 것 같다. 😏3. Finding data 속성 활용하기공식문서HTML요소의 data-로 시작하는 속성으로 자바스크립트의 SetAttribute, GetAttribute와 CSS 선택자를 통해 다양한 기능을 구현할 수 있다.구현 예시왼쪽 방향키를 누르면 element가 왼쪽으로 회전하고 오른쪽 방향키를 누르면 element가 오른쪽으로 회전하는 기능을 구현한다면, CSS data-direction 속성이 left면 왼쪽으로 회전시킨다. data-direction 속성이 right면 오른쪽으로 회전시킨다. JS 왼쪽 방향키를 클릭하면 data-direction 속성에 left 값을 준다. 오른쪽 방향키를 클릭하면 data-direction 속성에 right 값을 준다. .character[data-direction=\"left\"] { transform: rotateY(-90deg);}.character[data-direction=\"right\"] { transform: rotateY(90deg);}window.addEventListener(\"keydown\", function(event){ if (event.keyCode == 37) { //왼쪽 this.element.setAttribute(\"data-direction\", \"left\"); } else if (event.keyCode == 39) { // 오른쪽 this.element.setAttribute(\"data-direction\", \"right\"); }});4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/07/화 인터렉티브 웹 개발 제대로 시작하기", "url": "/posts/220607til/", "categories": "TIL/2022, 06", "tags": "til, css, javascript", "date": "2022-06-07 00:00:00 +0900", "snippet": "220607 Today I learned! 인터랙티브 웹 개발 제대로 시작하기1. Fact(1) 인터랙티브 웹 개발 제대로 시작하기 섹션 06 ~ 섹션 10 JS 기초 객체, 스크롤 이벤트, transition이벤트, animation이벤트 setTimeout, setInterval, requestAnimationFrame 정리본2. FeelingJS는 그래도 어느정도 활용하는 방법을 알고 있다고 생각했는데, 아니였구나 싶다. 🤔실제로 바닐라 JS로 웹개발하는 방식에 대해 고민을 해봐야겠다. 바닐라JS로 간단한 크롬앱을 만들어 보기는 했지만, 이로는 많이 부족한 것 같다.지난번에 리액트로 간단하게 만들었던 와자뵤를 develope하고 싶은 마음이 있었는데 이를 바닐라JS로 실행해보고 싶은 욕구가 생겼다. (그런데 SPA로 어떻게 만들지..)3. Finding Javscript 객체의 생성자 함수를 활용하여 html 태그로 생성하기자바스크립트 생성한 객체를 생성자 함수를 활용하여 바로, html 태그로 추가할 수 있다.여기서 prototype은 객체에 공통으로 적용되는 메서드를 메모리 낭비없이 저장하기 위해 해당 생성자 함수로 생성된 객체가 공통으로 가지는 속성, 메서드를 정의하는 공간이다. (prototype도 객체다!)아래처럼 객체가 생성 될 때, 이를 태그로 생성하여 DOM트리에 추가하는 함수를 실행시켜 바로 브라우저에 보일 수 있다. 😮function Card(num, color) { this.num = num; this.color = color; this.init();}// 아예 prototype 객체를 다시 만들 때는 constructor 속성을 넣어주어야 한다.Card.prototype = { constructor: Card, init: function () { const mainElem = document.createElement(\"div\"); mainElem.style.color = this.color; mainElem.innerText = this.num; mainElem.classList.add(\"card\"); document.body.appendChild(mainElem); },};const card1 = new Card(1, \"green\");const card2 = new Card(7, \"blue\");4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   와자뵤! 다시 만들기 notStarted🌙   " }, { "title": "22/06/06/월 인터렉티브 웹 개발 제대로 시작하기, 알고리즘 재활 훈련", "url": "/posts/220606til/", "categories": "TIL/2022, 06", "tags": "til, css, javascript, algorithm", "date": "2022-06-06 00:00:00 +0900", "snippet": "220606 Today I learned! 인터랙티브 웹 개발 제대로 시작하기 알고리즘 재활 훈련1. Fact(1) 인터랙티브 웹 개발 제대로 시작하기 인터렉티브 웹사이트를 만들기 위한 기초 지식 학습 섹션 00 ~ 섹션 05 CSS 속성 : transform, transition, animation, pespective 등 JS: 이벤트 위임 등 정리본(2) 알고리즘 재활 훈련 Jungol LCoder_python 출력, 변수와 입력 문제 풀이 풀이2. Feeling프로젝트가 끝난 후 절거운 휴식 후, 찐 방학이 왔다! 06월 10일까지 수업이 없고, 다음주 월요일부터 다시 계절 학기가 시작된다.지난주에, 06월에 어떤 공부를 할지 대략적으로 계획을 했다. 2학기가 시작되기 전 적당히 리프레시 하면서 공부를 할 예정이다.1학기 마지막 프로젝트 때 라이브러리를 일체 사용 하지 않으려 했지만, 몇가지의 기능들은 라이브러리를 사용했기때문에 이에 대한 아쉬움이 있었다.그 결과, 기초가 많이 부족하다는 생각이 들어서 프레임워크를 학습하기 보다는 CSS, Javascript 기초를 잡고 가려고 한다. 일분코딩: 인터렉티브 웹 개발 제대로 시작하기 , 애플 웹사이트 인터렉션 클론 Javascript deep-dive 완독!또한 CS지식이 1도 없기 때문에, 스터디가 필요하다는 생각이 들어서 스터디를 시작했다. 스터디원들이 돌아가면서 발표를 하는 방식으로 진행된다.네트워크 관련해서 키워드를 잡고 발표를 하고싶은데.. 고민중이다.🙃그리고 프로젝트 준비 하느라 오랫동안 놓았던 알고리즘PS 재활훈련도 시작했다. 이번 달은 재활하고 다음달부터 다시 백준문제를 풀 수 있지 않을까 싶다.06월 계획 기초 탄탄 CS 스터디 알고리즘 재활3. Finding Javascript 이벤트 위임참고한 블로그이벤트 위임이란 요소마다 이벤트를 바인딩 하지않고, 상위 요소에서 하위요소의 이벤트를 제어한다.모든 하위 요소의 이벤트를 따로따로 바인딩하는 것은 번거롭기 때문에, 한 번에 효율적으로 이벤트를 제어하기 위해 상위 요소에서 제어를 한다.이벤트 위임은 이벤트 버블링 (하위에서 발생한 이벤트를 상위요소가 알 수 있음) 을 활용한 기법이다.단, 이벤트 위임을 할 때는 에러처리를 잘 해주어야 한다.&lt;div class=\"stage\"&gt; &lt;div class=\"item a\"&gt;&lt;/div&gt; &lt;div class=\"item b\"&gt;&lt;/div&gt; &lt;div class=\"item c\"&gt;&lt;/div&gt;&lt;/div&gt;하위 div요소에 클릭이 발생하면 해당 요소를 제거 하려한다. 이는 event.target을 활용하여 반복 없이 쉽게 코드를 만들 수 있다. (이벤트 위임)const stage = document.querySelector(\".stage\");function clickHandler(event) { if (event.target.classList.contains(\"item\")) { stage.removeChild(event.target); }} stage.addEventListener(\"click\", clickHandler);stage(상위 요소)에서 하위 요소들의 click 이벤트를 듣고, 실제로 click이 발생한 요소가 조건에 부합하면 삭제한다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! JavsScript DeepDive notStarted🌙   " }, { "title": "22/05/13 ~ 22/05/26 1학기 관통 프로젝트 회고", "url": "/posts/220527til/", "categories": "TIL/2022, 05", "tags": "vue, django, project, MovieWiki, 짤막회고", "date": "2022-05-27 00:00:00 +0900", "snippet": "220527 프로젝트 회고" }, { "title": "22/05/20/금 1학기 마지막 프로젝트- NavBar, 로그인, 회원가입 구현", "url": "/posts/220520til/", "categories": "TIL/2022, 05", "tags": "til, vue, django, project, MovieWiki", "date": "2022-05-20 00:00:00 +0900", "snippet": "220520 Today I learned! 1학기 마지막 프로젝트1. Fact(1) 1학기 마지막 프로젝트 GitHub와 GitLab을 연동 navBar :로그인 유무에따라 유저에게 보이는 화면이 다르다. 로그인 유저: 프로필 이미지 비로그인 유저: 회원 가입 및 로그인 버튼 회원 가입 유저가 회원가입 버튼을 누르면 모달창이 켜진다. (모달창 외부를 누르면 종료된다.) 버튼을 누르면 유저가 기입한 정보를 서버로 보낸다. 정보가 유효하면 서버에 저장되고 토큰을 발급한다. 발급된 토큰을 localStorage에 저장하고 토큰을 활용하여 추가적으로 유저 프로필을 localStorage에 저장한다. 만약 정보가 유효하지 않았다면, 오류가 발생한다. 오류가 발생한 원인을 유저에게 알려준다. 로그인 유저가 로그인 버튼을 누르면 모달창이 켜진다. (모달창 외부를 누르면 종료된다.) 버튼을 누르면 유저가 기입한 정보를 서버로 보낸다. 정보가 유효하면 토큰을 발급한다. 발급된 토큰을 localStorage에 저장하고 토큰을 활용하여 추가적으로 유저 프로필을 localStorage에 저장한다. 만약 로그인 실패가 되었다면 유저에게 알림을 보낸다. 프로젝트 깃허브 프로젝트 노션2. Feeling피곤…..🙄.. 오늘 목표로한 기능을 전부 구현하지 않았다. 하지만, 혼자 console.log도 찍어보면서 account관련 로직에 대해 많이 배운 것 같다.오늘은 팀원이 꽤나 힘들어했다. 그런데 내 코가 석자여서 팀원을 잘 챙기지 못한느낌이다. 내일부터는 정말 같이 힘내면서 프로젝트를 진행해야겠다.CSS도 기능도 내가 원하는 데로 진행되지 않는 느낌이지만 내가 계획했던 것을 하나 둘 완성해나가는 기분이 너무 좋다!3. Finding Token 활용법 username(id)를 가져와서 해당 유저모델 세부 데이터에 접근한다.dispatch()로 발생하는 axios는 비동기적으로 진행되기 때문에, api 통신이 끝난 후에 확인해야 한다.// src/store/modules/account.js // 토큰과 맞는 username을 가져온다. fetchCurrentUser({ dispatch, getters, commit, state }) { if (getters.isLoggedIn) { axios({ url: drf.accounts.currentUserInfo(), method: \"get\", headers: getters.authHeader, }) .then((response) =&gt; { commit(\"SET_CURRENT_USER\", response.data); dispatch(\"fetchProfile\", state.currentUser); }) .catch((error) =&gt; { if (error.response.status === 401) { dispatch(\"removeToken\"); dispatch(\"removeProfile\"); router.push({ name: \"login\" }); } }); } },//username과 맞는 유저의 상세 profile을 가져온다. fetchProfile({ getters, commit }, { username }) { axios({ url: drf.accounts.profile(username), method: \"get\", header: getters.authHeader, }).then((response) =&gt; { const profileDict = { username: response.data.username, nickname: response.data.nickname, age: response.data.age, region: response.data.region, image: response.data.profile_image, }; const JsonProfileDict = JSON.stringify(profileDict); console.log(profileDict); commit(\"SET_PROFILE\", profileDict); localStorage.setItem(\"userProfile\", JsonProfileDict); }); }, Token을 localStorage에 저장하여 로그인한 유저인지 확인한다.isLoggedIn: (state) =&gt; !!state.token,별첨*오류내용을 뽑아서 오류가 발생한 원인을 유저에게 알려준다. (알림)// 회원가입 signUp({ dispatch }, credential) { axios({ url: drf.accounts.signup(), method: \"post\", data: credential, }) .then((response) =&gt; { const token = response.data.key; dispatch(\"saveToken\", token); dispatch(\"fetchCurrentUser\"); }) .catch((error) =&gt; { // 오류 내용을 뽑는다. const err = JSON.parse(error.request.response); const errMessage = Object.values(err)[0][0]; // 오류 알럿! Swal.fire({ title: errMessage, icon: \"error\", toast: true, width: \"25%\", confirmButtonColor: \"#5865f2\", }); }); },4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/19/목 Vue 응용, 1학기 마지막 프로젝트- API", "url": "/posts/220519til/", "categories": "TIL/2022, 05", "tags": "til, vue, django, project, MovieWiki", "date": "2022-05-19 00:00:00 +0900", "snippet": "220519 Today I learned! 1학기 마지막 프로젝트1. Fact(1) 1학기 마지막 프로젝트 트레일러 페이지 API profile_imge 필드 수정 회원 가입 시 기입한 정보가 DB에 저장되지 않는 오류를 수정했다. MovieReview API 최신순, 인기순 필터 CRUD 프로필 페이지, 회원정보 수정 API 영화 추천 API 최근 개봉 인기 영화 (50일 이내 개봉, 인기도 순으로 정렬) 요즘 제일 관심 받는 영화 (30일내에 작성된 리뷰가 많은 영화) 계절 추천 영화 (계절별 특정의 인기 있는 영화를 추천) Vue 초기 셋팅 프로젝트 깃허브 프로젝트 노션2. Feeling어제 구현하지 못한 회원 탈퇴를 구현했다. settings.py의 installed app에 빠진 내역이 있어서 오류가 발생했던 것이다 ㅠㅠ 요즘 왜맞틀~을 왜치면서 오류를 찾는 데 바쁘다. 그래도 오늘 백엔드는 끝이났고 내일부터 프론트 엔드를 시작할 것 같다. 과연 내가 기획했던 것들을 전부 구현할 수 있을지 모르겠지만,,,,Vue에 대한 실력이 미숙한 것은 누구보다 알지만 프로젝트를 하면서 많이 배워갈 수 있을 거라는 생각이 든다.3. Finding django orm은 신이다…. annotate로 생성한 열을 filter로 조건을 줄 수 있다. 또한, __를 활용하면 역참조 모델의 다른 필드에 접근할 수 있다.now = timezone.now()movies = Movie.objects.annotate( review_count=Count( 'review', distinct=True, filter = Q( review__created_at__range=[now-timedelta(days=30), now] ))).order_by('-review_count')[:21]serializer = MovieListSerializer(movies, many=True)return Response(serializer.data)annotate를 통해 review_count column을 생성하고 생성한 열을 created_at 범위로 filter설정을 준다.그 결과, 30일 이내 reivew를 작성한 수가 많은 영화에 대한 데이터를 받아올 수 있다. order_by('?')는 랜덤으로 정렬한 결과를 도출한다. now = int(timezone.now().strftime('%m')) if now == 3 or now == 4 or now == 5: season = 'spring' elif now == 6 or now == 7 or now == 8: season = 'summer' elif now == 9 or now == 10 or now == 12: season = 'fall' else: season = 'winter' season_code = { 'spring': 10749, 'summer': 27, 'fall': 12, 'winter': 14 } genre_id = season_code.get(season) movies = Movie.objects.filter(genre_ids=genre_id, popularity__gt=99).order_by('?')[:21] serializer = MovieListSerializer(movies, many=True) return Response(serializer.data)너무 인기도로만 정렬 하면 겹치는 추천영화가 많을 것을 예상했다. 그래서 인기도의 하한선을 정한뒤, 랜덤으로 정렬하여 데이터를 보낸다. ~Q()은 not~과 같다.movie = Movie.objects.filter(~Q(trailer_youtube_key='nothing') ,popularity__gt=99).order_by('?')serializer = MovieTrailerSerializer(movie, many=True)return Response(serializer.data) ~Q(trailer_youtube_key='nothing' =&gt; trailer_youtube_key가 있는 경우를 의미한다. (데이터를 받을 때 조건에 맞는 데이터가 없으면 ‘nothing’를 저장하기 때문이다.)즉, trailer_youtube_key가 있고 인기도가 99를 넘는 영화를 랜덤으로 정렬한다. URL을 조심하자…!/api/v1/accounts/login, signup이 되지 않아 골치가 많이 아팠다. 갑자기 자격 인증데이터(authentication credentials)가 제공되지 않아서 접근할 수 었다는 오류가 발생했다. login과 signup단계에서는 당연히 토근이 생성되지 않았기 때문에 토큰을 가져올 수 없는데, 왜 이럴까 고민했다.그런데! 나의 빛과 소금과 같은 프엔 스터디 친구들이 도움을 주었다.urlpatterns = [ path('admin/', admin.site.urls), path('api/v1/movie/', include('movies.urls')), path('api/v1/article/', include('articles.urls')), path('api/v1/accounts/', include('dj_rest_auth.urls')), path('api/v1/accounts/signup/', include('dj_rest_auth.registration.urls')), # 프로필로 가는 url 뒤에 &lt;str:username&gt;이 붙을 예정이다. path('api/v1/accounts/', include('accounts.urls')),]여기서 중요한 것은 path('api/v1/accounts/', include('accounts.urls'))를 가장 맨뒤로 보내야 한다는 것이다.만약 상단에 배치한다면, 해당 url은 뒤에 &lt;str:username&gt;이 붙기 때문에 api/v1/accounts/login 혹은 api/v1/accounts/signip/의 뒷부분이 문자열로 인식된다.그 결과, 내가 생각했던 view함수가 실행되지 않을 것이다. 또한, 위의 url의 문제점은 signup이라는 아이디를 가진 사람은 자신의 프로필 페이지에 절대 가지 못한다. 😅 그래서 결국 api/v1/accounts/profile/&lt;str:username&gt;으로 수정했다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/18/수 Vue 응용, 1학기 마지막 프로젝트- API", "url": "/posts/220518til/", "categories": "TIL/2022, 05", "tags": "til, vue, django, project, MovieWiki", "date": "2022-05-18 00:00:00 +0900", "snippet": "220517 Today I learned! Vue 응요 1학기 마지막 프로젝트1. Fact(1) Vue 응용 Navigation Guard: 전역가드 Vuex Module Vue Component 구성 서버와의 통신을 통한 article, comment, account 구현(2) 1학기 마지막 프로젝트 Article게시판 필터 API 인기게시판 (7일이내 인기순) 자유게시판, 영화게시판, 배우 게시판 ArticleComment API CRUD API 좋아요 API User관련 API와 Serializer 회원가입 Serializer 재 정의 프로필 페이지, 회원정보 수정 API 프로젝트 깃허브 프로젝트 노션2. Feeling오늘은 정말 정신이 없었다. 마지막 vue 수업이기 때문에 코드를 따라칠 시간도 없이 진도가 진행되었다. 프로젝트에서 직접 구현해보면서 해당 내용을 학습해야 할 것 같다.프로젝트는 잘 진행되고 있다. 내일 백엔드를 어느정도 완성하는 것이 목표이다. 오류도 많이 발생하고 Serializer에 머리가 많이 아프지만,…🙃아쉬운 점 회원정보 수정에서 비밀번호를 수정하지 못했다. 회원 탈퇴를 구현하지 못했다.3. Finding 너무 과한 모듈화는 하지 말자.Serializer 오버라이드를 할 때 과한 모듈화는 독이 된다. most likely due to a circular import에러가 계속 발생해서 진행이 더뎌졌는데, Serializer가 계속 오버라이드가 되다보니 서로 참조가 되는 상황이 자연스럽게 발생하게 되어 오류가 계속 발생했다. 그래서 다음과 같이 보기 싫은 코드가 나왔다 😥from rest_framework import serializersfrom movies.serializers.movie import MovieListSerializerfrom movies.serializers.movie_review import ProfileMovieReviewSerializerfrom articles.serializers.article_comment import ProfileArticleCommentSerializerfrom articles.models import Article, ArticleTypefrom django.contrib.auth import get_user_modelUser = get_user_model()class UserProfileSerializer(serializers.ModelSerializer): class ProfileArticleSerializer(serializers.ModelSerializer): class ArticleTypeSerializer(serializers.ModelSerializer): class Meta: model = ArticleType fields = ('pk', 'name') article_type = ArticleTypeSerializer(read_only=True) like_count = serializers.IntegerField(source=\"like_users.count\", read_only=True) class Meta: model = Article fields = ('pk', 'article_type', 'title', 'content', 'created_at', 'article_type','like_count',) like_movies = MovieListSerializer(many=True, read_only=True) article = ProfileArticleSerializer(many=True, read_only=True) comment = ProfileArticleCommentSerializer(many=True, read_only=True) review = ProfileMovieReviewSerializer (many=True, read_only=True) class Meta: model = User fields = ('pk', 'nickname', 'region', 'age', 'profile_image','like_movies', 'article', 'comment', 'review',)하나의 Serailizer에 모듈을 통한 참조와 직접 참조하는 것이 섞인 상황…이다.. 프로젝트 진행할 시간이 촉박해서 따로 수정하지 않고 넘어가지만, 나중는 꼭..!!다음에는 반복되는 코드가 많더라도, circular import에러방지와 코드의 가독성을 위해 직접참조만 사용하는 방식으로 코드를 작성할 것이다. DJango에서는 datetime.now()보다는 timezone.now()를 써야 한다.1주일이내 작성된 글을 필터링 해야하기 때문에 먼저 datetime.now()를 활용하여 현재 시각을 구하려 했다.now = datetime.now() before_one_week = now - timedelta(weeks=1) now = now.strftime('%Y-%m-%d') since = before_one_week.strftime('%Y-%m-%d')articles = Article.objects.filter(created_at__range=[since, now])그런데, warnings.warn(\"DateTimeField %s received a naive datetime (%s)라는 경고가 터미널창에 뜨는 것을 확인할 수 있었다. 참고블로그 datetime 객체의 종류는 크게 Navie 객체(timezone 정보를 포함하지 않는 datetime)와 Aware 객체(timezone 정보를 포함하는 datetime)가 있다.현재 Settings.py에서 Use_TZ=True로 설정을 했기문에 Aware datetime 객체를 사용하게 되는데, 현재 시간을 구하기 위해 사용한 datetime.now()는 Navie datetime 객체이다.즉, 이 둘의 차이 때문에 경고를 하는 것이다. 호환성을 위해 Naive datetime 객체를 사용해도 Awatr datetime 객체로 변환하지만 다른 문제가 발생할 여지가 있기 때문에 경고를 띄워준다.# 해결 방안: timezone.now()활용now = timezone.now()articles = Article.objects.filter(created_at__range=[now-timedelta(days=6), now]) annotate를 활용하여 새로운 필드를 만들고 이를 이용하여 정렬을 할 수 있다.좋아요가 많은 순서에 따라 데이터를 정렬을 해야 했다. 하지만 model에는 좋아요를 한 사람들에 대한 정보는 있지만 숫자를 기록하는 필드가 지정되지는 않았다.그래서 annotate를 통해 새로운 필드를 생성하고 이를 통해 좋아요가 많은 순서로 정렬을 할 수 있었다.# 최근 1주일 게시글, 좋아요 순으로 나열 articles = Article.objects.filter( created_at__range=[now-timedelta(days=6), now] ).annotate( like_count=Count('like_users', distinct=True) ).order_by('-like_count')4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/17/화 Vue API 실습, 1학기 마지막 프로젝트- Model, Serialize 구현", "url": "/posts/220517til/", "categories": "TIL/2022, 05", "tags": "til, vue, django, project, MovieWiki", "date": "2022-05-17 00:00:00 +0900", "snippet": "220517 Today I learned! Vue API 실습 1학기 마지막 프로젝트1. Fact(1) Vue API 실습 어제 학습했던 CORS와 Token 로그인에 대한 복습(2) 1학기 마지막 프로젝트 API 설계 팀 깃허브 초기 세팅 Model Article, User 관련 모델 구현 API Article Serializer 및 API 구현 프로젝트 깃허브 프로젝트 노션2. FeelingArticle CRUD, 좋아요 관련 API를 구현했다. 팀원과의 정리를 위해 API를 미리 설계했지만, 설계가 부실했는지 추가해야 하는 내용들이 계속 보였다. 어떤 데이터를 보내야 하는지 와이어프레임을 보면서 확인했는데, 1:N , M:N관계가 많다보니까 생각보다 serializer를 만드는 데 오랜 시간이 걸렸다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/16/월 CORS와 Token로그인, 1학기 마지막 프로젝트- ERD설계", "url": "/posts/220516til/", "categories": "TIL/2022, 05", "tags": "til, vue, django, project, MovieWiki", "date": "2022-05-16 00:00:00 +0900", "snippet": "220516 Today I learned! CORS와 Token 로그인 1학기 마지막 프로젝트1. Fact(1) CORS와 Token 로그인 CORS를 사용하여 교차출처 접근을 허용한다. django-cors-headers라이브러리 Authentication &amp; Authorization 인증과 권한부여 JWT vs Token 활용 dj-rest-auth, django-allauth (2) 1학기 마지막 프로젝트- ERD 설계 기능명세서와 와이어프레임을 기반으로 ERD를 설계했다. 노션2. FeelingTMDB API를 통해 데이터를 받아서 저장하는 과정에 대한 많은 고민을 했다. 결국, TMDB API를 통해 받은 데이터를 json으로 변환한 후 이를 DB에 반영하기로 했다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/15/일 1학기 마지막 프로젝트- 와이어 프레임", "url": "/posts/220515til/", "categories": "TIL/2022, 05", "tags": "til, vue, project, MovieWiki", "date": "2022-05-15 00:00:00 +0900", "snippet": "220515 Today I learned! Vue 과목평가 시험공부1. Fact(1) Vue 시험공부 Vue 기초 문법 Vue Props와 Router Vuex 요약본2. Feeling1학기 마지막 과목평가…..3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/14/토 1학기 마지막 프로젝트- 와이어 프레임", "url": "/posts/220514til/", "categories": "TIL/2022, 05", "tags": "til, figma, project, MovieWiki", "date": "2022-05-14 00:00:00 +0900", "snippet": "220514 Today I learned! Vue 프롭스와 라우터 CSS 그리드1. Fact(1) 1학기 마지막 프로젝트- 와이어 프레임 어제 팀원과 제작한 기능 명세서 및 컴포넌트 구조를 기반으로 와이어 프레임을 제작했다. 피그마를 활용한 와이어 프레임 제작 디자인 시스템과 컴포넌트 제작 내가 만든 컴포넌트 및 페이지와 모달 Home View의 NavBar와 Modal (홈뷰의 네브바와 모달- 로그인, 비로그인 버전 ) SearchMovieModal (검색 창, 검색 결과를 보여주는 모달) MovieDetailView (영화 상세 페이지 및 한줄평 페이지 -로그인, 비로그인 버전 ) UserInfoView( 유저 프로필 페이지 및 회원정보 수정 모달 ) 피그마2. Feeling오후 2시에 시작해서 오전 3시에 끝난...... 와이어 프레임 제작기...피그마를 처음 접한 팀원과 같이 함께 열심히 제작했다. 먼저 팀원에게 피그마 유튜브 강의 하나와 카드 컴포넌트를 만들어보라는 과제를 던져주고 디자인 시스템을 제작했다. 우리의 웹사이트 색 테마는 사실…….디스코드!!이다. 특별한 prime 컬러 없이 제작했다. 굳이 prime 컬러를 꼽자면 gray??사실 나도 피그마를 이렇게 다뤄본 적은 처음이기 때문에 힘들었지만 즐거운 과정이였다. (밤11시 전까지는..)저녁식사, 운동 시간을 제외하고 쉬지 않고 달려서 새벽부터는 너무 힘들었다. 그 결과, 새벽 시간의 일 효율이 너무 떨어졌다. 일도 쉬는 시간을 가지면서 해야한다는 것을 새삼 느꼈다. 그래도 결과물을 보니 뿌듯했다. 하지만, 우리가 만든 와이어 프레임 그대로 CSS를 구현할 수 있을지에 대한 우려도 있다.웹사이트 디자인은 넷플릭스, 티빙, 와챠, 리디북스, 인프런 등 다양한 사이트를 보고 제작했다. 그 결과, 현재 운영하는 사이트들과 너무 유사한 느낌도 있지만,,, 그래도 만족스럽다!3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/13/금 관통프로젝트, 1학기 마지막 프로젝트-기능명세서, 컴포넌트 구조 작성", "url": "/posts/220513til/", "categories": "TIL/2022, 05", "tags": "til, erd, project, MovieWiki", "date": "2022-05-13 00:00:00 +0900", "snippet": "220513 Today I learned! 관통 프로젝트 스터디 발표 1학기 마지막 프로젝트 (영화 커뮤니티 만들기)1. Fact(1) 관통프로젝트 Vue를 활용한 SPA구성 Git Hub 연습 이슈와 브런치를 활용한 개발을 팀원과 연습했다. TMDB API를 활용하여 영화 웹사이트 제작 영화 게시판 기능 랜덤 추천 기능 보고 싶은 영화를 기록하는 기능 (2) 스터디 발표 CSS를 활용한 그리드 레이아웃을 만드는 내용을 발표(3) 1학기 마지막 프로젝트 준비 기능 명세서 컴포넌트 구조 노션 페이지2. Feeling이제 정말 프로젝트 준비를 시작했다. 우선 우리 팀은 계획부터 천천히 하기로 마음을 먹었다. 그래서 정한 일정은 다음과 같다. 기능명세서 및 컴포넌트 구조 제작 와이어 프레임 제작 ERD설계 API 설계 및 백엔드 구현 프론트 엔드 구현계획 단계 먼저 우리가 만들 웹사이트에 필요한 기능을 생각해 보고 이에 따른 컴포넌트및 라우터 view를 구조화한다. (오늘 한 일!) 구조화된 컴포넌트와 라우터 view를 기반으로 와이어 프레임을 제작한다. ( 토요일 ) 구현할 기능에 필요한 데이터를 기반으로 ERD를 설계한다. ( 월요일 ) 이게 맞는 방식인지는 모르겠지만, 우선 우리는 어떤 영화커뮤니티를 만들고 싶고 이에 따라 필요한 기능을 나열해서 정리했다. 사실 우리가 만들고 싶은 영화커뮤니티는 사실 특별한 특색이 있는 웹사이트는 아니다. 실제로 상용화 되어도 어색하지 않은 평범한 사이트를 만들고 싶다는 생각이 컷다.내가 유저라면 어떤 영화 사이트가 있으면 좋을지 생각했을 때, 필요한 기능은 크게 4가지였다. 영화에 대한 정보를 보여주었으면 좋겠다. =&gt; 영화 데이터 조회할 수 있다. 다른 사람들의 평가가 궁금하다. =&gt; 유저들이 평가를 하는 공간 요즘 볼만한 영화가 궁금하다. =&gt; 추천 기능 심심할 때 생각 없이 즐길 수 있는 오락거리가 있었으면 좋겠다. =&gt; 요즘 유행하는 유튜브 Shorts기능과 유사한 랜덤 영화 트레일러 Shorts기능그래서 이를 기반으로 우리는 기능을 만들기로 했다. 3번의 경우 우리가 깊이 있는 추천 알고리즘을 만들 수 없다는 생각을 했기 때문에 가볍고 다양한 추천 기능을 만들기로 했다. 그래서 총 11가지의 추천기능이 나왔다.이번 프로젝트는 정말 detail을 신경써서 만들고 싶다. 유저가 보기에 불편함이 하나도 없는 사이트! 이게 내 목표이다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/12/목 Vuex , CSS 레이아웃 강의 (그리드)", "url": "/posts/220512til/", "categories": "TIL/2022, 05", "tags": "til, vue, css", "date": "2022-05-12 00:00:00 +0900", "snippet": "220512 Today I learned! Vuex 활용 실습 CSS 그리드1. Fact(1) Vuex 활용 실습 수요일에 학습한 Vuex에 대한 내용을 리마인드 한다. 어제 수업시간에 학습한 to-do 리스트를 혼자 구현한다. 지난 번에 제작했던 유튜브 API를 활용한 유튜브 앱을 Vuex를 통해 구현한다. 검색 기능 검색 결과에 맞는 유튜브 영상 리스트 제공 리스트 항목을 클릭하면 유튜브 영상이 플레이 된다. 정리본(2) CSS 레이아웃 강의 (그리드) 1학기 마지막 프로젝트 준비 그리드를 활용한 반응형 웹페이지 및 예제 요약본1 요약본22. FeelingVuex를 활용해서 직접 구현해보니 확실히 편리하다는 것을 알았다. emit, props으로만 컴포넌트가 통신하는 것이 얼마나 불편한지 새삼 깨닳게 되었다. 하지만 Store에 저장할 데이터와 컴포넌트단에서만 사용할 데이터를 잘 구분해야 할 것 같다. 단순히 유저에게 받아오는 인풋데이터 같은 경우 일일이 DB에 저장할 필요는 없다. 1학기 마지막프로젝트에서도 이것을 잘 유념해서 코드를 작성해야 할 것 같다.그리고 드디어 css 레이아웃 강의를 전부 다 들었다! flex는 지난 리액트 프로젝트에서 활용해서 많이 익숙해진 것 같지만, 아직 그리드는 아니다. 이에 대해서 많이 연습을 해야겠다. 그리고 이번 강의를 들으면서 css에 대한 기초지식이 많이 부족하다는 것을 느꼈다. 여유가 생기면 css 기초에 대해서도 더 공부를 해야할 것 같다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/11/수 Vuex를 활용한 데이터 통신", "url": "/posts/220511til/", "categories": "TIL/2022, 05", "tags": "til, vue", "date": "2022-05-11 00:00:00 +0900", "snippet": "220511 Today I learned! Vuex를 활용한 데이터 통신1. Fact(1) Vuex를 활용한 데이터 통신 Vuex를 활용한 상태관리 Vuex에서 State, Getters, Mutations, Actions의 역할과 활용방안을 학습했다. 컴포넌트의 공유된 상태를 추출하고 이를 전역에서 관리한다. 단방향데이터 흐름에서 원활하게 데이터를 관리하기 위해 중앙저장소 (store)에서 State를 관리한다. State: 중앙에서 관리하는 모든 상태 정보 Mutations: 실제 State를 변경하는 유이란 함수 Actions: 비동기 작업 및 Mutations를 호출하는 함수 Getters: State를 변경하지 않고 활용하여 계산을 수행하는 함수 (computed와 유사하다. ) Vuex를 활용하여 to-do앱을 생성한다. to-do리스트 생성 to-do 리스트 조회 to-do 리스트 수정 to-do 리스트 결과 localStorage 정리본2. FeelingVuex를 통해 편리하게 상태관리하는 방법을 배웠다. 요즘 Vue에 대해 학습하면서 내가 이전에 리액트 프로젝트에서 위험하게 데이터를 다루었다는 것을 깨닳고 있다. 그 때는 컴포넌트단에서 UseState(Mutations)를 props로 받아서 직접 데이터를 수정했었는데, 차라리 UseState를 활용하는 함수를 생성해서 props로 보내주는게 맞는 방식 인 것 같다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/10/화 Vue 프롭스와 라우터 , CSS 레이아웃 강의 (그리드)", "url": "/posts/220510til/", "categories": "TIL/2022, 05", "tags": "til, vue, css", "date": "2022-05-10 00:00:00 +0900", "snippet": "220510 Today I learned! Vue 프롭스와 라우터 CSS 그리드1. Fact(1) Vue 프롭스와 라우터 월요일에 학습한 프롭스와 라우터에 대한 내용을 리마인드 한다. 부모에서 자식이 통신하기 위해 사용하는 props와 emit을 연습했다. 데이터를 중복선언 하지 않는다. 데이터를 선언한 곳에서만 데이터를 수정한다. 컴포넌트들이 데이터를 공유한다면 공통 부모에 데이터를 저장하는 구조를 작성한다. Vue, 유튜브 API를 활용하여 유튜브 앱을 완성한다. 검색 기능 검색 결과에 맞는 유튜브 영상 리스트 제공 리스트 항목을 클릭하면 유튜브 영상이 플레이 된다. 정리본(2) CSS 레이아웃 강의 (그리드) 1학기 마지막 프로젝트 준비 그리드 기초 내용 학습 요약본2. Feeling요즘 정신이 없다. 슬슬 1학기 마지막 프로젝트가 다가오면서 이리저리 준비하느라 바쁘다. 아직 구체적인 명세가 나오지 않아서 프로젝트를 시작할 수는 없지만 대략적인 준비는 미리 할 예정이다.그래서 어제 프로젝트용 노션 페이지를 만들었다. 프로젝트 관련 공부는 해당 페이지에 정리할 예정이다. 현재 팀원과 인강을 나눠서 듣고있다. 인터렉티브 웹사이트에 관련된 내용은 팀원이, 반응형 웹사이트에 관련된 내용은 내가 공부하고 있다. 업무를 효율적으로 배분하기위해 프로젝트에 필요한 공부를 각자 하고 해당 업무를 맡을 예정이다. 그래도 각자 공부한 내용을 공유하여 서로의 코드를 이해할 정도의 지식을 갖도록 할 것이다.그런데, vue 공부를 많이 놓치고 있는 것 같다. 주말에 몰아서 해야할 것 같다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/06/금 Social Logtin과 Infinite Scroll, 관통 프로젝트, 스터디 발표", "url": "/posts/220506til/", "categories": "TIL/2022, 05", "tags": "til, vue, algorithm, project, WaZaByo", "date": "2022-05-06 00:00:00 +0900", "snippet": "220506 Today I learned! 소셜 로그인 및 Infinite Scroll 기능 학습 관통프로젝트 스터디 발표 백준 문제 풀이1. Fact(1) Social Login 과 Infinite Scroll Oauth를 통해 Django에서 Social Login을 구현하는 방법 학습 공식문서 Pagination과 Infinite Scroll 공식문서 관련 문서 (2) 관통 프로젝트 Django 팔로우, 좋아요 기능 비동기로 구현 영화 index 페이지 Infinite Scroll 구현 영화 메인 페이지에 도달했을 때, 10개의 영화데이터만 load한다. paginator를 통해 Movie db에 저장된 데이터 10개를 render한다. 받은 데이터를 유저에게 보여준다. 스크롤이 바닥에 닿았을 때, 추가 데이터를 비동기적으로 요청한다. EventListner를 통해 스크롤에 바닥에 닿은 이벤트가 발생하면 데이터를 요청하는 콜백함수(비동기)를 실행한다. 응답을 통해 받은 데이터를 뒤에 붙인다. 요청을 받으면 그에 맞는 JSON 데이터를 준다. 요청을 통해 받은 데이터를 활용하여 element를 생성하고 DOM에 반영한다. 영화 추천 알고리즘 구현 회원 가입시, 유저가 좋아하는 장르를 선택한다. user model에 장르 id를 기록하는 필드를 추가 회원가입 form 수정 추천페이지에서 유저가 좋아하는 장르의 영화를 추천한다. 장르와 영화는 M:N 관계 역참조를 통해 장르의 id를 통한 영화 데이터 필터링 2. Feeling영화 추천 알고리즘은 의도했던 데로 구현하는 데 많은 시간이 들었다. 데이터를 어떻게 가공해서 전달해야 하는 지 감을 잡지 못했던 것 같다. 하지만 동기들의 조언 덕분에 해결할 수 있었다!스터디 프로젝트가 마무리 되었다. 사실 나는 프로젝트 목표를 작게 잡아서 여유롭게 프로젝트를 진행했고 기한 내에 완성할 수 있었다. 이에 대해 조금 아쉬움이 있다. 좀 더 많이 시도하고 공부할 수 방향으로 프로젝트를 진행해보는 것도 나쁘지 않았을 지도…🤔3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/05/목 Vue.js 복습, 스터디 프로젝트 마무리", "url": "/posts/220505til/", "categories": "TIL/2022, 05", "tags": "til, vue, react, algorithm, project, WaZaByo", "date": "2022-05-05 00:00:00 +0900", "snippet": "220505 Today I learned! Vue.js 복습 스터디 프로젝트 마무리 백준 문제 풀이1. Fact(1)Vue.js 복습 Vue 공식문서와 교재를 읽으며 복습 Vue 기초 문법을 추가 정리했다. Vue instance의 option template 문법 정리본(2) 스터디 프로젝트 마무리 데이터 교환을 통한 Drag and Drop 구현 완벽한 Drag and Drop은 아니지만, 위치 교환은 구현했다. 사이드바 추가 평균 소모 칼로리, 최고 소모 칼로리를 보여주는 사이드바 구현 (3) 백준 문제 풀이 17471 게리맨더링 문제풀이 BFS 코드 구현을 너무 복잡하게 했다. 조합, 그래프인지 찾는 함수를 매번 새로 구현하다보니 구현 시간이 길어졌다. 라이브러리 사용하는 것을 연습을 할 예정이다. 참고할 블로그 2. Feelingnull;3. Finding Drag and Drop을 데이터 교환으로 간단하게 만들어 볼 수 있었다. (완벽하지는 않지만 ㅎㅎ)객체의 리스트 형식으로 데이터를 저장하니 데이터 관리가 편해졌다.그래서, 데이터 교환의 형식으로 드래그앤 드롭을 구현할 수 있었다.function Card({ data, setData, deleteData }) { /* 생략 */ let dragStartId = 0; const onDragStart = (num) =&gt; { dragStartId = num; }; const onDrop = (dropId) =&gt; { // 데이터 찾기! const startData = data.find((element) =&gt; element.id === dragStartId); const startDataIndex = data.indexOf(startData); const dropData = data.find((element) =&gt; element.id === dropId); const dropDataIndex = data.indexOf(dropData); // 데이터 교환! startData.id = dropId; dropData.id = dragStartId; const newData = [...data]; newData[startDataIndex] = dropData; newData[dropDataIndex] = startData; // 데이터 저장! setData(newData); }; return ( &lt;div&gt; &lt;StyledDiv&gt; &lt;StyledCardContainer onDragOver={(e) =&gt; e.preventDefault()}&gt; {data.map((detailData) =&gt; detailData.id === undefined ? null : ( &lt;StyledCard key={detailData.id} draggable onDragStart={() =&gt; onDragStart(detailData.id)} onDrop={() =&gt; onDrop(detailData.id)} &gt; /* 생략 */} 카드 컴포넌트에게 draggble 속성을 준다. 드래그를 시작한 컴포넌트의 id와 drop된 위치에 있는 컴포넌트의 id를 가져온다. id를 통해 얻은 데이터 정보로 두 데이터의 위치를 교환한다. 데이터가 순서대로 랜더링 되기 때문에 LocalStorage에 위치한 데이터의 순서를 바꾼다. daragover의 기본동작을 막는 이유ondragover 속성은 드래그되는 대상 객체가 어느 요소 위에 놓일 수 있는지를 설정한다.기본적으로 HTML 요소는 다른 요소의 위에 위치할 수 없기 때문에, 다른 요소 위에 위치할 수 있도록 만들기 위해서는 놓일 장소에 있는 요소의 기본 동작을 막아야만 한다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/04/수 Vue.js 기초", "url": "/posts/220504til/", "categories": "TIL/2022, 05", "tags": "til, vue, algorithm", "date": "2022-05-04 00:00:00 +0900", "snippet": "220504 Today I learned! Vue.js 백준 문제 풀이1. Fact(1)Vue.js 기초 SPA Sigle Page Application CSR과 SSR 바닐라 JS와 vue.js Vue.js 기초 MVVM 기초 문법 instance templates 정리본(2) 백준 문제 풀이 2579 계단 오르기 문제풀이 DP 탑 다운 방식 문제는 어렵지 않았다. 처음에 단순 재귀 방식으로 풀고 memo를 활용하는 방식으로 수정했다. 2. FeelingVue를 배우면서 오히려 react에 대한 개념이 정리되는 느낌이 있었다. ‘watch는 useEffect와 비슷하네 ! computed는 useMemo인가?’ 하면서 혼자 비교하면서 수업을 들은 것 같다. 그런데 오늘 배운 양이 조금 방대해서 정리하는 시간이 걸릴 것 같긴하다.공식문서도 읽어보면서 내일, 내일모래 이틀동안 정리를 해야겠다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! why 리액트? Not Start🌙   " }, { "title": "22/05/03/화 JavaScript Ajax 실습, 스터디 프로젝트", "url": "/posts/220503til/", "categories": "TIL/2022, 05", "tags": "til, javascript, axios, react, algorithm, project, WaZaByo", "date": "2022-05-03 00:00:00 +0900", "snippet": "220503 Today I learned! JavaScript Ajax 실습 스터디 프로젝트 백준 문제 풀이1. Fact(1) JavaScript Ajax Ajax를 통해 DJango에서 비동기 처리하는 것을 구현 좋아요와 팔로우 AJAX 요청으로 처리한다. 로그인 사용자가 좋아요 or 팔로우 버튼을 누름에 따라 버튼이 바뀐다. 실시간으로 좋아요 수, 팔로워 수 , 팔로잉 수가 반영된다. 새로고침 없이 발생해야 한다. 서버로 요청을 보내고 AJAX 요청하는 url method csrf 서버에서는 요청에 맞는 JSON 응답한다 views.py 요청에 맞는 데이터 JsonResponse 받은 응답을 DOM에 반영한다. JS .then() 태그 생성 및 속성 변경 정리본(2) 스터디 프로젝트 코드 간소화 소모 칼로리를 표현하는 칼로리바를 반복문을 사용하여 코드를 간소화했다. Array.map을 활용해 컴포넌트를 render 했다. (자세한 내용은 Finding에 정리했다.) 코드 재사용성을 높이기 위해 Card컴포넌트에 있는 함수를 상위 컴포넌트로 이동시켰다. 그리고 해당 함수를 props로 넘겨받았다. const deleteData = (num) =&gt; { const newData = data.filter((d) =&gt; d.id !== num); setData(newData); };위의 코드를 App.js로 이동했다. 만약 다른 컴포넌트에서 데이터를 삭제할 일이 있다면 해당 함수를 props로 전달하여 코드를 재사용하기 위함이다. 데이터 pk(id) 설정하는 방법을 조금 수정했다.// 처음 코드// 새로고침하면 id가 0으로 리셋이 되기 때문에 새로고침 후 생성한 데이터의 pk가 겹친다. const [index, setIndex] = useState(0);// 이전 코드 // 데이터를 중간에서 삭제하면 데이터의 길이가 줄어들기 때문에 마지막 id와 새로 생성한 id가 겹친다.const [index, setIndex] = useState(data.length);// 현재 코드// 가장 마지막에 있는 데이터의 id에 +1을 하기 때문에 중간에 데이터를 삭제해도 id가 겹치지 않는다. const [index, setIndex] = useState(data[data.length - 1].id + 1 || 1)(3) 백준 문제 풀이 2579 계단 오르기 문제풀이 DP 바텀업 방식 연속 3개의 계단을 밟으면 안된다는 조건이 까다로웠다. 단순 재귀방법에서는 밟는 계단의 수를 카운트하면 되었지만, 바텀업에서는 이런 방식을 적용할 수 없다고 판단했다. 그래서 조건에 맞는 기저사례를 만들고 바텀업방식으로 풀었다. 그런데 풀고 보니 계단의 수가 300개 였기때문에 간편하게 탑다운 방식으로 풀어도 괜찮지 않았을까라는 생각이 들었다. (아님말구..) 2. Feeling역시 프로젝트는 재밌다. 혼자서 고민하고 해결하는 재미가 있는 것 같다. 하지만 내 코드가 과연 좋은 코드인지에 대한 의문이 계속 든다. 과연 좋은 코드는 무엇이고 어떻게 구현을 해야 하는 걸까. 참 어렵다. 이건 내가 리액트에 대한 지식이 부족하기 때문인 것같다. 왜 리액트에서는 함수형 컴포넌트를 쓰고, 컴포넌트를 나눠서 개발하고 , Hook은 어떻게 쓰고 리액트은 어떤 점이 좋은지에 대해 잘 모르겠다. 그래서 프로젝트 이후 이에 대해서 학습하는 시간을 갖고 싶다. 😊3. Finding 반복랜더링은 return이 있어야 한다! ㄴo0oㄱ (너무 당연한건데.. 생각을 못했다… 👀) /* component/card.js (수정 전 코드) */function Card({ data, deleteData }) { return ( /* 생략... */ {detailData.calories &lt;= 50 ? ( &lt;StyledCircleContainer&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;/StyledCircleContainer&gt; ) : detailData.calories &lt;= 100 ? ( &lt;StyledCircleContainer&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;/StyledCircleContainer&gt; ) : detailData.calories &lt;= 150 ? ( &lt;StyledCircleContainer&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;/StyledCircleContainer&gt; ) : detailData.calories &lt;= 200 ? ( &lt;StyledCircleContainer&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarGrey /&gt; &lt;StyledExpBarGrey /&gt; &lt;/StyledCircleContainer&gt; ) : detailData.calories &lt;= 250 ? ( &lt;StyledCircleContainer&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarGrey /&gt; &lt;/StyledCircleContainer&gt; ) : ( &lt;StyledCircleContainer&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;StyledExpBarRed /&gt; &lt;/StyledCircleContainer&gt; )} &lt;StyledCircleContainer /&gt; /* 생략... */\t);}위의 코드는 사용자가 입력한 칼로리를 각 조건에 따라 어떻게 표현되는지 보여준다. (6칸으로 되어있는 경험치바로 50, 100, 150… 단위로 빨간색 칸이 증가한다. 예를 들어, 200kal를 소모했다면 빨간색 칸 4개 회색칸 2개로 구성된 경험치 바를 랜더링한다.처음에는 단순하게 조건부 랜더링을 했다. 하지만 작성하면서도 이 코드는 나중에 수정을 해야겠다 마음을 먹었고 어떻게 반복랜더링을 할 수 있을지 고민해 보았다.1) 우선 칼로리 데이터에 접근을 해볼까?const dataCalories = data.map((data) =&gt; data.calories);console.log(dataCalories);2) 아 ! 데이터의 id가 있어야 하네!id에 접근하기 위해서는 결국 template에서 가져와야 했다. 그래서 script구간에서 미리 함수를 만들어놓고 랜더링을 해봤다.데이터의 칼로리를 인자로 전달하여 함수를 template에서 실행 하면 되지 않을까… 라고 생각을 했었다. 🙄function Card({ data, deleteData }) { const expBar = (num) =&gt; { let redStart = 0; let greyStart = 0; // 경험치바는 최대 6칸이기 때문에 6보다 큰수가 오면 6칸으로 처리한다. const red = num &gt;= 6 ? 6 : num; const grey = 6 - red; while (redStart &lt; red) { &lt;StyledExpBarRed /&gt; redStart += 1; } while (greyStart &lt; grey) { &lt;StyledExpBarGrey /&gt; greyStart += 1; } };\treturn ( /* 생략... 칼로리를 50으로 나눈 값을 인자로 넘긴다.(Math.floor()를 통해 소숫점은 버린다. ) */ &lt;StyledCircleContainer&gt; {expBar(Math.floor(detailData.calories / 50))} &lt;/StyledCircleContainer&gt; )3) 오류는 발생하지 않지만 컴포넌트가 보이지 않았다.생각해보니 당연한 이유였다. return이 없기 때문이다. (머쓱타드)처음에 localStorage에 있던 데이터 배열을 map 메서드로 카드 컴포넌트를 만든 것은 별 생각 없이 만들었다. 지금와서 생각해보니 반복할때마다 return을 해주기때문에 카드 컴포넌트를 생성할 수 있었던 것이다!이를 위해서는 경험치를 표현하는 배열을 만들어야 했다. 예를 들어 ‘200kal만큼 운동을 했다’라고 가정하면, 빨간색칸은 4칸 회색 칸은 2칸이여야 한다. red = [0, 0, 0, 0] , grey = [0, 0]과 같이 만든다. template부분에서 map을 통해 해당 배열의 길이만큼 컴포넌트를 생성하는 것이다.이것이 깔끔한 방법인지는 모르겠지만, 내가 아는 반복 랜더링 방법은 map 뿐이였기 때문에 배열을 만들 수 밖에 없었다.function Card({ data, deleteData }) { const greyExp = (num) =&gt; { const red = num &gt;= 6 ? 6 : num; const grey = 6 - red; const greyArray = new Array(grey).fill(0); // [0, 0, 0, 0] return greyArray; }; const redExp = (num) =&gt; { const red = num &gt;= 6 ? 6 : num; const redArray = new Array(red).fill(0); // [0, 0] return redArray; };\treturn ( /* 생략... 칼로리를 50으로 나눈 값을 인자로 넘긴다.(Math.floor()를 통해 소숫점은 버린다. ) key는 해당 데이터의 `id-칼로리바색-index`로 구성했다. */ &lt;StyledCircleContainer&gt; {redExp(Math.floor(detailData.calories / 50)).map( (item, index) =&gt; {return (&lt;StyledExpBarRedkey={`${detailData.id}-red-${index}`}/&gt;); } )} {greyExp(Math.floor(detailData.calories / 50)).map( (item, index) =&gt; {return (&lt;StyledExpBarGreykey={`${detailData.id}-grey-${index}`}/&gt;); } )} &lt;/StyledCircleContainer&gt; )4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 1일 1알고! 🔥 in progress 🚀   why 리액트? Not Start🌙   " }, { "title": "22/05/02/월 JavaScript Ajax", "url": "/posts/220502til/", "categories": "TIL/2022, 05", "tags": "til, javascript, axios, algorithm", "date": "2022-05-02 00:00:00 +0900", "snippet": "220502 Today I learned! JavaScript 시험 JavaScript Ajax 복습 백준 문제 풀이1. Fact(1) JavaScript Ajax JS가 서버와 통신하고 응답을 받아 이를 처리하기 위한 내용들 자바스크립트는 싱글 스레드이다. 이벤트를 처리하는 Call Stack이 하나이다. 이 문제를 해결하기 위해 WebAPI, Task queue, Event Loop를 활용하여 비동기적으로 일을 처리한다. 순차적으로 비동기 처리를 해야 한다. 콜백 함수 Promise 객체 Async, Await Axios AJax 요청을 편리하게 하기 위해 사용한다. 정리본(2) 백준 문제 풀이 DP 연습 시작! 목표: DP 골드 문제 풀기 2748 피브나치의 수2 14631 1로 만들기 문제풀이2. FeelingDP문제에 너무 약해서 실버문제부터 차근차근 연습하려 한다. 처음부터 DP 방식으로 코드를 구현하는 것은 어려워서, 재귀(백트래킹)의 방식으로 코드를 작성하고 이를 DP방식으로 수정했다. 탑다운방식이 좀 더 구상하기 쉽지만, 메모리제한때문에 바텀 업 방식으로 풀어야 하는 경우가 많은 것 같다. 어떤 방식으로 해결해야 하는 지 아직 판단은 되지 않지만 문제를 많이 풀어보면서 이에 대한 감을 잡는 것도 중요해 보인다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/05/01/일 JS 복습", "url": "/posts/220501til/", "categories": "TIL/2022, 05", "tags": "til, javascript, algorithm", "date": "2022-05-01 00:00:00 +0900", "snippet": "220501 Today I learned! 스터디 프로젝트 JS 복습 백준 문제 풀이1. Fact(1) JS 복습 내일 치루는 시험 대비 JS 기초, JS 심화 복습 변수 데이터 타입 메서드 반복문, 조건문 DOM , Event 정리본 Poiema 챕터 12까지(2) 백준 문제 풀이 2493 탑 문제풀이 Stack2. Feeling이번에 프엔 스터디 친구들과 시험 성적에 대한 내기를 했기 때문에, 이번 시험은 중요하다.. 🙃 그래서 기초부터 다시 천천히 공부할 생각으로 Poiema 블로그 글을 읽다 보니 오히려 내가 수업내용을 정리했던 내용들을 볼 시간이 적었다. 시험 외적인 공부를 한 느낌이지만….ㅎㅎ 그래도 예전엔 이해하기 어려웠는데 이번에 다시 읽어보니 술술 읽혔다.Stack 자료구조관련 한 문제를 안 푼지 오래된 것 같아서 Stack 카테고리에 있는 문제를 풀었다. 그런데, 어떤 자료구조를 사용해야 할 지 미리 알고 푸니까 너무 쉽게 풀린 느낌이 없잖아 있었다. 이렇게 연습하면 안되나 싶기도 하고..3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/30/토 CSS 강의 복습", "url": "/posts/220430til/", "categories": "TIL/2022, 04", "tags": "til, css, algorithm", "date": "2022-04-30 00:00:00 +0900", "snippet": "220430 Today I learned! 스터디 프로젝트 CSS 강의 복습 백준 문제 풀이1. Fact(1) CSS 강의 복습 강의링크 Section 3: Flex로 반응형 페이지 만들기를 복습 겸 다시 구현혼자 구현하지 못한 코드\t&lt;!-- modal-switch --&gt; &lt;input type=\"checkbox\" id=\"modal-switch\"&gt;\t\t&lt;label for=\"modal-switch\"&gt; &lt;!-- 이런 텍스트는 안써도 되지만 나중에 접근성을 생각한다면, 살려주는 게 좋다. --&gt; &lt;!-- 대신 CSS로 안보이게 처리한다. --&gt; &lt;span&gt;modal열고 닫기&lt;/span&gt;\t\t&lt;/label&gt; \t\t&lt;!-- modal --&gt;\t\t&lt;div class=\"modal\"&gt; &lt;div class=\"dialog\"&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Exercitationem placeat eveniet esse dolorem nihil molestiae iste dignissimos? Ad accusantium possimus earum, hic veniam voluptates culpa sapiente, in repudiandae dolor quae. Modi numquam eos nesciunt! Cum fugit ipsam quam ex, eius ut quod explicabo praesentium quibusdam minus? Voluptatem est laudantium fugiat. Alias, molestias ab labore accusamus cumque minima, architecto ipsam enim voluptate sunt eos voluptates explicabo iusto eum omnis inventore aliquam corporis nesciunt consequatur nemo odit voluptatibus excepturi quasi cupiditate! Ratione ab aperiam quisquam repellat. Dolorum, voluptate animi, ratione dolore nostrum quis numquam delectus provident facilis explicabo maxime ipsum, necessitatibus maiores! &lt;/div&gt; &lt;/div&gt;.modal { display:none; /* 헤더에는 공간을 주지 않기 위함 */ top:80px;}/* ~ 결합자는 형제, 즉 첫 번째 요소를 뒤따르면서 같은 부모를 공유하는 두 번째 요소를 선택한다. */#modal-switch:checked ~ .modal { display:flex;}/* 상단으로 이동 *//* search form에서 margin-right를 줘서 공간을 배분해준다. */label[for=\"modal-switch\"] { display: inline-flex; align-items: center; justify-content: center; position:absolute; top:1.3rem; right: 1rem; width: 40px; height: 40px;}/* checkbox와 lable에 있는 span태그에 있는 문구를 안보이게 한다. *//* 스크린 리더, SEO 등의 이유로 display:none;, width:0;등의 사용을 피했다. */#modal-switch,label[for=\"modal-switch\"] span { overflow: hidden; position: absolute; width: 1px; height: 1px; opacity: 0; top: 0; }/* 가상 요소로 클릭할 아이콘을 추가한다. *//* 가상요소로 추가된 \"⚑\" 또한 라벨이 된다. */label[for=\"modal-switch\"]:before { content: \"⚑\"; font-size: 2rem;}#modal-switch:checked ~ label[for=\"modal-switch\"]:before { color: dodgerblue;} modal창을 css로 구현하기체크박스를 누르면 modal창이 보이게 된다. 라벨과 가상요소를 이용하여 가상요소를 클릭할 시 modal창이 보이게 한다. 가상요소를 제외한 나머지는 사용자에게 보이지 않도록 한다.(2) 백준 문제 풀이 24954 물약 구매 문제풀이 순열, 구현2. Feeling4월 마지막날! 벌써 5월이라니 시간이 정말 빠른 것 같다. 이제 1학기 교육과정의 후반부를 달리고 있다. 1학기는 기초지식을 탄탄하게 쌓고싶다. 작동원리를 이해하고 코드를 구현하고 싶다고 해야하나.. 그런데 이런 지식이 많이 부족한 것 같아서 남은 기간 + 방학동안은 기초를 닦고싶다.또한, 오늘 반응형 웹페이지를 혼자 구현해보면서 좀 더 공부해야할 부분을 찾았다. CSS 선택자 SEO를 고려한 웹사이트 구현 방법3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 강의에서 학습한 flex-website 혼자 제작하기 ` Success 😎`   1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/29/금 스터디 프로젝트 중간 발표", "url": "/posts/220429til/", "categories": "TIL/2022, 04", "tags": "til, javascript, react, algorithm, project, WaZaByo", "date": "2022-04-29 00:00:00 +0900", "snippet": "220429 Today I learned! 스터디 프로젝트 스터디 프로젝트 발표 백준 문제 풀이1. Fact(1) 스터디 프로젝트 로컬스토리지를 연동했다. 처음에는 컴포넌트에서 로컬 스토리지를 저장했는데, 그러면 다른 컴포넌트에 전달하기 어렵다는 사실을 알게 되었다. 그래서 로컬스토리지를 저장하는 것을 App.js로 이동시켰다. 데이터를 저장하는 로직을 대폭 수정했다. 이전에는 모든 항목별 리스트에 저장했다면 객체를 활용하여 통합했다. 컴포넌트 구조를 변경했다. 이전: App.js &lt;= Button. js &lt;= Modal.js &lt;= Card.js 현재: App.js &lt;= Button.js , Card.js &lt;= Modal.js (2) 백준 문제 풀이 24955 숫자 이어 붙이기 문제풀이 DFS2. Feeling검색형 개발자가 되어가고 있다.. 그래도 내가 처음에 기획했던 것의 대부분의 기능은 구현했다!현재 2번과 3번의 데이터수정을 아직 구현하지는 못했지만, 다음 주에 구현하면 목표대로 프로젝트가 끝날 수 있을 것 같다. 처음에 프로젝트 시작할 때는 정말 리액트에 대해 하나도 모르는 것 같아서 막막했지만 하면 된다는 걸 느끼고 있다. 확실히 혼자 삽질하면서 배우는 게 많은 것 같다 😉3. Finding 리액트에서 LocalStorage CRUD(1) 삽질의 시작: 여러개의 리스트로 데이터를 저장유저가 링피트 플레이 내역을 기록하면 해당 데이터를 Local Storage에 저장해야 했다. 저장해야할 데이터는 다음과 같다. 데이터 데이터 타입 (예시) 반영된 DB id int (예시: 1) countLocal = [0, 1, 2] 날짜 date (예시: 2022-04-28) dateLocal = [””, 2022-04-29, 2022-04-12] 플레이 시간 text (예시: 2시간 30분) timeLocal = [””, ‘1시간 20분’, ‘1시간 10분’] 소모 칼로리 int (예시 500) carloriesLocal = [””, 200, 300] 처음에 데이터를 저장하는 방법 자체를 잘못생각했다. 각각의 필드를 따로 따로 리스트 형태로 저장한 것이다.// components/Modal.js function Modal({ show, hide }) { /* Read: JSON으로 저장된 파일 파싱해서 가져온다. 데이터가 없으면 오류가 발생하기 때문에 빈 데이터를 처음에 추가한다. Create, Update: set을 통해 데이터를 수정, 추가할 수 있다. */ const [count, setCount] = useState( () =&gt; JSON.parse(localStorage.getItem(\"countInLocal\")) || [0] ); const [dateList, setdateList] = useState( () =&gt; JSON.parse(localStorage.getItem(\"dateInLocal\")) || [\"\"] ); const [timeList, settimeList] = useState( () =&gt; JSON.parse(localStorage.getItem(\"timeInLocal\")) || [\"\"] ); const [caloriesList, setcaloriesList] = useState( () =&gt; JSON.parse(localStorage.getItem(\"caloriesInLocal\")) || [\"\"] ); /* Create, Update: useEffect를 활용하여 데이터가 바뀔 때 자동으로 저장한다. 특정 데이터를 Json파일로 변환해서 문자열 형태로 저장한다. */ useEffect(() =&gt; { localStorage.setItem(\"countInLocal\", JSON.stringify(count)); }, [count]); useEffect(() =&gt; { localStorage.setItem(\"dateInLocal\", JSON.stringify(dateList)); }, [dateList]); useEffect(() =&gt; { localStorage.setItem(\"timeInLocal\", JSON.stringify(timeList)); }, [timeList]); useEffect(() =&gt; { localStorage.setItem(\"caloriesInLocal\", JSON.stringify(caloriesList)); }, [caloriesList]);이와 같이 데이터를 저장하면 단점이 있다. 코드가 길어진다. 데이터를 update하거나 삭제하기 힘들었다. 즉, 데이터가 분산 저장되어 접근,관리가 힘들었다.그래서 객체 방식으로 수정했다.또한, Local Storage는 상위에서 다루어야 하위 컴포넌트들에게 props로 전달하기 쉽기 때문에 App.js로 코드를 이동시켰다.(2) 객체로 데이터를 저장한다.// App.jsimport { useEffect, useState } from \"react\";import Button from \"./component/Button\";import Card from \"./component/Card\";import Sidebar from \"./component/Sidebar\";// App.js에서 LocalStorage를 관리한다. 그리고 해당 데이터들을 Button과 Card 컴포넌트에게 전달한다.function App() { // read, create, update const [data, setData] = useState( () =&gt; JSON.parse(localStorage.getItem(\"data\")) || [\"\"] ); // delete const deleteData = (num) =&gt; { const newData = data.filter((d) =&gt; d.id !== num); setData(newData); }; // create, update useEffect(() =&gt; { localStorage.setItem(\"data\", JSON.stringify(data)); }, [data]); return ( &lt;div&gt; &lt;Button data={data} setData={setData} /&gt; &lt;Card data={data} setData={setData} deleteData={deleteData} /&gt; &lt;Sidebar data={data} /&gt; &lt;/div&gt; );}export default App;// Modal.js// Createconst formSubmit = (event) =&gt; { hide(); event.preventDefault(); const newData = { id: index, date: date, time: time, calories: calories }; const realData = [...data]; realData.push(newData); setData(realData); changeIndex(); setDate(\"\"); setTime(\"\"); setCalories(\"\");}; Modal에서 데이터를 객체의 리스트로 저장한다. [””, {id:1 , date:2022-04-28, time: 20분, caloreis: 120}, {id:2, date:2022-04-29, time:30분 calories: 150}] // Card.js// DELETEconst deleteData = (num) =&gt; { const newData = data.filter((d) =&gt; d.id !== num); setData(newData);}; 카드 컴포넌트에서는 전달받은 데이터들을 Read하여 카드 컴포넌트를 생성한다. 삭제는 위의 방식처럼 삭제버튼을 누른 컴포넌트의 id를 인식하여 해당 id만 필터링한 리스트를 새로 생성하고 이를 데이터에 반영한다4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 강의에서 학습한 flex-website 혼자 제작하기 in progress 🚀 현재 Section2까지 진행한 상태이다.오는 주에 Section3를 할 예정이다. 1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/28/목 JavaScript심화, 스터디 프로젝트", "url": "/posts/220428til/", "categories": "TIL/2022, 04", "tags": "til, javascript, algorithm, project, WaZaByo", "date": "2022-04-28 00:00:00 +0900", "snippet": "220428 Today I learned! JavaScript 심화 스터디 프로젝트 백준 문제 풀이1. Fact(1) JavaScript 심화 어제 학습한 내용을 토대로 다양한 기능을 혼자 구현하며 학습했다. 특정 버튼을 클릭하면 해당 페이지의 배경과 글자 색이 바뀐다. 해당 버튼은 클릭하면 바디태그의 클래스가 변경된다. serAttribute 욕설로 설정된 단어 리스트를 만들고 해당 단어를 input 창에 입력하면 *로 필터링 되어 보여준다. 유저가 입력한 문자열을 변수에 저장한다. 욕설 단어 리스트를 forEach를 통해 각 단어들을 replaceAll한다. // badWords에 포함된 단어가 입력될 경우, '**'으로 변환하여 output에 출력한다.function filterMessage(event) { let filteredInput = userInput.value; badWords.forEach((word) =&gt; { filteredInput = filteredInput.replaceAll(word, \"**\"); }); output.innerText = filteredInput;} input창에 데이터를 입력하고 해당 form을 submit을 하면 입력한 데이터에 대한 내용을 보여주는 카드컴포넌트를 새로 생성한다. submit할 때 새로고침 되지 않기 위해 event.preventDefault();을 한다. element 생성, innerText 변경, DOM 트리에 추가 사용자가 입력한 내용을 기반으로 to-do 리스트를 만든다. input 값이 비어있을 경우 submit을 하면 alert을 보여준다. element 생성, innerText 변경, DOM 트리에 추가 랜덤한 배경을 가지고 현재 시간을 보여준다. lodash를 활용하여 랜덤으로 숫자를 뽑고 해당 이미지를 보여준다. Date객체를 활용하여 현재 시간을 가져온다. 만약 한자리 수면 앞에 0을 붙인다. setInterval()함수를 통해 1초에 한번씩 시간을 보여주는 함수를 실행한다. // 랜덤 배경const bodyTag = document.querySelector(\"body\");const num = _.random(1, 6);bodyTag.style.backgroundImage = `url('./images/${num}.jpg')`;// 시간을 보여주는 함수const timeDiv = document.querySelector(\"#time\");const displayTime = function () { const now = new Date(); const hours = now.getHours(); const hoursDevide = hours % 12; const minutes = now.getMinutes(); const seconds = now.getSeconds(); const timeNow = hours &lt; 12 ? \"오전\" : \"오후\"; const hoursNow = hoursDevide.toString().length === 1 ? `0${hoursDevide}` : hoursDevide; const minutesNow = minutes.toString().length === 1 ? `0${minutes}` : minutes; const secondsNow = seconds.toString().length === 1 ? `0${seconds}` : seconds; timeDiv.innerHTML = `${timeNow} ${hoursNow} : ${minutesNow} : ${secondsNow}`;}; 정리본(2) 스터디 프로젝트 링피트 기록을 입력하는 모달창에서 받은 내용을 submit하면 해당 내용을 갖고 있는 카드 컴포넌트가 생성된다. onChange 속성을 이용하여 input의 데이터를 기록 submit하는 순간 유저가 입력한 데이터를 리스트에 추가한다. 리스트의 인덱스도 기록하여 해당 인덱스를 통해 데이터에 접근한다. countList(인덱스), dateList(플레이한 날짜), timeList(플레이 시간), caloriesList(소모 칼로리)에 기록하여 데이터를 관리한다. 카드 컴포넌트의 x를 누르면 해당 카드가 삭제된다. 해당 카드의 count가 0이 된다. 0이된 인덱스는 카드로 표시를 하지 않는다. 현재 구현 로직: 기록을 추가하는 버튼 클릭 =&gt; 모달창 =&gt; 링피트 플레이 내용 입력 =&gt; 제출 =&gt; 해당 내용을 보여주는 카드 컴포넌트 생성 props를 활용해서 데이터를 작성하다보니 이상한 구조가 되었다. 한번 전체적으로 수정해야할 것 같다. 😅 Index. js &lt;= App.js &lt;= Button.js &lt;= Modal.js &lt;= Card.js (3) 백준 문제 풀이 1916 최소 비용 구하기 문제풀이 그래프2. Feelingreact에 대한 내용을 다 까먹었다고 생각했는데, 그래도 어떻게 하다보니 기능이 구현되고 내가 생각했던 것들이 진짜 웹사이트로 보이는 것 같아서 신기하다.그런데 현재 큰 문제점이 있다. 우선 내일 프로젝트 중간 발표 이후에 다 수정을 해야 할 것 같다. props를 활용해서 데이터를 작성하다보니 컴포넌트가 이상한 구조가 되었다. Index. js &lt;= App.js &lt;= Button.js &lt;= Modal.js &lt;= Card.js 위와 같이 단방향 구조를 가지게 되었다. import Button from \"./component/Button\";function App() { return ( &lt;div&gt; {/*Button 컴포넌트의 자식으로 Modal컴포넌트가 있고 Modal컴포넌트의 자식으로 Card 컴포넌트가 있다. */} &lt;Button/&gt; &lt;/div&gt; );}export default App; 유저가 입력한 데이터 항목에 따른 리스트를 갖고 있어서 데이터 관리가 불편하다. 한번에 모아서 객체 형식으로 저장을 해야 할 것 같다. (코드도 너무 길다… )function Modal({ show, hide }) { const [date, setDate] = useState(\"\"); const [time, setTime] = useState(\"\"); const [calories, setCalories] = useState(\"\"); {/* Card 컴포넌트에 보내줄 데이터 리스트들 */} const [count, setCount] = useState(0); const [dateList, setdateList] = useState([\"\"]) const [timeList, settimeList] = useState([\"\"]) const [caloriesList, setcaloriesList] = useState([\"\"]) {/* Card 컴포넌트에 보내줄 데이터 삭제 함수 */} {/* Card 컴포넌트에 보내줄 데이터 삭제 함수 실제로 데이터를 삭제하는 것이 아니라 인덱스를 0으로 바꿔주고 0은 카드 컴포넌트로 생성하지 않는다. */} const deleteCard = (num) =&gt; { const countList = [...count]; countList[num] = 0; setCount(countList); }; {/* 사용자가 인풋 데이터를 입력하면 해당 내용을 저장한다. */} const changeDate = (event) =&gt; { setDate(event.target.value); }; const changeTime = (event) =&gt; { setTime(event.target.value); }; const changeCalories = (event) =&gt; { setCalories(event.target.value); }; {/* 제출 했을 때 발생하는 함수 */} const formSubmit = (event) =&gt; { hide(); event.preventDefault(); {/*현재 유저가 입력한 데이터를 리스트에 추가한다. */} const dateArr = [...dateList]; const timeArr = [...timeList]; const caloriesArr = [...caloriesList]; dateArr.push(date); timeArr.push(time); caloriesArr.push(calories); setdateList(dateArr); settimeList(timeArr); setcaloriesList(caloriesArr); const countList = [...count]; let lastCount = countList.length; countList.push(lastCount); setCount(countList); setDate(\"\"); setTime(\"\"); setCalories(\"\"); }; return ( &lt;div&gt; &lt;Card count={count} date={dateList} time={timeList} calories={caloriesList} deleteCard={deleteCard} &gt;&lt;/Card&gt;\t\t{/*... 생략 */} &lt;/div&gt; );} 새로고침을 하면 데이터가 다 삭제된다. 로컬스토리지를 활용해야할 것 같다.3. Finding 잊고 있었던 리액트 기초! JS 문법은 {}를 써야한다. props도 {}안에 써야 한다.import PropTypes from \"prop-types\";import styled from \"styled-components\";function Card({ count, date, time, calories, deleteCard }) { return ( &lt;div&gt; &lt;StyledDiv&gt; &lt;StyledCardContainer&gt; {count.map((i) =&gt; i === 0 ? null : ( &lt;StyledCard key={i}&gt; &lt;StyledP1&gt;{date[i]} &lt;/StyledP1&gt; &lt;StyledDeleteButton onClick={() =&gt; deleteCard(i)}&gt; ✖ &lt;/StyledDeleteButton&gt; &lt;StyledP2&gt;{calories[i]} kcal&lt;/StyledP2&gt; &lt;StyledP3&gt;{time[i]} &lt;/StyledP3&gt; &lt;/StyledCard&gt;) )} &lt;/StyledCardContainer&gt; &lt;/StyledDiv&gt; &lt;/div&gt; );} 컴포넌트를 중복 render하면 안된다.import Button from \"./component/Button\";import Modal from \"./component/Modal\";import Card from \"./component/Card\";function App() { return ( &lt;div&gt; {/* Button 컴포넌트의 자식으로 Modal컴포넌트가 있고 Modal컴포넌트의 자식으로 Card 컴포넌트가 있다. */} {/* 따라서 Card 컴포넌트와 Modal 컴포넌트는 작성하면 안된다. */} &lt;Card /&gt; &lt;Modal /&gt; &lt;Button /&gt; &lt;/div&gt; );}export default App;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 강의에서 학습한 flex-website 혼자 제작하기 in progress 🚀 현재 Section2까지 진행한 상태이다.오는 주에 Section3를 할 예정이다. 1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/27/수 JavaScript심화, 스터디 프로젝트", "url": "/posts/220427til/", "categories": "TIL/2022, 04", "tags": "til, javascript, algorithm, WaZaByo, project", "date": "2022-04-27 00:00:00 +0900", "snippet": "220427 Today I learned! JavaScript 심화 스터디 프로젝트 백준 문제 풀이1. Fact(1) JavaScript 심화 DOM의 객체를 선택하고 변경하는 일련의 과정과 이벤트에 대해 학습했다. select (선택) 변화를 줄 객체를 선택한다. manipulution (변경) 객체 생성 및 추가 객체 변경 (속성) Event 특정 이벤트가 발생하면, 할 일 (함수)을 등록한다. EventTarget.addEventListener(type, listener[, options]) 정리본(2) 스터디 프로젝트 리액트를 활용한 토이프로젝트 노마드 코더 리액트 강의에서 학습한 내용을 활용하여 웹사이트 제작 운동 기록을 입력할 모달창 구현완료 props를 활용하여 button 컴포넌트와 modal컴포넌트를 연동 props로 함수를 보낼 수도 있다는 것도 알게 되었다! // button.jsfunction Button() { // modalOn이 true이면 modal창이 보인다. const [modalOn, setModalOn] = useState(false); const openModal = () =&gt; setModalOn(true); const closeModal = () =&gt; setModalOn(false); return ( &lt;div&gt; &lt;StyledButton onClick={openModal}&gt;+&lt;/StyledButton&gt; &lt;Modal show={modalOn} hide={closeModal}/&gt; &lt;/div&gt; );}(3) 백준 문제 풀이 16562 친구비 문제풀이 Union-Find2. FeelingVanila JS로 웹페이지를 한 번 구현해봐서 수업 내용은 수월하게 넘어갈 수 있었다.그런테 스터디에서 진행중인 프로젝트에는 하나의 큰 산이 남아있다… 버튼을 클릭하여 form이 있는 모달창을 띄우는 것까지는 했는데, submit을 하면 카드 컴포넌트를 생성하고 input으로 받은 데이터를 기록해야 한다. 그런데 어떻게 구현해야할지 막막하다. 🤔3. Finding 이벤트 캡쳐와 버블링에 대해 알게되었다!모달창을 띄운 후 모달창 외부를 클릭하면 창이 자동으로 꺼지게 설정하고 싶었다. 그런데 모달창내부 태그가 모달창 외부 태그보다 하위 태그이기 때문에 모달창내부를 클릭해도 모달창이 꺼지게 되는 상황이 발생했다. 해결하기 위해 더 알아보던중 이벤트 캡쳐와 버블링에 대한 개념을 알게 되었다. 공식문서이벤트 버블링이란, 특정 객체에 이벤트가 발생했을때 해당 객체보다 상위의 요소들로 전달되는 특성을 말한다. body &lt;= div &lt;= button 와 같은 구조일 때, 아래에 있는 button 태그에서 이벤트가 발생하면 body태그까지 이벤트가 전달된다.이벤트 캡쳐링이란, 버블링과 반대로 상위객체들로 부터 하위 요소에게 전달된다.이벤트가 전파되는 것을 막기위해서는 Event.stopPropagation()을 사용해야 한다. 공식문서// modal.js//... 생략 &lt;div&gt; {show ? ( &lt;StyledContainer onClick={hide}&gt; {/* 이벤트 전파 막기! 클릭 이벤트가 발생해도 상위 객체는 모른다! (전파되지 않는다.) */ } &lt;StyledModal onClick={(event) =&gt; event.stopPropagation()}&gt; &lt;form onSubmit={formSubmit}&gt;\t\t\t\t... &lt;/form&gt; &lt;/StyledModal&gt; &lt;/StyledContainer&gt; ) : null} &lt;/div&gt;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 강의에서 학습한 flex-website 혼자 제작하기 in progress 🚀 현재 Section2까지 진행한 상태이다.오는 주에 Section3를 할 예정이다. 1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/26/화 JavaScript기초", "url": "/posts/220426til/", "categories": "TIL/2022, 04", "tags": "til, javascript, algorithm", "date": "2022-04-26 00:00:00 +0900", "snippet": "220426 Today I learned! JavaScript 기초 백준 문제 풀이1. Fact(1) JavaScript 기초 JavaScript 기초 문법 함수: 함수는 일급객체이다! 선언식과 표현식 Rest operator와 spread operator arrow 함수 배열 관련 메서드 객체 관련 메서드 객체 관련 ES6 문법 (속성명 축약, 메서드명 축약, 구조 분해 할당 등) Json JSON.parse() 과 JSON.stringify() this 정리본(2) 백준 문제 풀이 1976 여행 가자 문제풀이 BFS2. Feeling파이썬 문법을 공부하다가 자바스크립트 문법을 보니 확실히 불편하다. 파이썬은 배열만들기가 얼마나 쉬운데요,..😅또한, 이전에 파이썬으로 풀었던 전기버스 문제를 자바스크립트로 푸는 것이 과제 중에 하나였는데, 과거의 나 어떻게 풀었니..? 알고리즘 구현 문제 연습을 해야할 것 같다..우선 배운 내용을 복습하면서 코드로 직접 많이 작성해보려고 노력 중이다. 이번에 자바스크립트에 대해 다시 한 번 정리하니까 너무 좋다…ヽ(✿ﾟ▽ﾟ)ノ3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 강의에서 학습한 flex-website 혼자 제작하기 in progress 🚀 현재 Section2까지 진행한 상태이다.오는 주에 Section3를 할 예정이다. 1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/25/월 JavaScript기초", "url": "/posts/220425til/", "categories": "TIL/2022, 04", "tags": "til, javascript, algorithm", "date": "2022-04-25 00:00:00 +0900", "snippet": "220425 Today I learned! 시험 JavaScript 기초 백준 문제 풀이1. Fact(1) JavaScript 기초 JavaScript 소개 DOM을 조작할 수 있는 유일한 프로그래밍 언어 JavaScript 기초 문법 변수와 식별자 let, const, var의 차이점 호이스팅 데이터 타입 원시 타입, 참조 타입 Infinity, NaN, undefined, null 연산자 == 와 ===의 차이 (암시적 형 변환) 3항 연산자 조건문 if문, switch 문 반복문 while, for, for…in, for…of 정리본(2) 백준 문제 풀이 15686 치킨 배달 문제풀이 BFS2. Feeling시험을 보고 급하게 진도를 나가느라, 정신 없었다. 이전에 스터디에서 따로 JS에 대해 공부하지 않았다면, 이해하기 힘들었을 것 같다. 이번에는 JS에 대해 제대로 공부해보려고 한다. 수업 내용 이외에도 MDN 공식문서도 많이 읽어 봐야겠다.또한, 다음주까지 진행되는 JS 수업이 끝나면 다시 DOM을 깨우치다책을 읽을 생각이다. 백준에서 node.js로 알고리즘 문제도 풀어봐야지..😉3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 강의에서 학습한 flex-website 혼자 제작하기 in progress 🚀 현재 Section2까지 진행한 상태이다.오는 주에 Section3를 할 예정이다. 1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/24 RESTful API 복습, Union-Find 최적화 방법", "url": "/posts/220424til/", "categories": "TIL/2022, 04", "tags": "til, django, algorithm", "date": "2022-04-24 00:00:00 +0900", "snippet": "220423 Today I learned! RESTful API 복습 백준 문제 풀이 (Union-find 최적화 방법 학습)1. Fact(1) RESTful API 복습 내일 치루는 시험 준비 수, 목에 진행했던 workshop과 금요일의 관통프로젝트를 혼자 구현했다. 1:N, M:N의 관계형 DB를 전달하는 API 클래스 재정의를 통한 fields override 정리본(2) 백준 문제 풀이 1717 집합의 표현 문제풀이 Uniton-Find 최적화에 대해 학습했다.2. Feeling내일 치루는 RESTful API 시험 준비를 했다. 구현위주의 시험이기 때문에 혼자서 코드를 작성하는 것을 가장 중점으로 진행했다.VS코드의 자동완성기능 넘나 편한 것..백준 문제의 경우, 시간초과가 연속으로 8번 정도 났다..😭😭 그래서 결국 구글링을 통해 최적화를 하는 방법을 찾아보았다.그런데!!!!!!import sysinput = sys.stdin.readline`최적화고 뭐고 위의 코드를 통해 입력 시간을 줄여야 하는 문제였다. 그래도 Union-Find최적화에 대해 학습할 수 있는 경험이여서 좋았다.3. Finding Union-find 최적화 방법시간초과가 해결되지 않아서, 최적화하는 방법을 찾아보았다. 참고하면 좋은 글 1 참고하면 좋은 글 2최적화를 해야 하는 이유 트리 구조가 연결리스트의 형태인경우, 원소의 개수가 N일때 트리의 높이가 N-1이므로 시간복잡도가 O(N)이다.이 문제에서는 N이 최대 1,000,000이기 때문에, 이를 고려하고 코드를 작성해야 한다.Find 연산 최적화경로 압축(Path Compression)# 경로 압축을 하지 않은 코드 # 단순하게,root만 찾기 때문에 트리의 높을 수록 시간복잡도가 높아진다. def find_set(x): while set_root[x] != x: x = set_root[x] return x# 경로 압축을 한 코드# root를 찾으면서 만난 모든 값의 부모를 root로 바꾼다. # 추후, find 연산을 다시 수행할 때, 중복되는 연산을 줄여준다.(바로 root를 찾을 수 있게 해준다.)def find_set(x): if set_root[x] != x: set_root[x] = find_set(set_root[x]) return set_root[x]Union 연산 최적화union-by-rank(union-by-height)# union-by-rank을 하지 않은 코드def union(a, b): root_a = find_set(a) root_b = find_set(b) if root_a != root_b: set_root[root_b] = root_a# union-by-rank을 한 코드# 합집합 연산을 할 때, 높이가 더 낮은 트리를 더 높은 트리 밑에 넣는다.# 이는 트리가 균형잡힌 형태가 되도록 강제한다. (트리의 높이가 같을 때만 트리의 높이가 증가한다.)rank = [0]*(N+1) # 각각의 집합은 rank를 갖는다. (초기값은 0) =&gt; tree의 높이를 나타낸다. def union(a, b): root_a = find_set(a) root_b = find_set(b) if root_a != root_b: if rank[root_a] &lt; rank[root_b]: set_root[root_a] = root_b # a_root의 root를 root_b로 변경한다. else: set_root[root_b] = root_a # b_root의 root를 root_a로 변경한다. # 만약 높이가 같다면 위에서 합친 후 높이를 +1한다. if rank[root_a] == rank[root_b]: rank[root_a] += 14. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 강의에서 학습한 flex-website 혼자 제작하기 in progress 🚀 현재 Section2까지 진행한 상태이다.오는 주에 Section3를 할 예정이다. 1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/23 CSS 강의 복습, 스터디 프로젝트 시작", "url": "/posts/220423til/", "categories": "TIL/2022, 04", "tags": "til, css, algorithm, WaZaByo, project", "date": "2022-04-23 00:00:00 +0900", "snippet": "220423 Today I learned! CSS 강의 복습 스터디 프로젝트 시작 백준 문제 풀이1. Fact(1) CSS 강의 복습 강의링크 Section 2: Flex UI만들기를 혼자서 제작했다.혼자서 구현하지 못한 코드.user-content { overflow: hidden; text-overflow: ellipsis; white-space: nowrap;} text가 너무 길때, 말줄임표로 표시하는 방법이다. 공식문서1 공식문서2overflow 속성은 요소의 콘텐츠가 너무 커서 요소의 블록 서식에 맞출 수 없을때 처리법을 나타낸다. hidden일 경우 보이지 않는다. 이런 overflow 속성이 효력을 갖기 위해서는 white-space: nowrap로 설정해야 한다.text-overflow는 hidden overflow일 경우, 유저에게 어떻게 어떤 신호를 보내줄지 결정하는 속성이다. ellipsis의 경우 말줄임표 표시가된다.@media (min-width: 600px) { .card { overflow-x: hidden; } .card-list { display: flex; flex-wrap: wrap; margin: 0 -1rem; } .card-item { width: 50%; padding: 0 1rem; }} 반응형 웹을 구현할때, 카드 컴포넌트들을 한 열에 여러개 배치하기 위함이다.overflow-x는 가로 스크롤이 생기는 것을 방지하기 추가한 속성이다. over-flow: hidden;을 하게 되면, 내용이 잘려서 스크롤 바가 나타나지 않는다.margin: 0 -1rem;을 주는 이유는 양쪽에 생긴 공백을 제거하기 위함이다. (음수 마진을 사용하면 컨텐츠를 당기는 효과가 있다.)(2) 스터디 프로젝트 시작 리액트를 활용한 토이프로젝트 노마드 코더 리액트 강의에서 학습한 내용을 활용하여 웹사이트 제작 컴포넌트 구조 구상 &amp; Button component 생성 리액트 복습 (다 잊어버렸다….😓) 프로젝트 시작 방법 component 생성 Props, State의 활용 (3) 백준 문제 풀이 2146 다리 만들기 문제풀이2. FeelingCSS lay-out을 혼자 만들어 보면서, 실제로 머릿 속에 상상한 것을 구현할 수 있는데 도움이 많이 되는 것 같다.리액트를 활용한 프로젝트의 경우.. 현재 진행이 엄청 더디다. 왜냐하면 현재 리액트 몰?루?상태이기 때문이다. 망각곡선이시여..‘까짓것 지금부터 다시 배우면 되지…‘라는 생각으로 하나하나씩 시작하고 있다. 그래도 이 코드만 작성한 나.. 제법 실망스러워요 🥺import styled from \"styled-components\";function Button() { return ( &lt;div&gt; &lt;StyledButton&gt;+&lt;/StyledButton&gt; &lt;/div&gt; );}const StyledButton = styled.button` border: none; border-radius: 50%; background-color: #ff9300; color: white; width: 50px; height: 50px; font-size: 2.5rem; position: fixed; top: 80%; right: 10%; &amp;:hover { cursor: pointer; background-color: #ffd200; }`;export default Button;3. Finding CSS in JS (styled-components 라이브러리 활용법)리액트에서 CSS를 어떻게 적용해야 할 지, 찾아보다가 CSS in JS 방식을 발견하게 되었다. 참고한 블로그 글CSS in JS 방식은 다음과 같다. HTML, CSS, JavaScript 3개로 분리하지 않는다. 대신 component 단위로 제작한다. 각 component에 HTML, CSS, JavaScript을 다 넣는다.즉, CSS, HTML을 JavaScipt로 코드를 작성한다. styled-components 라이브러리는 생각보다 손쉽게 사용할 수 있었다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 pause 🤦‍♀️ 잠시 중단! 강의에서 학습한 flex-website 혼자 제작하기 in progress 🚀 현재 Section2까지 진행한 상태이다.오는 주에 Section3를 할 예정이다. 1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/22 관통프로젝트, 스터디 발표", "url": "/posts/220422til/", "categories": "TIL/2022, 04", "tags": "til, django, project, algorithm, WaZaByo", "date": "2022-04-22 00:00:00 +0900", "snippet": "220422 Today I learned! 관통프로젝트 스터디 발표 백준 문제 풀이1. Fact(1) 관통프로젝트 DB 설계를 활용한 REST API 설계 배우, 영화, 리뷰 데이터를 활용하여 REST API를 설계한다 배우: 영화 (M:N 관계) / 영화:리뷰(1:N 관계) 배우 데이터 조회 배우 전체 데이터 조회 (id, name) 특정 배우 조회 (id, name, movies-title) 영화 데이터 조회 영화 전체 데이터 조회 (title, overview) 특정 영화 조회 (id, title, overview, release_data, actors-name, review-title, review-content) 리뷰 데이터 조회, 생서, 수정, 삭제 리뷰 전체 데이터 조회 (title, content) 특정 리뷰 조회 (id, title, content, movie-title) 리뷰 추가 리뷰 삭제 리뷰 수정 (2) 스터디 발표 리액트를 활용한 토이프로젝트 노마드 코더 리액트 강의에서 학습한 내용을 활용하여 웹사이트 제작 프로젝트 주제 선정 이유, 기능 소개 등(3) 백준 문제 풀이 1197 최소 스패닝 트리 문제풀이2. Feeling오늘도 즐겁게 관통프로젝트에 참여했다. 이번에는 Navigator와 Driver의 역할을 잘 나눠서 진행한 것 같다.스터디 발표에서 좋은 피드백을 많이 받을 수 있었다. 또한, 다른 사람들의 주제를 보면서 나도 많이 배울 수 있었다..(●’◡’●)하지만 리액트로 내가 생각했던 것을 구현할 수 있을까에 대한 불안감이 한 켠에 있다. 일단 내일부터 조금씩 해야지..3. Finding 원하는 데이터를 출력하기 위해 클래스 내부에 새로운 클래스를 정의한다.1:N, N:M 관계의 데이터를 불러올 때 원하는 필드만 적용하기 위해서 클래스 내부에 새로운 클래스를 정의해야 한다. (오버라이드).# moveis/serializers/actor.pyfrom rest_framework import serializersfrom ..models import Actor,Moviefrom .movie import MovieSerializerclass ActorListSerializer(serializers.ModelSerializer): class Meta: model = Actor fields = ('id','name',)class ActorSerializer(serializers.ModelSerializer): # title만 출력하기 위해 내부에 새로운 클래스 정의 class MovieSerializer(serializers.ModelSerializer): class Meta: model = Movie fields = ('title',)\t # 필드 재정의(override) movies = MovieSerializer(many=True, read_only=True) class Meta: model = Actor fields = '__all__'# moveis/serializers/movie.pyfrom rest_framework import serializersfrom ..models import Movie,Actor, Reviewclass MovieListSerializer(serializers.ModelSerializer): class Meta: model=Movie fields=('title','overview',)class MovieSerializer(serializers.ModelSerializer):\t class ActorSerializer(serializers.ModelSerializer): class Meta: model = Actor fields = ('name',) class ReviewSerializer(serializers.ModelSerializer): class Meta: model = Review fields = ('title', 'content',) # 필드 재정의(override) actors = ActorSerializer(many=True, read_only=True) review_set = ReviewSerializer(many=True, read_only=True) class Meta: model=Movie fields='__all__'# moveis/serializers/review.pyfrom rest_framework import serializersfrom ..models import Review, Movieclass ReviewSerializer(serializers.ModelSerializer): class MovieSerializer(serializers.ModelSerializer): class Meta: model = Movie fields = ('title',) movie = MovieSerializer(read_only=True) class Meta: model = Review fields = '__all__' read_only_fields = ('movie',)4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 in progress 🚀   강의에서 학습한 flex-website 혼자 제작하기 not start   1일 1알고! 🔥     " }, { "title": "22/04/21 Django RESTapi 복습, 스터디 발표 자료 준비", "url": "/posts/220421til/", "categories": "TIL/2022, 04", "tags": "til, django, project, algorithm, WaZaByo", "date": "2022-04-21 00:00:00 +0900", "snippet": "220421 Today I learned! Django RESTapi 스터디 발표 자료 준비 백준 문제 풀이1. Fact(1) Django RESTapi Django의 Serializers를 활용하여 API를 구현하는 것을 연습했다. 음악 관련 API를 구현 (1:N 관계) 모든 가수의 정보를 반환 (id, name) 상세 가수의 정보를 생성 후 반환 (id, name, music, music의 개수) 모든 음악 정보를 반환 (id, title) 상세 음악 정보 반환( id, title, artist) 정리본(2) 스터디 발표 자료 준비 리액트를 활용한 토이프로젝트 노마드 코더 리액트 강의에서 학습한 내용을 활용하여 웹사이트 제작 어플리케이션 대한 발표 준비 (기획 발표) 어플리케이션 제작 의도 end 구현 기능 계획 end 와이어 프레임 제작 end (3) 백준 문제풀이 16234 인구 이동 문제 풀이2. Feeling이번주는 쉬어가는 주간인 것 같다. 다음주부터 다시 달리게 되겠지만! 🏃‍♀️🏃‍♂️3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 in progress 🚀   강의에서 학습한 flex-website 혼자 제작하기 not start   1일 1알고! 🔥 in progress 🚀   " }, { "title": "22/04/20 Django RESTapi", "url": "/posts/220420til/", "categories": "TIL/2022, 04", "tags": "til, django", "date": "2022-04-20 00:00:00 +0900", "snippet": "220420 Today I learned! Django RESTapi1. Fact(1) Django RESTapi HTTP 기본 개념에 대한 내용을 이해할 수 있었다. URI의 구성, HttpMethod API 기본 개념, RESTfulAPI의 기본규칙에 대해서 학습했다. 프로그램간에 데이터를 주고 받기 위해서 어떤 과정을 통해 이루어지는 지. 과거에 사람들은 어떻게 데이터를 주고받아왔는가. Serialize에 대한 이해 Django의 Serializers를 활용하여 API를 구현했다. Serialize, Deserialize 정리본2. Feeling통신에 대한 기초적인 CS 지식을 배울 수 있어서 좋았다. CS 지식은 너무 재밌다!그런데, 오늘은 이상하게 체력적으로 많이 힘들었다. 그래서 오늘 배운 내용만 복습하는 선에서 공부를 마쳤다. (워낙 양이 많아서 오래걸렸지만..ㅠㅠ)다음주 월요일에 시험을 보는데 아직 코드가 익숙하지 않아서 걱정이 된다.그리고 요즘 1일1알고를 못하고 거의 2일1알고를 하고 있는데 내일부터는 꼭…🙋‍♀️3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 in progress 🚀   강의에서 학습한 flex-website 혼자 제작하기 not start   1일 1알고! 🔥     " }, { "title": "22/04/19 Django M:N 관계 복습, 스터디 발표 준비", "url": "/posts/220419til/", "categories": "TIL/2022, 04", "tags": "til, django", "date": "2022-04-19 00:00:00 +0900", "snippet": "220419 Today I learned! Django DB M:N 복습 스터디 발표 준비 백준 문제1. Fact(1) Django DB M:N 관계 Django ORM을 통해 Django의 M:N 관계의 DB를 CRUD하는 것을 복습했다. 로그인, 로그아웃, 유저 프로필, 팔로우 기능이 있는 웹사이트를 혼자 구현했다. DJango DB 수업이 끝났기 때문에 전반적으로 내용을 다시 리마인드 했다. 정리본(2) 스터디 발표 준비 리액트를 활용한 토이프로젝트 노마드 코더 리액트 강의에서 학습한 내용을 활용하여 웹사이트 제작 어플리케이션 대한 발표 준비 (기획 발표) 어플리케이션 제작 의도 end 구현 기능 계획 ~ ing 와이어 프레임 제작 ~ing (3) 백준 문제 풀이 N과 M (9) ~ (12) 문제 풀이2. Feeling오늘은 일정이 여유가 있는 날이였다. 그래서 이번에 어떤 웹사이트를 만들지 고민했다.스터디에서 노마드 코더 리액트 클론 코딩 강의를 통해 학습한 내용을 웹사이트를 만드는 짧은 프로젝트를 진행하고 있다. 지난, 스터디 프로젝트에서의 실패를 발판 삼아 각자 제작할 어플리케이션에 대해 고민할 시간을 가질 수 있었다. 이전에는 생각없이 코드 작성을 시작해서 배웠던 기능을 덕지덕지 붙여나갔다면, 이번에는 내가 원하는 서비스에 맞는 기능을 먼저 생각하고 구현을 하는 방식으로 진행할 것이다. 또한, saffy일정을 진행하면서 프로젝트를 진행하기 때문에 복잡한 프로젝트가 되지 않도록 하는것도 중요하다.이번에는 프로젝트 잘 준비해서 git에 올리고 싶다..😥(지난 프로젝트는 너무 부끄러운 결과물이기때문에 내 하드디스크에 고이… )3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 in progress 🚀   강의에서 학습한 flex-website 혼자 제작하기 not start   " }, { "title": "22/04/18 Django M:N 관계, CSS 강의", "url": "/posts/220418til/", "categories": "TIL/2022, 04", "tags": "til, django", "date": "2022-04-18 00:00:00 +0900", "snippet": "220418 Today I learned! Django DB M:N 학습 CSS 강의 (flex ui를 활용한 웹페이지 만들기 실습) 백준 문제1. Fact(1) Django DB M:N 관계 M:N관계를 갖는 데이터베이스를 구현하는 방법을 학습했다. 중개모델을 활용하거나 ManyToManyField를 사용하여 model을 생성하면된다. M:N 관계의 DB에서 데이터를 CRUD하는 ORM 문법을 배웠다. related_name속성을 활용한 역참조 키워드 add(), remove() M:N DB를 사용하는 몇가지 기능을 구현했다. 좋아요 기능 프로필 페이지와 팔로우 기능 정리본(2) CSS 강의 지난번에 제작했던 CSS ui를 활용하여 웹페이지를 제작했다. CSS 가상 클래스 :checked를 활용하여 모달기능을 구현할 수 있다. CSS 결합자를 활용하여 원하는 태그에 속성을 부여할 수 있다. Flex를 활용하여 웹사이트를 어떻게 구성하는지 학습할 수 있었다. width vsflex-grow flex-wrap을 활용하여 위에서부터 차례대로 웹사이트 요소를 놓는다. flex-order를 통해 요소의 순서를 변경한다. 수업 자료2. Feeling오늘 시험을 보고 바로 수업을 진행해서 좀 힘든 감이 있었다.그래도 오늘이 Django DB 마지막 수업이니까.. 😥 그동안 배운 내용을 한번 쭉 훑어 보면서 정리하는 시간을 가져야 할 것 같다.User가 재귀적으로 스스로에 대해 M:N 관계를 갖는 개념이 신기했다. 팔로워와 팔로잉 개념이 헷갈리긴했지만, 수업이 끝난 후 다시 살펴보니 괜찮았다.CSS강의로 배운 내용은 아직 100% 습득하지 못한 것 같다. 주말에 혼자서 실습으로 제작한 웹사이트를 혼자 만들어봐야겠다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 in progress 🚀   강의에서 학습한 flex-website 혼자 제작하기 not start   " }, { "title": "22/04/17 Django DB, SQL 복습", "url": "/posts/220417til/", "categories": "TIL/2022, 04", "tags": "til, django", "date": "2022-04-17 00:00:00 +0900", "snippet": "220417 Today I learned! Django DB , SQL 복습1. Fact(1) Django DB, SQL 복습 DJango DB 시험 (2022.04.18) 공부 Django ORM 과 1:N DB를 복습 했다. Django ORM 정리본 DJango 1:N DB 정리본 SQL 문법을 복습했다. SQL 정리본 DDL(Data Definition Language), DML(Data Manipulation Language) 위주 특히 DML에서 데이터를 조회 할 때 어떻게 쿼리문을 작성해야 하는지를 가장 중점으로 학습했다. SELECT ,WHERE, LIKE, DISTINCT, AGGREAGTE FUNCTION , GROUP BY, ORDER BY, LIMIT , OFFSET 등 2. Feeling주말 휴식 &amp; 시험 공부오늘은 시험공부에만 집중했다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 in progress 🚀   " }, { "title": "22/04/16 Django DB 복습, CSS 강의", "url": "/posts/220416til/", "categories": "TIL/2022, 04", "tags": "til, django", "date": "2022-04-16 00:00:00 +0900", "snippet": "220416 Today I learned! Django DB 복습 CSS 강의 수강 백준 문제1. Fact(1) Django DB 복습 DJango DB 시험(2022.04.18) 대비 공부 DJango ORM에 대한 복습을 했다. ORM을 활용하여 데이터를 CRUD 할 수 있다. 정리본(2) CSS 강의 css flex grid 제대로 익히기 섹션2. Flex UI 만들기를 수강했다. 실제로 어떻게 Flex를 활용하는지 알 수 있었다. Flex의 유연성을 어떻게 적용하여 편하게 레이아웃을 만드는지 감을 잡았다. 가운데 정렬을 하기 위해서는 정렬시킬 엘리먼트를 품고 있는 컨테이너 크기 자체가 브라우저에 꽉 차있어야 한다. CSS 실습관련 강의를 처음 듣기 때문에 실전 꿀팁을 많이 얻을 수 있었다. (처음 보는 속성들이 많았다) transition: CSS 속성을 변경할 때 애니메이션 속도에 대한 속성 background-size: 요소의 배경 이미지의 크기를 설정한다. (auto, cover, contain, %) overflow-x: hidden: 왼쪽과 오른쪽의 내용이 넘칠때 내용이 잘리고 스크롤바가 나타나지 않는다. /* wrap되지 않고 말줄임표 효과 넣기 */overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 수업 자료(3) 백준 문제풀기 N과 M (1) ~ N과 M (8) 조합과 순열 풀이2. Feeling월요일 시험 범위 중 하나인 SQL까지 복습을 하기로 마음을 먹었는데, 토요일인 만큼 휴식을 취하면서 쉬엄쉬엄 공부했다.CSS강의를 들으면서 나는 아직 CSS 잘 다루지 못한다는 것을 새삼 느끼게 되었다… 🥺하지만, 새롭게 배우는 것이 많은만큼 강의는 재밌고 유익했다.3. Finding 의도를 명확하게 가지고 코드를 입력해야 한다.CSS강의를 들으면서 강사님이 지속적으로 어떤 의도로 이런 코드를 작성했는 지 수강하는 학생들에게 명확히 말해주었다. 이렇게 내가 의도하는 것은 명확해야 하고 그것에 맞는 코드를 작성해야 한다. 요즘들어, 배운 내용을 외우듯이 기계적으로 코드를 작성할 때가 많았던 것 같아서 나름 반성 중..👀 HTML img태그와 CSS background-image 속성의 차이사실 그동안, 이미지는 무조건 HTML의 이미지 태그를 활용하는 줄 알았다. 하지만 CSS로 편리하게 이미지를 다루기 위해서는 CSS의 backgourd-image 속성을 사용하기도 한다. 특히, 디자인적 요소로만 사용할 때는 이미지는 큰 의미를 갖지 않기 때문에 alt속성이 필요하지 않다. 그런 경우, CSS의 background-image 속성을 사용한다.그러나 콘텐츠로서 의미가 있을때 혹은 SEO작업을 위한 키워드가 필요할 때는 img 태그를 사용한다. 이번 강의에서는 img태그를 사용하더라도 이를 display:none처리를 하고 back-gorund 이미지를 사용하는 모습을 보여주었다.아마도 콘텐츠로서의 의미가 있어서 img태그를 사용했지만, CSS를 편하게 하기위해 이런식으로 처리를 한 것이 아닐까…🤔4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 in progress 🚀   " }, { "title": "22/04/15 관통프로젝트", "url": "/posts/220415til/", "categories": "TIL/2022, 04", "tags": "til, django", "date": "2022-04-15 00:00:00 +0900", "snippet": "220415 Today I learned! Django 관통 프로젝트 노마드 코더1. Fact(1) Django 관통 프로젝트 사용자 인증 기반 관계형 DB 설계 (user, article, comment에 대한 1:N 관계 ) 영화 커뮤니티서비스의 게시판 기능 구현 (user, article, comment에 대한 CRUD 구현 ) 회원가입, 로그인, 로그아웃, 개인 정보 수정, 비밀번호 수정 영화 관련 게시글 작성, 댓글 작성 로그인 사용자만 작성할 수 있다. 해당 게시글, 댓글 작성자만 수정 및 삭제를 할 수 있다. 이번 관통 프로젝트는 페어 프로젝트로 진행했다. 기본적으로 2인 1팀으로 방향을 제시하는 네비게이터와 코드를 입력하는 드라이버로 나뉜다. 디스코드를 통해 드라이버가 화면 공유를 하고 네비게이터의 발언에 따라 코드를 작성한다. 지속적으로 역할을 교체한다. (2) 노마드 코더 React Clone Coding 끝!!! 🎉🎉 다이나믹 url을 통해 상세 페이지에 접근할 수 있다. 유저를 /movie/영화 id 의 경로로 보내면 해당 id를 가진 영화의 상세페이지에 접근한다. use paramsURL 인자들의 key/ value 짝을 객체로 반환한다. 강의 요약본2. Feeling처음에 페어프로젝트를 진행한다는 소식을 들었을 때는 걱정이 되었는데, 팀원과 협력하여 함께 하나의 앱을 구현하는 과정은 꽤나 재밌었다! 서로가 부족한 점을 도우면서 같이 성과를 만들어나가는 것은 혼자 하는 것보다 좋은 것 같다. 서로의 코드에 대해서 이야기도 많이 하고 피드백을 하면서 진행을 했는데, 서로가 많이 배운 것 같다.노마드 코더 강의 끝! 이번에 들은 강의를 통해 느낀점은 나는 무작정 클론 코딩을 통해 배우는 것보다 (기술구현 위주의 학습) 기초부터 알아가는 과정이 재미있다. 강의를 들으면서, 대체적으로 왜 이런 코드를 작성하고 정확히 어떤 역할을 하는지 감을 잡기가 어려웠다.😥 아직 JS에 대한 기초지식이 부족해서 그런 것일 수도 있다,,, 그래도 리액트를 처음 접하는 강의여서 재밌게 들을 수 있었다. 이제는, 배운 내용을 바탕으로 진행하게 될 토이프로젝트에 대해서도 생각을 해야 할 것 같다.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 in progress 🚀   " }, { "title": "22/04/14 django 복습, ERD 설계", "url": "/posts/220414til/", "categories": "TIL/2022, 04", "tags": "til, django, algorithm", "date": "2022-04-14 00:00:00 +0900", "snippet": "220414 Today I learned! Django 관계형 DB(1:N) 복습 편의점 상품 관리 프로그램을 위한 ERD 설계 백준 dp 문제 DOM을 깨우치다1. Fact(1) Django DJgango 관계형 DB(1:N)을 복습했다. 정리본 Django 를 통해 to-do리스트를 만드는 앱을 구현하였다. 로그인한 유저가 자신이 작성한 to-do리스트를 볼 수 있다. (CREATE, READ) 로그인을 하지 않은 유저가 접근하면 로그인 페이지로 이동시킨 뒤, 로그인을 하면 next파라미터를 이용하여 원래 접근하려고 했던 페이지로 이동시킨다. 회원가입 후 자동으로 로그인이 된다. (2) ERD 설계 편의점 상품 관리 프로그램을 제작하기위해 모델링을 해야 하는 임무가 주어졌다. 1) 지점별 편의점들이 존재한다.2) 각 상품들은 특정 조건 별로 구분할 수 있다.3) 단 , User는 고려하지 않는다. 물류가 해당 권역창고에서 출하되는 것을 고려하여 먼저 지역관련 테이블들을 생성했다.(region, local region) 해당지역에 위치한 store와 관련된 테이블을 생성했다. (store_owner, store) 각 store와 관련된 재고에 대한 테이블을 생성했다. (store_category, store_item, store_item_detail)1:N 관계에 대해서만 학습했기때문에 각각의 테이블은 FK로 연결되는 1:N관계를 갖고있다.(3) 백준 1932 정수 삼각형 (dp) 풀이(4) DOM을 깨우치다 1장의 반정도를 읽었다. DOM과 Node에 대한 기초적인 지식을 얻을 수 있었다.2. FeelingERD설계는 많은 고민이 들었다. 복잡하지 않으면서, 필요한 정보가 전부 구조화되어서 볼 수 있게 만드는 일은 참 어려웠다.먼저, 내가 총괄하여 편의점의 물류를 담당하는 직원이라면 어떤 데이터를 가장 원할지 생각해보았다. 당연하게도, 가장 중요한 것은 재고의 유무이다. 해당 매장에 어떤 재고가 있는지 파악을 함으로서, 소비자들의 선호도를 파악할 수도 있다. (plan을 세우기 위함) 지금 매장이 처한 혹은 미래에 처할 Problem을 해결해 줄 수 있기 때문이다. (재고부족으로 인한 problem)그래서 가장 촛점을 맞춘것은 local storage에서 재고의 필요 유무를 빨리 파악하도록 DB테이블을 생성하는 것이였는데, 너무 조회과정이 길었다. 어느샌가 내가 넣고 싶은 데이터필드가 가득 쌓인… 산으로 가버린 테이블이 되어버렸다.. 🥺DOM을 깨우치다는 아직 JS가 능숙하지 않기 때문에 생소한 개념들이 많았다. 그래서 배우는 내용이 거의 처음 배우는 내용들이여서 천천히 읽어 나갈 예정이다.3. Finding 원하는 것보다 필요한 것을 구현하자.ERD 설계를 해보면서 느낀 점은 ‘아 이런 데이터필드가 있으면 좋지않나..? 🤔’라고 접근 하는 것보다 어떤 데이터가 필요한지 정확히 파악하는 것이 중요하다. 소위, 개발자들을 Problem을 Solve하는 사람들이라고 칭한다. 어떤 문제가 있는지 파악하고 그 문제를 해결하기 위해서 해당 기능을 구현하는 것이 맞는 순서라는 것을 새삼 깨닳게 되었다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 in progress 🚀   " }, { "title": "22/04/13 django 관계형 DB (1:N 관계)", "url": "/posts/220413til/", "categories": "TIL/2022, 04", "tags": "til, django, algorithm", "date": "2022-04-13 00:00:00 +0900", "snippet": "220413 Today I learned! Django 1:N 관계형 DB 테이블 학습 및 관련 기능 구현 백준 dp 문제 DOM을 깨우치다1. Fact(1) Django Django에서 관계형 DB테이블(1:N 관계)을 생성하고 데이터를 CRUD하는 것을 학습했다. ForeginKey를 활용하여 테이블을 참조하여 참조된 테이블의 데이터에 접근할 수 있다. 반대로 참조된 테이블이 역참조하여 참조한 테이블을 데이터에 접근할 수 있다. Custom User모델을 생성하여 default User Model을 재정의(오버라이드)했다. 아래의 표와 같은 관계를 이해하고 해당 테이블의 데이터를 CRUD하는 방법을 배웠다. 정리본   관계 관계 테이블 User 1   auth_user Article N 1 articles_article Comment N N articles_comment (2) 백준 1149 RGB거리 (dp) 풀이(3) DOM을 깨우치다 오늘 1장을 전부 읽으려 했으나…🙄2. Feeling시간을 효율적으로 잘 써야할 것 같다. AM 3시 전에는 자야 그 다음날 생활에 무리가 없다. 먼저, (1) 수업 복습 (2) 1일 1알고를 default로 진행하고 시간 여유가 된다면 하고 싶은 공부를 해야 할 것 같다.추가로 하고 싶은 공부는 많지만, 남은 기간을 생각하자.3. Findingnull;4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 start 🚀 책이 도착했다!   " }, { "title": "22/04/12 django 복습, 삼성 SW 역량 테스트 a형 모의 시험", "url": "/posts/220412til/", "categories": "TIL/2022, 04", "tags": "til, django, algorithm", "date": "2022-04-12 00:00:00 +0900", "snippet": "220412 Today I learned! Django를 통한 인증(로그인, 회원가입) 기능 구현 삼성 SW 역량 테스트 a형 모의 시험 백준 dp 문제1. Fact(1) Django 어제 학습한 로그인과 로그아웃 기능 (session을 create, delete), 회원가입, 수정, 탈퇴 기능 (user을 create, read, update, delete) 복습을 했다. Django GIT에서 어제 배운 다양한 모델폼을 직접 살펴보면서 해당 모델폼의 특징을 이해할 수 있었다.(2) 삼성 SW 역량 테스트 a형 모의 시험 17:40 ~ 20:30동안 치뤄지는 모의 시험 참여했다.(3) 백준 문제 풀다가 피곤해서 fail 😥 내일 다시 풀어보기 문제2. FeelingDjango GIT과 공식문서를 보면서 혼자 이리저리 찾아보고 깨닳아가는 과정이 재미있었다. 단순하게 구현하는 코드를 암기 하는 것이 아니라 왜 이런 메서드와 속성이 쓰이는지 이해하고 코드를 작성하니까 습득도 더 빠른 것같다.삼성 SW 역량 테스트의 경우, 생각보다 어려웠다.내가 알고 있는 알고리즘 템플릿 위주로 생각하며 문제를 풀려고 했던 것 같다. 생각을 확장하자.3. Finding Django GITHUB를 살펴보면서 실제로 클래스를 어떻게 사용하는지 볼 수 있었다.python을 배울 때 클래스에 대해 학습을 했지만, 실제로 어떻게 적용하는지 볼 기회는 그리 많지 않았다.Django의 built-in form들이 상속의 상속을 받는 서브클래스이다보니 부모클래스를 하나씩 살펴보았고 왜 이런 메서드와 속성이 사용되는지 알수 있었다.직접 체계적으로 구조화된 클래스들을 보면서 클래스가 이렇게 쓰이는구나 싶었다.클래스를 만들어서 활용해본 경험이 거의 전무한데, 한번 시도해봐야겠다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 Not started 👀   " }, { "title": "22/04/11 django 인증 기능 구현", "url": "/posts/220411til/", "categories": "TIL/2022, 04", "tags": "til, django, algorithm", "date": "2022-04-11 00:00:00 +0900", "snippet": "220411 Today I learned! Django를 통한 인증(로그인, 회원가입) 기능 구현 백준 BFS 문제1. Fact(1) Django 로그인과 로그아웃 기능 (session을 create, delete)을 구현했다. 회원가입, 수정, 탈퇴 기능 (user을 create, read, update, delete)을 구현했다. 정리built-in ModelForm, login(), logout(request)함수등을 활용하여 비교적 쉽게 할 수 있었다.또한, is_authenticated, @login_required 를 통해 인증 되지 않은 사용자에 대해 특정 기능에 접근을 제한 시키는 것을 학습했다.(2) 백준 solving 그룹 문제집에 있는 bfs 문제 풀이2. FeelingDJango 기능에 대해 배우는 양이 많아진 것 같다.그래도 수업 내용과 공식문서를 통해 추가 학습한 내용을 md파일로 정리하는 것은 꽤나 학습에 도움이 되는 것 같다. 시간이 오래걸리는 것이 단점이지만..😥그리고 이번에 쿠키와 session을 배우면서 TCP, UDP와 같은 개념들이 등장했는데, 기초적인 지식이 부족한 것을 느꼈다. 이전에 선물받은 책이 있는데 이번 기회에 다시 읽어봐야 겠다.3. Finding 세션에 대한 개념을 직접 구현하면서 확실히 정리했다. 😏로그인과 로그아웃을 구현하면서, 크롬 개발자 도구와 data base(django는 기본적으로 Database- backend sessions 저장방식을 사용)를 통해 sessionid가 생성되고 삭제 되는 과정을 볼 수 있었다. 그동안, 쿠키와 세션은 머리로는 이해되었지만 와닿지 않는 개념들이였는데 직접 다루면서 확실하게 정리된 것 같다.4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 Not started 👀   " }, { "title": "22/04/10 알고리즘 PS(DP), React복습", "url": "/posts/220410til/", "categories": "TIL/2022, 04", "tags": "til, react, algorithm", "date": "2022-04-10 00:00:00 +0900", "snippet": "220410 Today I learned! 백준 DP 기초 문제 React 복습1. Fact(1) 백준 solving DP에 단계별로 풀기 1단계 문제 다익스트라 알고리즘을 활용한 graph 문제 풀이(2) 노마드 코더 react 강의 복습 coin관련 api를 통해 현재 코인의 시세와 USD를 KRW로 환산해주는 Coin Converter를 만들며 복습했다. 리액트의 핵심인 useState, useEffect를 많이 활용하면서 익숙해질 수 있었다.2. FeelingDP, react를 배운 지 한 주정도 지나서 복습의 필요성을 느꼈다.알고리즘의 경우 이론부터 천천히 공부하고 있어서 문제를 푸는데 큰 어려움을 느끼지는 못했다.리액트는 막상 코드를 보지 않고 직접 구현을 하려고 하니 꽤나 어려웠다. 주기적으로 계속 복습을 해야 할 것 같다.3. Finding DP의 경우, 탑다운 방식과 바텀 업 방식의 차이점을 알 수 있었다.DFS 백트래킹으로 문제를 자주 풀다보니 재귀를 활용하는 탑 다운방식이 익숙했는데, 주어지는 N이 클수록 재귀를 통해 푸는 방법은 메모리에 부담이 간다.N이 크다면, for문을 활용한 바텀 업 방식으로 문제를 풀어나가자. 리액트 스타일 속성에 대한 궁금증 해결!리액트에서 스타일 속성을 사용할 때, 중괄호를 연속으로 두개 사용하는 이유가 궁금했다. JSX에서 자바스크립트 문법을 쓰려면 {}를 써야 한다. 스타일을 적용할 때 객체 형식으로 넣어야 해서 {}를 사용해야 한다. (스타일 또한 객체이다.)그런데 2번에 대한 내용이 이해가 잘 가지 않아서 더 찾아보게 되었다. DOM, SSOM, 파싱 등과 같은 개념이 등장했고, DOM에 대해 집중탐구를 하고 싶다는 생각이 들었다. 실무에서 크게 필요하지 않은 지식일 수도 있지만, 개인적으로 궁금해서 관련 도서를 구매했다. 😉4. Future Action &amp; Feedback Future Action 진행 상황 Feedback DOM을 깨우치다 Not started 👀   " }, { "title": "개인 기록 공간입니다.", "url": "/posts/hello/", "categories": "Blogging, Hello", "tags": "blogging", "date": "2022-04-09 00:00:00 +0900", "snippet": " 어서오세요（＾∀＾●）ﾉｼ" } ]
